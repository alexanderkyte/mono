mini/abcremoval.c:	printf ("Dump of evaluation area (%d variables):\n", area->cfg->num_varinfo);
mini/abcremoval.c:	for (i = 0; i < area->cfg->num_varinfo; i++) {
mini/abcremoval.c:	printf ("Dump of evaluation area contexts (%d variables):\n", area->cfg->num_varinfo);
mini/abcremoval.c:	for (i = 0; i < area->cfg->num_varinfo; i++) {
mini/abcremoval.c:	clean_contexts (area, area->cfg->next_vreg);
mini/abcremoval.c:	clean_contexts (area, area->cfg->next_vreg);
mini/abcremoval.c:	rel = (MonoAdditionalVariableRelation *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoAdditionalVariableRelation));
mini/abcremoval.c:	*check_relations = g_slist_append_mempool (cfg->mempool, *check_relations, rel);
mini/abcremoval.c:				rel = (MonoAdditionalVariableRelation *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoAdditionalVariableRelation));
mini/abcremoval.c:				check_relations = g_slist_append_mempool (cfg->mempool, check_relations, rel);
mini/abcremoval.c:				rel = (MonoAdditionalVariableRelation *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoAdditionalVariableRelation));
mini/abcremoval.c:				check_relations = g_slist_append_mempool (cfg->mempool, check_relations, rel);
mini/abcremoval.c:	verbose_level = cfg->verbose_level;
mini/abcremoval.c:		printf ("\nRemoving array bound checks in %s\n", mono_method_full_name (cfg->method, TRUE));
mini/abcremoval.c:		mono_mempool_alloc (cfg->mempool, sizeof (MonoSummarizedValueRelation) * (cfg->next_vreg) * 2);
mini/abcremoval.c:		mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRelationsEvaluationContext) * (cfg->next_vreg));
mini/abcremoval.c:		mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRelationsEvaluationStatus) * (cfg->next_vreg));
mini/abcremoval.c:		mono_mempool_alloc (cfg->mempool, sizeof (MonoIntegerValueKind) * (cfg->next_vreg));
mini/abcremoval.c:	area.defs = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * cfg->next_vreg);
mini/abcremoval.c:	for (i = 0; i < cfg->next_vreg; i++) {
mini/abcremoval.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/abcremoval.c:					type_relation = (MonoSummarizedValueRelation *) mono_mempool_alloc (cfg->mempool, sizeof (MonoSummarizedValueRelation));
mini/abcremoval.c:					type_relation = (MonoSummarizedValueRelation *) mono_mempool_alloc (cfg->mempool, sizeof (MonoSummarizedValueRelation));
mini/abcremoval.c:	for (i = 0; i < cfg->next_vreg; i++) {
mini/abcremoval.c:			int related_index = cfg->next_vreg + i;
mini/abcremoval.c:	process_block (cfg, cfg->bblocks [0], &area);
mini/alias-analysis.c:		if (cfg->verbose_level > 2)
mini/alias-analysis.c:		if (cfg->verbose_level > 2) 
mini/alias-analysis.c:		if (cfg->verbose_level > 2) { printf ("mem2reg replacing: "); mono_print_ins (load); }
mini/alias-analysis.c:		if (cfg->verbose_level > 2)
mini/alias-analysis.c:		if (cfg->verbose_level > 2) 
mini/alias-analysis.c:		if (cfg->verbose_level > 2) { printf ("mem2reg replacing: "); mono_print_ins (store); }
mini/alias-analysis.c:			if (cfg->verbose_level > 2) printf ("Incompatible variable of size != 4\n");
mini/alias-analysis.c:		if (cfg->verbose_level > 2) { printf ("mem2reg replacing: "); mono_print_ins (store); }
mini/alias-analysis.c:			if (cfg->verbose_level > 2) printf ("Incompatible variable of size != 8\n");
mini/alias-analysis.c:		if (cfg->verbose_level > 2) { printf ("mem2reg replacing: "); mono_print_ins (store); }
mini/alias-analysis.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/alias-analysis.c:				if (cfg->verbose_level > 2) { printf ("New address: "); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 2) { printf ("New alias: "); mono_print_ins (ins); }
mini/alias-analysis.c:						if (cfg->verbose_level > 2) { printf ("Killed alias: "); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 2) { printf ("Found candidate load:"); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 2) { printf ("Found candidate store:"); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 2) { printf ("Found candidate store-imm:"); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 2) { printf ("Found null check over local: "); mono_print_ins (ins); }
mini/alias-analysis.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/alias-analysis.c:		MonoInst *var = cfg->varinfo [i];
mini/alias-analysis.c:			if (cfg->verbose_level > 2) {
mini/alias-analysis.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/alias-analysis.c:				if (cfg->verbose_level > 2) { printf ("Found op :"); mono_print_ins (ins); }
mini/alias-analysis.c:					if (cfg->verbose_level > 1) { printf ("Restoring :"); mono_print_ins (var); }
mini/alias-analysis.c:		if (cfg->verbose_level > 2) {
mini/alias-analysis.c:			printf ("Method: %s\n", mono_method_full_name (cfg->method, 1));
mini/alias-analysis.c:	if (!cfg->has_indirection)
mini/alias-analysis.c:	if (cfg->verbose_level > 2)
mini/alias-analysis.c:	if (cfg->opt & MONO_OPT_DEADCE)
mini/alias-analysis.c:		if (cfg->opt & MONO_OPT_DEADCE)
mini/alias-analysis.c:	if (cfg->verbose_level > 2)
mini/aot-compiler.c:	if (acfg->logfile)
mini/aot-compiler.c:		output = acfg->logfile;
mini/aot-compiler.c:	if (acfg->logfile)
mini/aot-compiler.c:		output = acfg->logfile;
mini/aot-compiler.c:	if (acfg->logfile)
mini/aot-compiler.c:		output = acfg->logfile;
mini/aot-compiler.c:	mono_img_writer_emit_section_change (acfg->w, section_name, subsection_index);
mini/aot-compiler.c:		mono_img_writer_emit_label (acfg->w, mangled_symbol_name);
mini/aot-compiler.c:	mono_img_writer_emit_local_symbol (acfg->w, mangled_symbol_name, end_label, func);
mini/aot-compiler.c:	mono_img_writer_emit_local_symbol (acfg->w, name, end_label, func);
mini/aot-compiler.c:	mono_img_writer_emit_label (acfg->w, name); 
mini/aot-compiler.c:	mono_img_writer_emit_bytes (acfg->w, buf, size); 
mini/aot-compiler.c:	mono_img_writer_emit_string (acfg->w, value); 
mini/aot-compiler.c:	mono_img_writer_emit_line (acfg->w); 
mini/aot-compiler.c:	mono_img_writer_emit_alignment (acfg->w, size);
mini/aot-compiler.c:	if (acfg->align_pad_value)
mini/aot-compiler.c:		mono_img_writer_emit_alignment_fill (acfg->w, size, acfg->align_pad_value);
mini/aot-compiler.c:		mono_img_writer_emit_alignment (acfg->w, size);
mini/aot-compiler.c:	if (acfg->align_pad_value) {
mini/aot-compiler.c:			buf [i] = acfg->align_pad_value;
mini/aot-compiler.c:	mono_img_writer_emit_pointer (acfg->w, target); 
mini/aot-compiler.c:		mono_img_writer_emit_pointer (acfg->w, s);
mini/aot-compiler.c:		mono_img_writer_emit_pointer (acfg->w, target);
mini/aot-compiler.c:	mono_img_writer_emit_int16 (acfg->w, value); 
mini/aot-compiler.c:	mono_img_writer_emit_int32 (acfg->w, value); 
mini/aot-compiler.c:	mono_img_writer_emit_symbol_diff (acfg->w, end, start, offset); 
mini/aot-compiler.c:	mono_img_writer_emit_zero_bytes (acfg->w, num); 
mini/aot-compiler.c:	mono_img_writer_emit_byte (acfg->w, val); 
mini/aot-compiler.c:		mono_img_writer_emit_label (acfg->w, mangled_symbol_name);
mini/aot-compiler.c:	mono_img_writer_emit_global (acfg->w, mangled_symbol_name, func);
mini/aot-compiler.c:	mono_img_writer_emit_global (acfg->w, name, func);
mini/aot-compiler.c:	return !acfg->aot_opts.static_link && !acfg->aot_opts.asm_only;
mini/aot-compiler.c:	return acfg->aot_opts.no_dlsym || link_shared_library (acfg);
mini/aot-compiler.c:	return acfg->aot_opts.no_dlsym;
mini/aot-compiler.c:		g_ptr_array_add (acfg->globals, g_strdup (name));
mini/aot-compiler.c:	if (acfg->aot_opts.no_dlsym) {
mini/aot-compiler.c:		mono_img_writer_emit_local_symbol (acfg->w, name, NULL, func);
mini/aot-compiler.c:	mono_img_writer_emit_symbol_size (acfg->w, name, end_label);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		sprintf (symbol, "%s%s%s", acfg->user_symbol_prefix, acfg->global_prefix, name);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:	mono_img_writer_emit_section_change (acfg->w, RODATA_SECT, 1);
mini/aot-compiler.c:	mono_img_writer_emit_label (acfg->w, name);
mini/aot-compiler.c:	mono_img_writer_emit_string (acfg->w, value);
mini/aot-compiler.c:	mono_img_writer_emit_unset_mode (acfg->w);
mini/aot-compiler.c:	fprintf (acfg->fp, ".code 16\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".code 32\n");
mini/aot-compiler.c:		fprintf (acfg->fp, "%s 0x%x\n", acfg->inst_directive, *(guint32*)(buf + i));
mini/aot-compiler.c:	acfg->llc_args = g_string_new ("");
mini/aot-compiler.c:	acfg->as_args = g_string_new ("");
mini/aot-compiler.c:	acfg->llvm_owriter_supported = TRUE;
mini/aot-compiler.c:	acfg->llvm_label_prefix = "";
mini/aot-compiler.c:	acfg->user_symbol_prefix = "";
mini/aot-compiler.c:	g_string_append (acfg->llc_args, " -march=x86 -mattr=sse4.1");
mini/aot-compiler.c:	g_string_append (acfg->llc_args, " -march=x86-64 -mattr=sse4.1");
mini/aot-compiler.c:	acfg->align_pad_value = 0x90;
mini/aot-compiler.c:	if (acfg->aot_opts.mtriple && strstr (acfg->aot_opts.mtriple, "darwin")) {
mini/aot-compiler.c:		g_string_append (acfg->llc_args, "-mattr=+v6");
mini/aot-compiler.c:		g_string_append (acfg->llc_args, " -mattr=+vfp2,-neon,+d16 -float-abi=hard");
mini/aot-compiler.c:		g_string_append (acfg->as_args, " -mfpu=vfp3");
mini/aot-compiler.c:		g_string_append (acfg->llc_args, " -mattr=+vfp2,-neon,+d16");
mini/aot-compiler.c:		g_string_append (acfg->as_args, " -mfpu=vfp3");
mini/aot-compiler.c:		g_string_append (acfg->llc_args, " -soft-float");
mini/aot-compiler.c:	if (acfg->aot_opts.mtriple && strstr (acfg->aot_opts.mtriple, "thumb"))
mini/aot-compiler.c:		acfg->thumb_mixed = TRUE;
mini/aot-compiler.c:	if (acfg->aot_opts.mtriple)
mini/aot-compiler.c:		mono_arch_set_target (acfg->aot_opts.mtriple);
mini/aot-compiler.c:	acfg->inst_directive = ".inst";
mini/aot-compiler.c:	if (acfg->aot_opts.mtriple)
mini/aot-compiler.c:		mono_arch_set_target (acfg->aot_opts.mtriple);
mini/aot-compiler.c:	acfg->user_symbol_prefix = "_";
mini/aot-compiler.c:	acfg->llvm_label_prefix = "_";
mini/aot-compiler.c:	acfg->inst_directive = ".word";
mini/aot-compiler.c:	acfg->need_no_dead_strip = TRUE;
mini/aot-compiler.c:	acfg->aot_opts.gnu_asm = TRUE;
mini/aot-compiler.c:	acfg->need_pt_gnu_stack = TRUE;
mini/aot-compiler.c:	acfg->global_symbols = TRUE;
mini/aot-compiler.c:	acfg->llvm_owriter_supported = FALSE;
mini/aot-compiler.c:	g_assert (acfg->fp);
mini/aot-compiler.c:	fprintf (acfg->fp, "adrp x16, %s@PAGE+%d\n", acfg->got_symbol, offset & 0xfffff000);
mini/aot-compiler.c:	fprintf (acfg->fp, "add x16, x16, %s@PAGEOFF\n", acfg->got_symbol);
mini/aot-compiler.c:	fprintf (acfg->fp, "ldr x%d, [x16, #%d]\n", dreg, offset & 0xfff);
mini/aot-compiler.c:	fprintf (acfg->fp, "adrp x16, %s+%d\n", acfg->got_symbol, offset & 0xfffff000);
mini/aot-compiler.c:	fprintf (acfg->fp, "add x16, x16, :lo12:%s\n", acfg->got_symbol);
mini/aot-compiler.c:	fprintf (acfg->fp, "ldr x%d, [x16, %d]\n", dreg, offset & 0xfff);
mini/aot-compiler.c:	g_assert (acfg->fp);
mini/aot-compiler.c:	fprintf (acfg->fp, "adrp x%d, L_OBJC_SELECTOR_REFERENCES_%d@PAGE\n", reg, index);
mini/aot-compiler.c:	fprintf (acfg->fp, "add x%d, x%d, L_OBJC_SELECTOR_REFERENCES_%d@PAGEOFF\n", reg, reg, index);
mini/aot-compiler.c:	fprintf (acfg->fp, "ldr x%d, [x%d]\n", reg, reg);
mini/aot-compiler.c:	g_assert (acfg->fp);
mini/aot-compiler.c:		fprintf (acfg->fp, "b %s\n", target);
mini/aot-compiler.c:		fprintf (acfg->fp, "bl %s\n", target);
mini/aot-compiler.c:	fprintf (acfg->fp, "br x16\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "%s %d\n", acfg->inst_directive, info_offset);
mini/aot-compiler.c:	if (!acfg->aot_opts.use_trampolines_page)
mini/aot-compiler.c:	acfg->tramp_page_size = pagesize;
mini/aot-compiler.c:	sprintf (symbol, "%sspecific_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_SPECIFIC] = common_tramp_size;
mini/aot-compiler.c:	sprintf (symbol, "%srgctx_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_STATIC_RGCTX] = common_tramp_size;
mini/aot-compiler.c:	sprintf (symbol, "%sgsharedvt_arg_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_GSHAREDVT_ARG] = common_tramp_size;
mini/aot-compiler.c:	sprintf (symbol, "%simt_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_IMT] = common_tramp_size;
mini/aot-compiler.c:	fprintf (acfg->fp, "br x16\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "add x0, x0, %d\n", (int)(sizeof (MonoObject)));
mini/aot-compiler.c:	fprintf (acfg->fp, "b %s\n", call_target);
mini/aot-compiler.c:	fprintf (acfg->fp, "br x16\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "br x16\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "call %s\n", target);
mini/aot-compiler.c:		fprintf (acfg->fp, "blx %s\n", target);
mini/aot-compiler.c:		fprintf (acfg->fp, "bl %s\n", target);
mini/aot-compiler.c:	fprintf (acfg->fp, "bl %s\n", target);
mini/aot-compiler.c:	fprintf (acfg->fp, ".L%d:\n", acfg->label_generator);
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 0, (.Lgot_addr + 4 - .L%d)@h\n", acfg->label_generator);
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 0, 0, (.Lgot_addr + 4 - .L%d)@l\n", acfg->label_generator);
mini/aot-compiler.c:	fprintf (acfg->fp, "add 30, 30, 0\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 30, 0(30)\n", PPC_LD_OP);
mini/aot-compiler.c:	acfg->label_generator ++;
mini/aot-compiler.c:	fprintf (acfg->fp, ".L%d:\n", acfg->label_generator);
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 0, (%s + 4 - .L%d)@h\n", acfg->got_symbol, acfg->label_generator);
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 0, 0, (%s + 4 - .L%d)@l\n", acfg->got_symbol, acfg->label_generator);
mini/aot-compiler.c:	acfg->label_generator ++;
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", offset);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "mov %s+%d(%%rip), %s\n", got_symbol, (unsigned int) ((got_slot * sizeof (gpointer))), mono_arch_regname (dreg));
mini/aot-compiler.c:	int lindex = acfg->objc_selector_index_2 ++;
mini/aot-compiler.c:	mono_img_writer_emit_unset_mode (acfg->w);
mini/aot-compiler.c:	fprintf (acfg->fp, ".long %s-(%s+12)", symbol2, symbol1);
mini/aot-compiler.c:		fprintf (acfg->fp, "jmp *%s+%d(%%rip)\n", got_symbol, offset);
mini/aot-compiler.c:		acfg->stats.plt_size += 10;
mini/aot-compiler.c:		fprintf (acfg->fp, "lis 11, %d@h\n", offset);
mini/aot-compiler.c:		fprintf (acfg->fp, "ori 11, 11, %d@l\n", offset);
mini/aot-compiler.c:		fprintf (acfg->fp, "add 11, 11, 30\n");
mini/aot-compiler.c:		fprintf (acfg->fp, "%s 11, 0(11)\n", PPC_LD_OP);
mini/aot-compiler.c:		fprintf (acfg->fp, "%s 2, %d(11)\n", PPC_LD_OP, (int)sizeof (gpointer));
mini/aot-compiler.c:		fprintf (acfg->fp, "%s 11, 0(11)\n", PPC_LD_OP);
mini/aot-compiler.c:		fprintf (acfg->fp, "mtctr 11\n");
mini/aot-compiler.c:		fprintf (acfg->fp, "bctr\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "ldr ip, [pc, #8]\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "add ip, pc, ip\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "ldr ip, [ip, #0]\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "bx ip\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".4byte 0xc008f8df\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".2byte 0x44fc\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".4byte 0xc000f8dc\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".2byte 0x4760\n");
mini/aot-compiler.c:	if (!acfg->aot_opts.use_trampolines_page)
mini/aot-compiler.c:	acfg->tramp_page_size = pagesize;
mini/aot-compiler.c:	sprintf (symbol, "%sspecific_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%srgctx_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%sgsharedvt_arg_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%simt_trampolines_page", acfg->user_symbol_prefix);
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_SPECIFIC] = 16;
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_STATIC_RGCTX] = 16;
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_IMT] = 72;
mini/aot-compiler.c:	acfg->tramp_page_code_offsets [MONO_AOT_TRAMP_GSHAREDVT_ARG] = 16;
mini/aot-compiler.c:	sprintf (symbol, "%sspecific_trampolines_page_gen_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%sspecific_trampolines_page_sp_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%srgctx_trampolines_page_gen_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%srgctx_trampolines_page_sp_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%sgsharedvt_trampolines_page_gen_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%sgsharedvt_trampolines_page_sp_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%simt_trampolines_page_gen_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	sprintf (symbol, "%simt_trampolines_page_sp_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "call *%s+%d(%%rip)\n", acfg->got_symbol, (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:		emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) - 4);
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) - 4 + 4);
mini/aot-compiler.c:	//emit_symbol_diff (acfg, acfg->got_symbol, ".", ((offset + 1) * sizeof (gpointer)) - 4 + 8);
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 0, %d(30)\n", PPC_LD_OP, (int)sizeof (gpointer));
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 11, %d@h\n", (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 11, 11, %d@l\n", (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 11, 11, 0\n", PPC_LDX_OP);
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 11, 0(11)\n", PPC_LD_OP);
mini/aot-compiler.c:	fprintf (acfg->fp, "mtctr 11\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 11, %d@h\n", (int)((offset + 1) * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 11, 11, %d@l\n", (int)((offset + 1) * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 0, 11, 0\n", PPC_LDX_OP);
mini/aot-compiler.c:	fprintf (acfg->fp, "bctr\n");
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "jmp %s\n", call_target);
mini/aot-compiler.c:	if (acfg->thumb_mixed && cfg->compile_llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "add r0, r0, #%d\n", (int)sizeof (MonoObject));
mini/aot-compiler.c:		fprintf (acfg->fp, "b %s\n", call_target);
mini/aot-compiler.c:		fprintf (acfg->fp, ".arm\n");
mini/aot-compiler.c:		fprintf (acfg->fp, ".align 2\n");
mini/aot-compiler.c:	if (acfg->thumb_mixed && cfg->compile_llvm)
mini/aot-compiler.c:		fprintf (acfg->fp, "\n\tbx %s\n", call_target);
mini/aot-compiler.c:		fprintf (acfg->fp, "\n\tb %s\n", call_target);
mini/aot-compiler.c:	fprintf (acfg->fp, "\n\taddi %d, %d, %d\n", this_pos, this_pos, (int)sizeof (MonoObject));
mini/aot-compiler.c:	fprintf (acfg->fp, "\n\tb %s\n", call_target);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "mov %s+%d(%%rip), %%r10\n", acfg->got_symbol, (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:		fprintf (acfg->fp, "jmp *%s+%d(%%rip)\n", acfg->got_symbol, (int)((offset + 1) * sizeof (gpointer)));
mini/aot-compiler.c:		emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) - 4);
mini/aot-compiler.c:		emit_symbol_diff (acfg, acfg->got_symbol, ".", ((offset + 1) * sizeof (gpointer)) - 4);
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) - 4 + 8);
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", ((offset + 1) * sizeof (gpointer)) - 4 + 4);
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 0, %d(30)\n", PPC_LD_OP, (int)sizeof (gpointer));
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 11, %d@h\n", (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 11, 11, %d@l\n", (int)(offset * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "%s %d, 11, 0\n", PPC_LDX_OP, MONO_ARCH_RGCTX_REG);
mini/aot-compiler.c:	fprintf (acfg->fp, "lis 11, %d@h\n", (int)((offset + 1) * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "ori 11, 11, %d@l\n", (int)((offset + 1) * sizeof (gpointer)));
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 11, 11, 0\n", PPC_LDX_OP);
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 2, %d(11)\n", PPC_LD_OP, (int)sizeof (gpointer));
mini/aot-compiler.c:	fprintf (acfg->fp, "%s 11, 0(11)\n", PPC_LD_OP);
mini/aot-compiler.c:	fprintf (acfg->fp, "mtctr 11\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "bctr\n");
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		fprintf (acfg->fp, "mov %s+%d(%%rip), %s\n", acfg->got_symbol, (int)(offset * sizeof (gpointer)), mono_arch_regname (MONO_ARCH_IMT_SCRATCH_REG));
mini/aot-compiler.c:	if (!acfg->llvm) {
mini/aot-compiler.c:		emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) - 4);
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) + (code - (labels [0] + 8)) - 4);
mini/aot-compiler.c:	g_assert (acfg->fp);
mini/aot-compiler.c:	fprintf (acfg->fp, "mov %s+%d(%%rip), %s\n", acfg->got_symbol, (unsigned int) ((got_slot * sizeof (gpointer))), mono_arch_regname (dreg));
mini/aot-compiler.c:	emit_symbol_diff (acfg, acfg->got_symbol, ".", (offset * sizeof (gpointer)) + 4);
mini/aot-compiler.c:	fprintf (acfg->fp, "jmp *%%r11\n");
mini/aot-compiler.c:	g_assert (!acfg->blob_closed);
mini/aot-compiler.c:	if (acfg->blob.alloc_size == 0)
mini/aot-compiler.c:		stream_init (&acfg->blob);
mini/aot-compiler.c:	return add_stream_data (&acfg->blob, (char*)data, data_len);
mini/aot-compiler.c:	if (acfg->blob.alloc_size == 0)
mini/aot-compiler.c:		stream_init (&acfg->blob);
mini/aot-compiler.c:	count = acfg->blob.index % align;
mini/aot-compiler.c:		add_stream_data (&acfg->blob, buf, 4 - count);
mini/aot-compiler.c:	return add_stream_data (&acfg->blob, (char*)data, data_len);
mini/aot-compiler.c:	if (acfg->data_outfile) {
mini/aot-compiler.c:		acfg->table_offsets [(int)table] = acfg->datafile_offset;
mini/aot-compiler.c:		fwrite (data,1, size, acfg->data_outfile);
mini/aot-compiler.c:		acfg->datafile_offset += size;
mini/aot-compiler.c:		acfg->datafile_offset += align;
mini/aot-compiler.c:		fwrite (align_buf, align, 1, acfg->data_outfile);
mini/aot-compiler.c:	} else if (acfg->llvm) {
mini/aot-compiler.c:	index = GPOINTER_TO_UINT (g_hash_table_lookup (cfg->image_hash, image));
mini/aot-compiler.c:		index = g_hash_table_size (cfg->image_hash);
mini/aot-compiler.c:		g_hash_table_insert (cfg->image_hash, image, GUINT_TO_POINTER (index + 1));
mini/aot-compiler.c:		g_ptr_array_add (cfg->image_table, image);
mini/aot-compiler.c:	int len = acfg->image->tables [MONO_TABLE_TYPESPEC].rows;
mini/aot-compiler.c:	if (!acfg->typespec_classes) {
mini/aot-compiler.c:		acfg->typespec_classes = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:			MonoClass *klass_key = mono_class_get_and_inflate_typespec_checked (acfg->image, typespec, NULL, &error);
mini/aot-compiler.c:			g_hash_table_insert (acfg->typespec_classes, klass_key, GINT_TO_POINTER (typespec));
mini/aot-compiler.c:	return GPOINTER_TO_INT (g_hash_table_lookup (acfg->typespec_classes, klass));
mini/aot-compiler.c:		guint offset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->klass_blob_hash, klass));
mini/aot-compiler.c:			g_hash_table_insert (acfg->klass_blob_hash, klass, GUINT_TO_POINTER (offset + 1));
mini/aot-compiler.c:		ji = (MonoJumpInfoToken *)g_hash_table_lookup (acfg->token_info_hash, method);
mini/aot-compiler.c:		ji = (MonoJumpInfoToken *)g_hash_table_lookup (acfg->token_info_hash, method);
mini/aot-compiler.c:	return g_strdup_printf ("%sp_%d", acfg->llvm_label_prefix, plt_offset);
mini/aot-compiler.c:	return g_strdup_printf ("%sp_%d", acfg->temp_prefix, plt_offset);
mini/aot-compiler.c:	if (!acfg->patch_to_plt_entry [patch_info->type])
mini/aot-compiler.c:		acfg->patch_to_plt_entry [patch_info->type] = g_hash_table_new (mono_patch_info_hash, mono_patch_info_equal);
mini/aot-compiler.c:	res = (MonoPltEntry *)g_hash_table_lookup (acfg->patch_to_plt_entry [patch_info->type], patch_info);
mini/aot-compiler.c:	if (!acfg->llvm && patch_info->type == MONO_PATCH_INFO_METHOD && (patch_info->data.method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED)) {
mini/aot-compiler.c:		new_ji = mono_patch_info_dup_mp (acfg->mempool, patch_info);
mini/aot-compiler.c:		res = (MonoPltEntry *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoPltEntry));
mini/aot-compiler.c:		res->plt_offset = acfg->plt_offset;
mini/aot-compiler.c:		if (acfg->aot_opts.write_symbols)
mini/aot-compiler.c:			res->debug_sym = get_plt_entry_debug_sym (acfg, res->ji, acfg->plt_entry_debug_sym_cache);
mini/aot-compiler.c:		g_hash_table_insert (acfg->patch_to_plt_entry [new_ji->type], new_ji, res);
mini/aot-compiler.c:		g_hash_table_insert (acfg->plt_offset_to_entry, GUINT_TO_POINTER (res->plt_offset), res);
mini/aot-compiler.c:		//g_hash_table_print_stats (acfg->patch_to_plt_entry);
mini/aot-compiler.c:		acfg->plt_offset ++;
mini/aot-compiler.c:	GotInfo *info = llvm ? &acfg->llvm_got_info : &acfg->got_info;
mini/aot-compiler.c:		got_offset = acfg->llvm_got_offset;
mini/aot-compiler.c:		acfg->llvm_got_offset ++;
mini/aot-compiler.c:		got_offset = acfg->got_offset;
mini/aot-compiler.c:		acfg->got_offset ++;
mini/aot-compiler.c:	acfg->stats.got_slots ++;
mini/aot-compiler.c:	acfg->stats.got_slot_types [ji->type] ++;
mini/aot-compiler.c:	if (!g_hash_table_lookup (acfg->method_indexes, method)) {
mini/aot-compiler.c:		g_ptr_array_add (acfg->methods, method);
mini/aot-compiler.c:		g_hash_table_insert (acfg->method_indexes, method, GUINT_TO_POINTER (index + 1));
mini/aot-compiler.c:		acfg->nmethods = acfg->methods->len + 1;
mini/aot-compiler.c:		g_ptr_array_add (acfg->extra_methods, method);
mini/aot-compiler.c:	int index = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_indexes, method));
mini/aot-compiler.c:	index = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_indexes, method));
mini/aot-compiler.c:	index = acfg->method_index;
mini/aot-compiler.c:	g_ptr_array_add (acfg->method_order, GUINT_TO_POINTER (index));
mini/aot-compiler.c:	g_hash_table_insert (acfg->method_depth, method, GUINT_TO_POINTER (depth));
mini/aot-compiler.c:	acfg->method_index ++;
mini/aot-compiler.c:	else if ((acfg->opts & MONO_OPT_GSHAREDVT) && prefer_gsharedvt_method (acfg, method) && mono_method_is_generic_sharable_full (method, FALSE, FALSE, TRUE))
mini/aot-compiler.c:	if (acfg->aot_opts.log_generics)
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:			if (info && !has_nullable && !acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	if (strcmp (acfg->image->assembly->aname.name, "mscorlib") == 0) {
mini/aot-compiler.c:		if (!acfg->aot_opts.llvm_only)
mini/aot-compiler.c:		if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {
mini/aot-compiler.c:		klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:		} else if ((acfg->opts & MONO_OPT_GSHAREDVT) && mono_class_is_gtd (klass)) {
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPESPEC].rows; ++i) {
mini/aot-compiler.c:		klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:			if (!acfg->aot_opts.llvm_only)
mini/aot-compiler.c:			if (!acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:			} else if ((acfg->opts & MONO_OPT_GSHAREDVT) && mono_class_is_gtd (method->klass)) {
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:			if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:				t = mono_reflection_type_from_name_checked (n, acfg->image, &error);
mini/aot-compiler.c:					g_hash_table_insert (acfg->export_names, wrapper, export_name);
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {
mini/aot-compiler.c:		klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:	if (!mono_aot_mode_is_full (&acfg->aot_opts) && !mono_aot_mode_is_hybrid (&acfg->aot_opts) && !force)
mini/aot-compiler.c:	if (!acfg->ginst_hash)
mini/aot-compiler.c:		acfg->ginst_hash = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	if (!acfg->ginst_hash)
mini/aot-compiler.c:		acfg->ginst_hash = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	if (g_hash_table_lookup (acfg->ginst_hash, klass))
mini/aot-compiler.c:	if (acfg->aot_opts.log_generics)
mini/aot-compiler.c:	g_hash_table_insert (acfg->ginst_hash, klass, klass);
mini/aot-compiler.c:	if ((acfg->opts & MONO_OPT_GSHAREDVT) && klass->image == mono_defaults.corlib && mono_class_is_ginst (klass) && mono_class_get_generic_class (klass)->context.class_inst && is_vt_inst (mono_class_get_generic_class (klass)->context.class_inst) &&
mini/aot-compiler.c:		if ((acfg->opts & MONO_OPT_GSHAREDVT) && method->is_inflated && mono_method_get_context (method)->method_inst) {
mini/aot-compiler.c:		if (acfg->aot_opts.log_generics)
mini/aot-compiler.c:	if (acfg->aot_opts.no_instances)
mini/aot-compiler.c:	depth = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_depth, method));
mini/aot-compiler.c:	if (acfg->aot_opts.no_instances)
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_METHODSPEC].rows; ++i) {
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:		if (method->klass->image != acfg->image)
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPESPEC].rows; ++i) {
mini/aot-compiler.c:		klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:	for (i = 0; i < acfg->methods->len; ++i) {
mini/aot-compiler.c:		method = (MonoMethod *)g_ptr_array_index (acfg->methods, i);
mini/aot-compiler.c:	if (acfg->image == mono_defaults.corlib) {
mini/aot-compiler.c:		klass = mono_class_try_load_from_name (acfg->image, "System.Collections.Generic", "GenericComparer`1");
mini/aot-compiler.c:		klass = mono_class_try_load_from_name (acfg->image, "System.Collections.Generic", "GenericEqualityComparer`1");
mini/aot-compiler.c:		klass = mono_class_try_load_from_name (acfg->image, "System.Collections.Generic", "ICollection`1");
mini/aot-compiler.c:		klass = mono_class_try_load_from_name (acfg->image, "System.Collections.Generic", "IList`1");
mini/aot-compiler.c:		klass = mono_class_try_load_from_name (acfg->image, "System.Collections.Generic", "IEnumerable`1");
mini/aot-compiler.c:	if ((patch_info->type == MONO_PATCH_INFO_METHOD) && (patch_info->data.method->klass->image == acfg->image)) {
mini/aot-compiler.c:		MonoCompile *callee_cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, patch_info->data.method);
mini/aot-compiler.c:			if (direct_callable && !(!callee_cfg->has_got_slots && mono_class_is_before_field_init (callee_cfg->method->klass)))
mini/aot-compiler.c:			if ((callee_cfg->method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) && (!method || method->wrapper_type != MONO_WRAPPER_SYNCHRONIZED))
mini/aot-compiler.c:			if (acfg->aot_opts.soft_debug || acfg->aot_opts.no_direct_calls) {
mini/aot-compiler.c:			if (callee_cfg->method->wrapper_type == MONO_WRAPPER_ALLOC)
mini/aot-compiler.c:			if (callee_cfg->method->wrapper_type == MONO_WRAPPER_WRITE_BARRIER)
mini/aot-compiler.c:		if (acfg->aot_opts.direct_pinvoke)
mini/aot-compiler.c:		if (acfg->aot_opts.direct_icalls)
mini/aot-compiler.c:	import = (char *)g_hash_table_lookup (acfg->method_to_pinvoke_import, method);
mini/aot-compiler.c:	g_hash_table_insert (acfg->method_to_pinvoke_import, method, import);
mini/aot-compiler.c:	// FIXME: This seems to happen when two methods have the same cfg->method_to_register
mini/aot-compiler.c:	if (!acfg->dwarf_ln_filenames)
mini/aot-compiler.c:		acfg->dwarf_ln_filenames = g_hash_table_new (g_str_hash, g_str_equal);
mini/aot-compiler.c:	findex = GPOINTER_TO_INT (g_hash_table_lookup (acfg->dwarf_ln_filenames, source_file));
mini/aot-compiler.c:		findex = g_hash_table_size (acfg->dwarf_ln_filenames) + 1;
mini/aot-compiler.c:		g_hash_table_insert (acfg->dwarf_ln_filenames, g_strdup (source_file), GINT_TO_POINTER (findex));
mini/aot-compiler.c:		fprintf (acfg->fp, ".file %d \"%s\"\n", findex, mono_dwarf_escape_path (source_file));
mini/aot-compiler.c:	if (acfg->gas_line_numbers && method && debug_info) {
mini/aot-compiler.c:			fprintf (acfg->fp, ".loc %d %d 0\n", findex, 1);
mini/aot-compiler.c:			fprintf (acfg->fp, ".loc %d %d 0%s\n", findex, loc->row, options);
mini/aot-compiler.c:				if (!acfg->objc_selector_to_index)
mini/aot-compiler.c:					acfg->objc_selector_to_index = g_hash_table_new (g_str_hash, g_str_equal);
mini/aot-compiler.c:				if (!acfg->objc_selectors)
mini/aot-compiler.c:					acfg->objc_selectors = g_ptr_array_new ();
mini/aot-compiler.c:				index = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->objc_selector_to_index, selector));
mini/aot-compiler.c:					index = acfg->objc_selector_index;
mini/aot-compiler.c:					g_ptr_array_add (acfg->objc_selectors, (void*)patch_info->data.target);
mini/aot-compiler.c:					g_hash_table_insert (acfg->objc_selector_to_index, selector, GUINT_TO_POINTER (index + 1));
mini/aot-compiler.c:					acfg->objc_selector_index ++;
mini/aot-compiler.c:				if ((patch_info->type == MONO_PATCH_INFO_METHOD) && (patch_info->data.method->klass->image == acfg->image)) {
mini/aot-compiler.c:						MonoCompile *callee_cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, patch_info->data.method);
mini/aot-compiler.c:						//printf ("DIRECT: %s %s\n", method ? mono_method_full_name (method, TRUE) : "", mono_method_full_name (callee_cfg->method, TRUE));
mini/aot-compiler.c:						direct_call_target = callee_cfg->asm_symbol;
mini/aot-compiler.c:						acfg->stats.direct_calls ++;
mini/aot-compiler.c:					acfg->stats.all_calls ++;
mini/aot-compiler.c:							direct_call_target = g_strdup_printf ("%s%s", acfg->user_symbol_prefix, direct_pinvoke);
mini/aot-compiler.c:					if (!got_only && sym && acfg->aot_opts.direct_icalls) {
mini/aot-compiler.c:						direct_call_target = g_strdup_printf ("%s%s", acfg->user_symbol_prefix, sym);
mini/aot-compiler.c:					if (!got_only && sym && acfg->aot_opts.direct_icalls && info->func == info->wrapper) {
mini/aot-compiler.c:						direct_call_target = g_strdup_printf ("%s%s", acfg->user_symbol_prefix, sym);
mini/aot-compiler.c:					acfg->stats.direct_calls ++;
mini/aot-compiler.c:					arch_emit_got_access (acfg, acfg->got_symbol, code + i, got_slot, &code_size);
mini/aot-compiler.c:	res = mono_mempool_strdup (acfg->mempool, gs->str);
mini/aot-compiler.c:	method = cfg->orig_method;
mini/aot-compiler.c:	code = cfg->native_code;
mini/aot-compiler.c:	symbol = g_strdup_printf ("%sme_%x", acfg->temp_prefix, method_index);
mini/aot-compiler.c:	if (acfg->global_symbols && acfg->need_no_dead_strip)
mini/aot-compiler.c:		fprintf (acfg->fp, "	.no_dead_strip %s\n", cfg->asm_symbol);
mini/aot-compiler.c:	emit_label (acfg, cfg->asm_symbol);
mini/aot-compiler.c:	if (acfg->aot_opts.write_symbols && !acfg->global_symbols && !acfg->llvm) {
mini/aot-compiler.c:		debug_sym = get_debug_sym (method, "", acfg->method_label_hash);
mini/aot-compiler.c:		cfg->asm_debug_symbol = g_strdup (debug_sym);
mini/aot-compiler.c:		if (acfg->need_no_dead_strip)
mini/aot-compiler.c:			fprintf (acfg->fp, "	.no_dead_strip %s\n", debug_sym);
mini/aot-compiler.c:	export_name = (char *)g_hash_table_lookup (acfg->export_names, method);
mini/aot-compiler.c:	if (cfg->verbose_level > 0)
mini/aot-compiler.c:		g_print ("Method %s emitted as %s\n", mono_method_get_full_name (method), cfg->asm_symbol);
mini/aot-compiler.c:	acfg->stats.code_size += cfg->code_len;
mini/aot-compiler.c:	acfg->cfgs [method_index]->got_offset = acfg->got_offset;
mini/aot-compiler.c:	emit_and_reloc_code (acfg, method, code, cfg->code_len, cfg->patch_info, FALSE, mono_debug_find_method (cfg->jit_info->d.method, mono_domain_get ()));
mini/aot-compiler.c:	if (acfg->aot_opts.write_symbols) {
mini/aot-compiler.c:			emit_symbol_size (acfg, cfg->asm_symbol, ".");
mini/aot-compiler.c:		offset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_blob_hash, entry->method));
mini/aot-compiler.c:			g_hash_table_insert (acfg->method_blob_hash, entry->method, GUINT_TO_POINTER (offset + 1));
mini/aot-compiler.c:	method = cfg->orig_method;
mini/aot-compiler.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next)
mini/aot-compiler.c:	first_got_offset = acfg->cfgs [method_index]->got_offset;
mini/aot-compiler.c:	g_assert (!(cfg->opt & MONO_OPT_SHARED));
mini/aot-compiler.c:		if ((patch_info->type == MONO_PATCH_INFO_IMAGE) && (patch_info->data.image == acfg->image)) {
mini/aot-compiler.c:		if (is_plt_patch (patch_info) && !(cfg->compile_llvm && acfg->aot_opts.llvm_only)) {
mini/aot-compiler.c:		g_assert (cfg->has_got_slots);
mini/aot-compiler.c:	encode_patch_list (acfg, patches, n_patches, cfg->compile_llvm, first_got_offset, p, &p);
mini/aot-compiler.c:	acfg->stats.info_size += p - buf;
mini/aot-compiler.c:	cfg->method_info_offset = add_to_blob (acfg, buf, p - buf);
mini/aot-compiler.c:	offset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->unwind_info_offsets, GUINT_TO_POINTER (cache_index + 1)));
mini/aot-compiler.c:		offset = acfg->unwind_info_offset;
mini/aot-compiler.c:		g_hash_table_insert (acfg->unwind_info_offsets, GUINT_TO_POINTER (cache_index + 1), GUINT_TO_POINTER (offset + 1));
mini/aot-compiler.c:		g_ptr_array_add (acfg->unwind_ops, GUINT_TO_POINTER (cache_index));
mini/aot-compiler.c:		acfg->unwind_info_offset += encoded_len + (p - buf);
mini/aot-compiler.c:	MonoJitInfo *jinfo = cfg->jit_info;
mini/aot-compiler.c:	code = cfg->native_code;
mini/aot-compiler.c:	header = cfg->header;
mini/aot-compiler.c:	if (!acfg->aot_opts.nodebug) {
mini/aot-compiler.c:	seq_points = cfg->seq_point_info;
mini/aot-compiler.c:	buf_size = header->num_clauses * 256 + debug_info_size + 2048 + seq_points_size + cfg->gc_map_size;
mini/aot-compiler.c:	use_unwind_ops = cfg->unwind_ops != NULL;
mini/aot-compiler.c:	flags = (jinfo->has_generic_jit_info ? 1 : 0) | (use_unwind_ops ? 2 : 0) | (header->num_clauses ? 4 : 0) | (seq_points_size ? 8 : 0) | (cfg->compile_llvm ? 16 : 0) | (jinfo->has_try_block_holes ? 32 : 0) | (cfg->gc_map ? 64 : 0) | (jinfo->has_arch_eh_info ? 128 : 0);
mini/aot-compiler.c:		encoded = mono_unwind_ops_encode (cfg->unwind_ops, &encoded_len);
mini/aot-compiler.c:	if (cfg->compile_llvm) {
mini/aot-compiler.c:			if (!cfg->compile_llvm) {
mini/aot-compiler.c:	if (cfg->gc_map) {
mini/aot-compiler.c:		encode_value (cfg->gc_map_size, p, &p);
mini/aot-compiler.c:		memcpy (p, cfg->gc_map, cfg->gc_map_size);
mini/aot-compiler.c:		p += cfg->gc_map_size;
mini/aot-compiler.c:	acfg->stats.ex_info_size += p - buf;
mini/aot-compiler.c:	cfg->ex_info_offset = add_to_blob_aligned (acfg, buf, p - buf, cfg->gc_map ? 4 : 1);
mini/aot-compiler.c:	MonoClass *klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:		if (cm && mono_method_signature (cm)->is_inflated && !g_hash_table_lookup (acfg->token_info_hash, cm))
mini/aot-compiler.c:	acfg->stats.class_info_size += p - buf;
mini/aot-compiler.c:	if (acfg->llvm && llvm_acfg->aot_opts.static_link) {
mini/aot-compiler.c:		prefix = g_strdup_printf ("plt_%s_", acfg->assembly_name_sym);
mini/aot-compiler.c:		debug_sym = g_strdup_printf ("%s_rgctx_fetch_%d", prefix, acfg->label_generator ++);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		g_assert (acfg->plt_offset == 1);
mini/aot-compiler.c:	emit_label (acfg, acfg->plt_symbol);
mini/aot-compiler.c:	for (i = 0; i < acfg->plt_offset; ++i) {
mini/aot-compiler.c:		plt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));
mini/aot-compiler.c:		if (acfg->thumb_mixed && !plt_entry->jit_used)
mini/aot-compiler.c:		if (acfg->llvm && !acfg->thumb_mixed) {
mini/aot-compiler.c:			if (acfg->llvm) {
mini/aot-compiler.c:				fprintf (acfg->fp, ".private_extern %s\n", plt_entry->llvm_symbol);
mini/aot-compiler.c:			if (acfg->need_no_dead_strip) {
mini/aot-compiler.c:				fprintf (acfg->fp, "	.no_dead_strip %s\n", debug_sym);
mini/aot-compiler.c:		arch_emit_plt_entry (acfg, acfg->got_symbol, (acfg->plt_got_offset_base + i) * sizeof (gpointer), acfg->plt_got_info_offsets [i]);
mini/aot-compiler.c:	if (acfg->thumb_mixed) {
mini/aot-compiler.c:		for (i = 0; i < acfg->plt_offset; ++i) {
mini/aot-compiler.c:			plt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));
mini/aot-compiler.c:			if (acfg->aot_opts.write_symbols) {
mini/aot-compiler.c:				fprintf (acfg->fp, "	.thumb_func %s\n", debug_sym);
mini/aot-compiler.c:				fprintf (acfg->fp, "	.no_dead_strip %s\n", debug_sym);
mini/aot-compiler.c:			fprintf (acfg->fp, "\n.thumb_func\n");
mini/aot-compiler.c:			if (acfg->llvm)
mini/aot-compiler.c:			arch_emit_llvm_plt_entry (acfg, acfg->got_symbol, (acfg->plt_got_offset_base + i) * sizeof (gpointer), acfg->plt_got_info_offsets [i]);
mini/aot-compiler.c:	emit_symbol_size (acfg, acfg->plt_symbol, ".");
mini/aot-compiler.c:	sprintf (start_symbol, "%s%s", acfg->user_symbol_prefix, name);
mini/aot-compiler.c:	sprintf (symbol, "%snamed_%s", acfg->temp_prefix, name);
mini/aot-compiler.c:		sprintf (end_symbol, "%snamede_%s", acfg->temp_prefix, name);
mini/aot-compiler.c:	sprintf (symbol, "%s%s_p", acfg->user_symbol_prefix, name);
mini/aot-compiler.c:		sprintf (symbol2, "%snamed_%s", acfg->temp_prefix, name);
mini/aot-compiler.c:		if (acfg->dwarf)
mini/aot-compiler.c:			mono_dwarf_writer_emit_trampoline (acfg->dwarf, symbol, symbol2, NULL, NULL, code_size, unwind_ops);
mini/aot-compiler.c:	if (!mono_aot_mode_is_full (&acfg->aot_opts) || acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	g_assert (acfg->image->assembly);
mini/aot-compiler.c:	if (strcmp (acfg->image->assembly->aname.name, "mscorlib") == 0) {
mini/aot-compiler.c:			mono_arch_create_generic_trampoline ((MonoTrampolineType)tramp_type, &info, acfg->aot_opts.use_trampolines_page? 2: TRUE);
mini/aot-compiler.c:			emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:			emit_trampoline_full (acfg, acfg->got_offset, info, TRUE);
mini/aot-compiler.c:			emit_trampoline_full (acfg, acfg->got_offset, info, TRUE);
mini/aot-compiler.c:				emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		for (i = 0; i < acfg->aot_opts.nrgctx_fetch_trampolines; ++i) {
mini/aot-compiler.c:			emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:			emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:				emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		emit_trampoline (acfg, acfg->got_offset, info);
mini/aot-compiler.c:		tramp_got_offset = acfg->got_offset;
mini/aot-compiler.c:			if (acfg->aot_opts.write_symbols)
mini/aot-compiler.c:			acfg->trampoline_got_offset_base [ntype] = tramp_got_offset;
mini/aot-compiler.c:			for (i = 0; i < acfg->num_trampolines [ntype]; ++i) {
mini/aot-compiler.c:				if (!acfg->trampoline_size [ntype]) {
mini/aot-compiler.c:					acfg->trampoline_size [ntype] = tramp_size;
mini/aot-compiler.c:		acfg->num_trampoline_got_entries = tramp_got_offset - acfg->got_offset;
mini/aot-compiler.c:	acfg->got_offset += acfg->num_trampoline_got_entries;
mini/aot-compiler.c:	new_ji = (MonoJumpInfoToken *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfoToken));
mini/aot-compiler.c:	g_hash_table_insert (acfg->token_info_hash, method, new_ji);
mini/aot-compiler.c:				if (!g_hash_table_lookup (acfg->token_info_hash, method)) {
mini/aot-compiler.c:	if (gsharedvt_in && g_hash_table_lookup (acfg->gsharedvt_in_signatures, sig))
mini/aot-compiler.c:	if (gsharedvt_out && g_hash_table_lookup (acfg->gsharedvt_out_signatures, sig))
mini/aot-compiler.c:		g_hash_table_insert (acfg->gsharedvt_in_signatures, sig, sig);
mini/aot-compiler.c:		g_hash_table_insert (acfg->gsharedvt_out_signatures, sig, sig);
mini/aot-compiler.c:	if (acfg->aot_opts.metadata_only)
mini/aot-compiler.c:	if (acfg->aot_opts.profile_only && !method->is_inflated && !g_hash_table_lookup (acfg->profile_methods, method))
mini/aot-compiler.c:	InterlockedIncrement (&acfg->stats.mcount);
mini/aot-compiler.c:		InterlockedIncrement (&acfg->stats.genericcount);
mini/aot-compiler.c:	//acfg->aot_opts.print_skipped_methods = TRUE;
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts))
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	if (acfg->aot_opts.no_direct_calls)
mini/aot-compiler.c:	if (acfg->aot_opts.direct_pinvoke)
mini/aot-compiler.c:	cfg = mini_method_compile (method, acfg->opts, mono_get_root_domain (), flags, 0, index);
mini/aot-compiler.c:	if (cfg->exception_type == MONO_EXCEPTION_GENERIC_SHARING_FAILED) {
mini/aot-compiler.c:		if (acfg->aot_opts.print_skipped_methods)
mini/aot-compiler.c:			printf ("Skip (gshared failure): %s (%s)\n", mono_method_get_full_name (method), cfg->exception_message);
mini/aot-compiler.c:		InterlockedIncrement (&acfg->stats.genericcount);
mini/aot-compiler.c:	if (cfg->exception_type != MONO_EXCEPTION_NONE) {
mini/aot-compiler.c:		if (acfg->aot_opts.print_skipped_methods)
mini/aot-compiler.c:	if (cfg->disable_aot) {
mini/aot-compiler.c:		if (acfg->aot_opts.print_skipped_methods)
mini/aot-compiler.c:		InterlockedIncrement (&acfg->stats.ocount);
mini/aot-compiler.c:	cfg->method_index = index;
mini/aot-compiler.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:	g_hash_table_foreach (cfg->token_info_hash, add_token_info_hash, acfg);
mini/aot-compiler.c:	g_hash_table_destroy (cfg->token_info_hash);
mini/aot-compiler.c:	cfg->token_info_hash = NULL;
mini/aot-compiler.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:		if (acfg->aot_opts.print_skipped_methods)
mini/aot-compiler.c:		InterlockedIncrement (&acfg->stats.abscount);
mini/aot-compiler.c:	if (cfg->gsharedvt)
mini/aot-compiler.c:		acfg->stats.method_categories [METHOD_CAT_GSHAREDVT] ++;
mini/aot-compiler.c:	else if (cfg->gshared)
mini/aot-compiler.c:		acfg->stats.method_categories [METHOD_CAT_INST] ++;
mini/aot-compiler.c:	else if (cfg->method->wrapper_type)
mini/aot-compiler.c:		acfg->stats.method_categories [METHOD_CAT_WRAPPER] ++;
mini/aot-compiler.c:		acfg->stats.method_categories [METHOD_CAT_NORMAL] ++;
mini/aot-compiler.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:		if (acfg->aot_opts.print_skipped_methods)
mini/aot-compiler.c:		acfg->stats.ocount++;
mini/aot-compiler.c:	if (!cfg->compile_llvm)
mini/aot-compiler.c:		acfg->has_jitted_code = TRUE;
mini/aot-compiler.c:	if (method->is_inflated && acfg->aot_opts.log_instances) {
mini/aot-compiler.c:		if (acfg->instances_logfile)
mini/aot-compiler.c:			fprintf (acfg->instances_logfile, "%s ### %d\n", mono_method_get_full_name (method), cfg->code_size);
mini/aot-compiler.c:			printf ("%s ### %d\n", mono_method_get_full_name (method), cfg->code_size);
mini/aot-compiler.c:	depth = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_depth, method));
mini/aot-compiler.c:	if (!acfg->aot_opts.no_instances && depth < 32 && mono_aot_mode_is_full (&acfg->aot_opts)) {
mini/aot-compiler.c:		for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:				if (m->is_inflated && mono_aot_mode_is_full (&acfg->aot_opts)) {
mini/aot-compiler.c:							if (mono_aot_mode_is_full (&acfg->aot_opts) && !method_has_type_vars (m))
mini/aot-compiler.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:			if (patch_info->data.image != acfg->image)
mini/aot-compiler.c:				cfg->has_got_slots = TRUE;
mini/aot-compiler.c:			if (!is_plt_patch (patch_info) || (cfg->compile_llvm && acfg->aot_opts.llvm_only))
mini/aot-compiler.c:				cfg->has_got_slots = TRUE;
mini/aot-compiler.c:	if (!cfg->has_got_slots)
mini/aot-compiler.c:		InterlockedIncrement (&acfg->stats.methods_without_got_slots);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		if (!cfg->method->wrapper_type || cfg->method->wrapper_type == MONO_WRAPPER_DELEGATE_INVOKE)
mini/aot-compiler.c:			add_gsharedvt_wrappers (acfg, mono_method_signature (cfg->method), FALSE, TRUE);
mini/aot-compiler.c:		for (l = cfg->signatures; l; l = l->next) {
mini/aot-compiler.c:		for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/aot-compiler.c:			MonoJumpInfo *new_patch_info = mono_patch_info_dup_mp (acfg->mempool, patch_info);
mini/aot-compiler.c:		cfg->patch_info = patches;
mini/aot-compiler.c:		for (l = cfg->unwind_ops; l; l = l->next) {
mini/aot-compiler.c:			op = (MonoUnwindOp *)mono_mempool_alloc (acfg->mempool, sizeof (MonoUnwindOp));
mini/aot-compiler.c:			unwind_ops = g_slist_prepend_mempool (acfg->mempool, unwind_ops, op);
mini/aot-compiler.c:		cfg->unwind_ops = g_slist_reverse (unwind_ops);
mini/aot-compiler.c:		args = (MonoInst **)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst*) * (sig->param_count + sig->hasthis));
mini/aot-compiler.c:			args [i] = (MonoInst *)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst));
mini/aot-compiler.c:			memcpy (args [i], cfg->args [i], sizeof (MonoInst));
mini/aot-compiler.c:		cfg->args = args;
mini/aot-compiler.c:		locals = (MonoInst **)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst*) * header->num_locals);
mini/aot-compiler.c:			locals [i] = (MonoInst *)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst));
mini/aot-compiler.c:			memcpy (locals [i], cfg->locals [i], sizeof (MonoInst));
mini/aot-compiler.c:		cfg->locals = locals;
mini/aot-compiler.c:	while (index >= acfg->cfgs_size) {
mini/aot-compiler.c:		new_size = acfg->cfgs_size * 2;
mini/aot-compiler.c:		memcpy (new_cfgs, acfg->cfgs, sizeof (MonoCompile*) * acfg->cfgs_size);
mini/aot-compiler.c:		g_free (acfg->cfgs);
mini/aot-compiler.c:		acfg->cfgs = new_cfgs;
mini/aot-compiler.c:		acfg->cfgs_size = new_size;
mini/aot-compiler.c:	acfg->cfgs [index] = cfg;
mini/aot-compiler.c:	g_hash_table_insert (acfg->method_to_cfg, cfg->orig_method, cfg);
mini/aot-compiler.c:	if (cfg->orig_method->wrapper_type)
mini/aot-compiler.c:		g_ptr_array_add (acfg->extra_methods, cfg->orig_method);
mini/aot-compiler.c:	InterlockedIncrement (&acfg->stats.ccount);
mini/aot-compiler.c:	return offset < llvm_acfg->nshared_got_entries;
mini/aot-compiler.c:	if (llvm_acfg->aot_opts.static_link)
mini/aot-compiler.c:		return g_strdup_printf ("%s_%s", llvm_acfg->assembly_name_sym, get_debug_sym (cfg->orig_method, "", llvm_acfg->method_label_hash));
mini/aot-compiler.c:		return get_debug_sym (cfg->orig_method, "", llvm_acfg->method_label_hash);
mini/aot-compiler.c:	if (llvm_acfg->aot_opts.direct_icalls) {
mini/aot-compiler.c:			else if (llvm_acfg->aot_opts.direct_pinvoke)
mini/aot-compiler.c:	MonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc (llvm_acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	if (llvm_acfg->aot_opts.direct_icalls) {
mini/aot-compiler.c:	return g_strdup_printf (plt_entry->llvm_symbol + strlen (llvm_acfg->llvm_label_prefix));
mini/aot-compiler.c:	res = mono_patch_info_dup_mp (llvm_acfg->mempool, ji);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only && acfg->aot_opts.asm_only) {
mini/aot-compiler.c:		tempbc = g_strdup_printf ("%s.bc", acfg->tmpbasename);
mini/aot-compiler.c:		optbc = g_strdup (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:		tempbc = g_strdup_printf ("%s.bc", acfg->tmpbasename);
mini/aot-compiler.c:		optbc = g_strdup_printf ("%s.opt.bc", acfg->tmpbasename);
mini/aot-compiler.c:	mono_llvm_emit_aot_module (tempbc, g_path_get_basename (acfg->image->name));
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	command = g_strdup_printf ("\"%sopt\" -f %s -o \"%s\" \"%s\"", acfg->aot_opts.llvm_path, opts, optbc, tempbc);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only && acfg->aot_opts.asm_only)
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		command = g_strdup_printf ("clang++ -fexceptions -march=x86-64 -fpic -msse -msse2 -msse3 -msse4 -O2 -fno-optimize-sibling-calls -Wno-override-module -c -o \"%s\" \"%s.opt.bc\"", acfg->llvm_ofile, acfg->tmpbasename);
mini/aot-compiler.c:	if (!acfg->llc_args)
mini/aot-compiler.c:		acfg->llc_args = g_string_new ("");
mini/aot-compiler.c:	g_string_append (acfg->llc_args, " -asm-verbose=false");
mini/aot-compiler.c:	if (acfg->aot_opts.mtriple)
mini/aot-compiler.c:		g_string_append_printf (acfg->llc_args, " -mtriple=%s", acfg->aot_opts.mtriple);
mini/aot-compiler.c:	g_string_append (acfg->llc_args, " -disable-gnu-eh-frame -enable-mono-eh-frame");
mini/aot-compiler.c:	g_string_append_printf (acfg->llc_args, " -mono-eh-frame-symbol=%s%s", acfg->user_symbol_prefix, acfg->llvm_eh_frame_symbol);
mini/aot-compiler.c:	g_string_append_printf (acfg->llc_args, " -disable-tail-calls");
mini/aot-compiler.c:	g_string_append_printf (acfg->llc_args, " -relocation-model=pic");
mini/aot-compiler.c:	if (llvm_acfg->aot_opts.static_link)
mini/aot-compiler.c:		g_string_append_printf (acfg->llc_args, " -relocation-model=static");
mini/aot-compiler.c:		g_string_append_printf (acfg->llc_args, " -relocation-model=pic");
mini/aot-compiler.c:	if (acfg->llvm_owriter) {
mini/aot-compiler.c:		output_fname = g_strdup_printf ("%s", acfg->llvm_ofile);
mini/aot-compiler.c:		g_string_append_printf (acfg->llc_args, " -filetype=obj");
mini/aot-compiler.c:		output_fname = g_strdup_printf ("%s", acfg->llvm_sfile);
mini/aot-compiler.c:	command = g_strdup_printf ("\"%sllc\" %s -o \"%s\" \"%s.opt.bc\"", acfg->aot_opts.llvm_path, acfg->llc_args->str, output_fname, acfg->tmpbasename);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	emit_pointer (acfg, acfg->got_symbol);
mini/aot-compiler.c:	for (oindex = 0; oindex < acfg->method_order->len; ++oindex) {
mini/aot-compiler.c:		i = GPOINTER_TO_UINT (g_ptr_array_index (acfg->method_order, oindex));
mini/aot-compiler.c:		cfg = acfg->cfgs [i];
mini/aot-compiler.c:		method = cfg->orig_method;
mini/aot-compiler.c:		if (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {
mini/aot-compiler.c:			if (acfg->thumb_mixed && cfg->compile_llvm) {
mini/aot-compiler.c:				fprintf (acfg->fp, "\n.thumb_func\n");
mini/aot-compiler.c:			arch_emit_unbox_trampoline (acfg, cfg, cfg->orig_method, cfg->asm_symbol);
mini/aot-compiler.c:			if (acfg->thumb_mixed && cfg->compile_llvm)
mini/aot-compiler.c:				sprintf (user_symbol, "%sunbox_trampoline_p", acfg->user_symbol_prefix);
mini/aot-compiler.c:		if (cfg->compile_llvm)
mini/aot-compiler.c:			acfg->stats.llvm_count ++;
mini/aot-compiler.c:	if (acfg->llvm && acfg->need_no_dead_strip) {
mini/aot-compiler.c:		fprintf (acfg->fp, "\n");
mini/aot-compiler.c:		for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:			if (acfg->cfgs [i] && acfg->cfgs [i]->compile_llvm)
mini/aot-compiler.c:				fprintf (acfg->fp, ".no_dead_strip %s\n", acfg->cfgs [i]->asm_symbol);
mini/aot-compiler.c:	if (acfg->aot_opts.write_symbols)
mini/aot-compiler.c:	if (acfg->need_no_dead_strip)
mini/aot-compiler.c:		fprintf (acfg->fp, "	.no_dead_strip %s\n", symbol);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		if (acfg->cfgs [i]) {
mini/aot-compiler.c:			arch_emit_direct_call (acfg, acfg->cfgs [i]->asm_symbol, FALSE, acfg->thumb_mixed && acfg->cfgs [i]->compile_llvm, NULL, &call_size);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		cfg = acfg->cfgs [i];
mini/aot-compiler.c:		method = cfg->orig_method;
mini/aot-compiler.c:		if (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		cfg = acfg->cfgs [i];
mini/aot-compiler.c:		method = cfg->orig_method;
mini/aot-compiler.c:		if (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {
mini/aot-compiler.c:			arch_emit_direct_call (acfg, symbol, FALSE, acfg->thumb_mixed && cfg->compile_llvm, NULL, &call_size);
mini/aot-compiler.c:	offsets = g_new0 (gint32, acfg->nmethods);
mini/aot-compiler.c:	for (oindex = 0; oindex < acfg->method_order->len; ++oindex) {
mini/aot-compiler.c:		i = GPOINTER_TO_UINT (g_ptr_array_index (acfg->method_order, oindex));
mini/aot-compiler.c:		if (acfg->cfgs [i]) {
mini/aot-compiler.c:			emit_method_info (acfg, acfg->cfgs [i]);
mini/aot-compiler.c:			offsets [i] = acfg->cfgs [i]->method_info_offset;
mini/aot-compiler.c:	acfg->stats.offsets_size += emit_offset_table (acfg, "method_info_offsets", MONO_AOT_TABLE_METHOD_INFO_OFFSETS, acfg->nmethods, 10, offsets);
mini/aot-compiler.c:	info_offsets = g_new0 (guint32, acfg->extra_methods->len);
mini/aot-compiler.c:	for (i = 0; i < acfg->extra_methods->len; ++i) {
mini/aot-compiler.c:		MonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);
mini/aot-compiler.c:		MonoCompile *cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, method);
mini/aot-compiler.c:		method = cfg->method_to_register;
mini/aot-compiler.c:	for (i = 0; i < acfg->extra_methods->len; ++i) {
mini/aot-compiler.c:		MonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);
mini/aot-compiler.c:		MonoCompile *cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, method);
mini/aot-compiler.c:		new_entry = (HashEntry *)mono_mempool_alloc0 (acfg->mempool, sizeof (HashEntry));
mini/aot-compiler.c:	buf_size = acfg->extra_methods->len * 8 + 4;
mini/aot-compiler.c:	encode_int (acfg->extra_methods->len, p, &p);
mini/aot-compiler.c:	for (i = 0; i < acfg->extra_methods->len; ++i) {
mini/aot-compiler.c:		MonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);
mini/aot-compiler.c:	offsets = g_new0 (gint32, acfg->nmethods);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		if (acfg->cfgs [i]) {
mini/aot-compiler.c:			MonoCompile *cfg = acfg->cfgs [i];
mini/aot-compiler.c:			gboolean method_seq_points_to_file = acfg->aot_opts.gen_msym_dir &&
mini/aot-compiler.c:				cfg->gen_seq_points && !cfg->gen_sdb_seq_points;
mini/aot-compiler.c:			gboolean method_seq_points_to_binary = cfg->gen_seq_points && !method_seq_points_to_file;
mini/aot-compiler.c:			offsets [i] = cfg->ex_info_offset;
mini/aot-compiler.c:					mono_seq_point_data_init (&sp_data, acfg->nmethods);
mini/aot-compiler.c:				mono_seq_point_data_add (&sp_data, cfg->method->token, cfg->method_index, cfg->seq_point_info);
mini/aot-compiler.c:		char *aotid = mono_guid_to_string_minimal (acfg->image->aotid);
mini/aot-compiler.c:		char *dir = g_build_filename (acfg->aot_opts.gen_msym_dir_path, aotid, NULL);
mini/aot-compiler.c:		char *image_basename = g_path_get_basename (acfg->image->name);
mini/aot-compiler.c:	acfg->stats.offsets_size += emit_offset_table (acfg, "ex_info_offsets", MONO_AOT_TABLE_EX_INFO_OFFSETS, acfg->nmethods, 10, offsets);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		g_assert (acfg->unwind_ops->len == 0);
mini/aot-compiler.c:	for (i = 0; i < acfg->unwind_ops->len; ++i) {
mini/aot-compiler.c:		guint32 index = GPOINTER_TO_UINT (g_ptr_array_index (acfg->unwind_ops, i));
mini/aot-compiler.c:		acfg->stats.unwind_info_size += (p - buf) + unwind_info_len;
mini/aot-compiler.c:	offsets = g_new0 (gint32, acfg->image->tables [MONO_TABLE_TYPEDEF].rows);
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i)
mini/aot-compiler.c:	acfg->stats.offsets_size += emit_offset_table (acfg, "class_info_offsets", MONO_AOT_TABLE_CLASS_INFO_OFFSETS, acfg->image->tables [MONO_TABLE_TYPEDEF].rows, 10, offsets);
mini/aot-compiler.c:	table_size = g_spaced_primes_closest ((int)(acfg->image->tables [MONO_TABLE_TYPEDEF].rows * 1.5));
mini/aot-compiler.c:	for (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {
mini/aot-compiler.c:		klass = mono_class_get_checked (acfg->image, token, &error);
mini/aot-compiler.c:	buf_size = acfg->image_table->len * 28 + 4;
mini/aot-compiler.c:	for (i = 0; i < acfg->image_table->len; i++) {
mini/aot-compiler.c:		MonoImage *image = (MonoImage*)g_ptr_array_index (acfg->image_table, i);
mini/aot-compiler.c:	encode_int (acfg->image_table->len, p, &p);
mini/aot-compiler.c:	for (i = 0; i < acfg->image_table->len; i++) {
mini/aot-compiler.c:		MonoImage *image = (MonoImage*)g_ptr_array_index (acfg->image_table, i);
mini/aot-compiler.c:	GotInfo *info = llvm ? &acfg->llvm_got_info : &acfg->got_info;
mini/aot-compiler.c:		acfg->plt_got_offset_base = acfg->got_offset;
mini/aot-compiler.c:		for (i = 1; i < acfg->plt_offset; ++i) {
mini/aot-compiler.c:			MonoPltEntry *plt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));
mini/aot-compiler.c:			acfg->stats.got_slot_types [plt_entry->ji->type] ++;
mini/aot-compiler.c:		acfg->got_offset += acfg->plt_offset;
mini/aot-compiler.c:	p = buf = (guint8 *)mono_mempool_alloc (acfg->mempool, buf_size);
mini/aot-compiler.c:	got_info_offsets = (guint32 *)mono_mempool_alloc (acfg->mempool, info->got_patches->len * sizeof (guint32));
mini/aot-compiler.c:		acfg->plt_got_info_offsets = (guint32 *)mono_mempool_alloc (acfg->mempool, acfg->plt_offset * sizeof (guint32));
mini/aot-compiler.c:		if (acfg->plt_offset)
mini/aot-compiler.c:			acfg->plt_got_info_offsets [0] = 0;
mini/aot-compiler.c:		acfg->stats.got_slot_info_sizes [ji->type] += p - p2;
mini/aot-compiler.c:			acfg->plt_got_info_offsets [i - first_plt_got_patch + 1] = got_info_offsets [i];
mini/aot-compiler.c:		acfg->stats.got_info_size += p - buf;
mini/aot-compiler.c:	acfg->stats.offsets_size += emit_offset_table (acfg, llvm ? "llvm_got_info_offsets" : "got_info_offsets", llvm ? MONO_AOT_TABLE_LLVM_GOT_INFO_OFFSETS : MONO_AOT_TABLE_GOT_INFO_OFFSETS, llvm ? acfg->llvm_got_offset : first_plt_got_patch, 10, (gint32*)got_info_offsets);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	sprintf (symbol, "%s", acfg->got_symbol);
mini/aot-compiler.c:	fprintf (acfg->fp, ".section __DATA, __bss\n");
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:	fprintf (acfg->fp, ".lcomm %s, %d\n", acfg->got_symbol, (int)(acfg->got_offset * sizeof (gpointer)));
mini/aot-compiler.c:	if (acfg->aot_opts.write_symbols)
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:	if (acfg->got_offset > 0)
mini/aot-compiler.c:		emit_zero_bytes (acfg, (int)(acfg->got_offset * sizeof (gpointer)));
mini/aot-compiler.c:		for (guint i = 0; i < acfg->globals->len; ++i) {
mini/aot-compiler.c:			name = (char *)g_ptr_array_index (acfg->globals, i);
mini/aot-compiler.c:		fprintf (acfg->fp, "movl $1, %%eax\n");
mini/aot-compiler.c:		fprintf (acfg->fp, "ret\n");
mini/aot-compiler.c:	if (!acfg->aot_opts.static_link)
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		g_assert (acfg->globals->len == 0);
mini/aot-compiler.c:	table_size = g_spaced_primes_closest ((int)(acfg->globals->len * 1.5));
mini/aot-compiler.c:	for (i = 0; i < acfg->globals->len; ++i) {
mini/aot-compiler.c:		char *name = (char *)g_ptr_array_index (acfg->globals, i);
mini/aot-compiler.c:	for (i = 0; i < acfg->globals->len; ++i) {
mini/aot-compiler.c:		char *name = (char *)g_ptr_array_index (acfg->globals, i);
mini/aot-compiler.c:	sprintf (symbol, "%sglobals_hash", acfg->temp_prefix);
mini/aot-compiler.c:	for (i = 0; i < acfg->globals->len; ++i) {
mini/aot-compiler.c:		char *name = (char *)g_ptr_array_index (acfg->globals, i);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:	info->plt_got_offset_base = acfg->plt_got_offset_base;
mini/aot-compiler.c:	info->got_size = acfg->got_offset * sizeof (gpointer);
mini/aot-compiler.c:	info->plt_size = acfg->plt_offset;
mini/aot-compiler.c:	info->nmethods = acfg->nmethods;
mini/aot-compiler.c:	info->flags = acfg->flags;
mini/aot-compiler.c:	info->opts = acfg->opts;
mini/aot-compiler.c:	info->simd_opts = acfg->simd_opts;
mini/aot-compiler.c:	info->gc_name_index = acfg->gc_name_offset;
mini/aot-compiler.c:	info->datafile_size = acfg->datafile_offset;
mini/aot-compiler.c:		info->table_offsets [i] = acfg->table_offsets [i];
mini/aot-compiler.c:		info->num_trampolines [i] = acfg->num_trampolines [i];
mini/aot-compiler.c:		info->trampoline_got_offset_base [i] = acfg->trampoline_got_offset_base [i];
mini/aot-compiler.c:		info->trampoline_size [i] = acfg->trampoline_size [i];
mini/aot-compiler.c:	info->num_rgctx_fetch_trampolines = acfg->aot_opts.nrgctx_fetch_trampolines;
mini/aot-compiler.c:	info->tramp_page_size = acfg->tramp_page_size;
mini/aot-compiler.c:	info->nshared_got_entries = acfg->nshared_got_entries;
mini/aot-compiler.c:		info->tramp_page_code_offsets [i] = acfg->tramp_page_code_offsets [i];
mini/aot-compiler.c:	memcpy(&info->aotid, acfg->image->aotid, 16);
mini/aot-compiler.c:	symbols [sindex ++] = acfg->got_symbol;
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		symbols [sindex ++] = g_strdup_printf ("%s%s", acfg->user_symbol_prefix, acfg->llvm_got_symbol);
mini/aot-compiler.c:		symbols [sindex ++] = acfg->llvm_eh_frame_symbol;
mini/aot-compiler.c:	if (!acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	if (acfg->data_outfile) {
mini/aot-compiler.c:		if (acfg->llvm)
mini/aot-compiler.c:	if (acfg->num_trampoline_got_entries) {
mini/aot-compiler.c:	if (acfg->aot_opts.static_link) {
mini/aot-compiler.c:	if (!acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	sprintf (symbol, "%smono_aot_file_info", acfg->user_symbol_prefix);
mini/aot-compiler.c:	if (!acfg->aot_opts.static_link)
mini/aot-compiler.c:	if (acfg->aot_opts.static_link) {
mini/aot-compiler.c:		emit_global_inner (acfg, acfg->static_linking_symbol, FALSE);
mini/aot-compiler.c:		emit_label (acfg, acfg->static_linking_symbol);
mini/aot-compiler.c:		emit_pointer_2 (acfg, acfg->user_symbol_prefix, "mono_aot_file_info");
mini/aot-compiler.c:	if (acfg->aot_opts.bind_to_runtime_version) {
mini/aot-compiler.c:	emit_string_symbol (acfg, "assembly_guid" , acfg->image->guid);
mini/aot-compiler.c:	emit_string_symbol (acfg, "assembly_name", acfg->image->assembly->aname.name);
mini/aot-compiler.c:	if (acfg->aot_opts.static_link) {
mini/aot-compiler.c:		sprintf (symbol, "%smono_aot_module_%s_info", acfg->user_symbol_prefix, acfg->image->assembly->aname.name);
mini/aot-compiler.c:		acfg->static_linking_symbol = g_strdup (symbol);
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:		mono_llvm_emit_aot_file_info (info, acfg->has_jitted_code);
mini/aot-compiler.c:	acfg->blob_closed = TRUE;
mini/aot-compiler.c:	emit_aot_data (acfg, MONO_AOT_TABLE_BLOB, "blob", (guint8*)acfg->blob.data, acfg->blob.index);
mini/aot-compiler.c:	if (!acfg->objc_selectors || acfg->objc_selectors->len == 0)
mini/aot-compiler.c:	mono_img_writer_emit_unset_mode (acfg->w);
mini/aot-compiler.c:	g_assert (acfg->fp);
mini/aot-compiler.c:	fprintf (acfg->fp, ".section	__DATA,__objc_selrefs,literal_pointers,no_dead_strip\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".align	3\n");
mini/aot-compiler.c:	for (i = 0; i < acfg->objc_selectors->len; ++i) {
mini/aot-compiler.c:	fprintf (acfg->fp, ".section	__TEXT,__cstring,cstring_literals\n");
mini/aot-compiler.c:	for (i = 0; i < acfg->objc_selectors->len; ++i) {
mini/aot-compiler.c:		fprintf (acfg->fp, "L_OBJC_METH_VAR_NAME_%d:\n", i);
mini/aot-compiler.c:		fprintf (acfg->fp, ".asciz \"%s\"\n", (char*)g_ptr_array_index (acfg->objc_selectors, i));
mini/aot-compiler.c:	fprintf (acfg->fp, ".section	__DATA,__objc_imageinfo,regular,no_dead_strip\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".align	3\n");
mini/aot-compiler.c:	fprintf (acfg->fp, "L_OBJC_IMAGE_INFO:\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".long	0\n");
mini/aot-compiler.c:	fprintf (acfg->fp, ".long	16\n");
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		MonoCompile *cfg = acfg->cfgs [i];
mini/aot-compiler.c:		if (cfg->compile_llvm)
mini/aot-compiler.c:		sprintf (symbol2, "%sme_%x", acfg->temp_prefix, i);
mini/aot-compiler.c:		mono_dwarf_writer_emit_method (acfg->dwarf, cfg, cfg->method, cfg->asm_symbol, symbol2, cfg->asm_debug_symbol, (guint8 *)cfg->jit_info->code_start, cfg->jit_info->code_size, cfg->args, cfg->locals, cfg->unwind_ops, mono_debug_find_method (cfg->jit_info->d.method, mono_domain_get ()));
mini/aot-compiler.c:	MonoImage *image = acfg->image;
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:		if (mono_aot_mode_is_full (&acfg->aot_opts) && method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {
mini/aot-compiler.c:		if (acfg->aot_opts.soft_debug && !method->wrapper_type) {
mini/aot-compiler.c:		acfg->method_index ++;
mini/aot-compiler.c:		if (!(acfg->opts & MONO_OPT_GSHAREDVT))
mini/aot-compiler.c:		method = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts))
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts))
mini/aot-compiler.c:	if (acfg->aot_opts.nthreads > 0) {
mini/aot-compiler.c:		methods_len = acfg->methods->len;
mini/aot-compiler.c:		len = acfg->methods->len / acfg->aot_opts.nthreads;
mini/aot-compiler.c:		/* Make a copy since acfg->methods is modified by compile_method () */
mini/aot-compiler.c:		//memcpy (methods, g_ptr_array_index (acfg->methods, 0), sizeof (MonoMethod*) * methods_len);
mini/aot-compiler.c:			methods [i] = (MonoMethod *)g_ptr_array_index (acfg->methods, i);
mini/aot-compiler.c:	for (i = methods_len; i < acfg->methods->len; ++i) {
mini/aot-compiler.c:		/* This can add new methods to acfg->methods */
mini/aot-compiler.c:		compile_method (acfg, (MonoMethod *)g_ptr_array_index (acfg->methods, i));
mini/aot-compiler.c:	const char *tool_prefix = acfg->aot_opts.tool_prefix ? acfg->aot_opts.tool_prefix : "";
mini/aot-compiler.c:	char *ld_flags = acfg->aot_opts.ld_flags ? acfg->aot_opts.ld_flags : g_strdup("");
mini/aot-compiler.c:	if (acfg->aot_opts.asm_only) {
mini/aot-compiler.c:		aot_printf (acfg, "Output file: '%s'.\n", acfg->tmpfname);
mini/aot-compiler.c:		if (acfg->aot_opts.static_link)
mini/aot-compiler.c:			aot_printf (acfg, "Linking symbol: '%s'.\n", acfg->static_linking_symbol);
mini/aot-compiler.c:		if (acfg->llvm)
mini/aot-compiler.c:			aot_printf (acfg, "LLVM output file: '%s'.\n", acfg->llvm_sfile);
mini/aot-compiler.c:	if (acfg->aot_opts.static_link) {
mini/aot-compiler.c:		if (acfg->aot_opts.outfile)
mini/aot-compiler.c:			objfile = g_strdup_printf ("%s", acfg->aot_opts.outfile);
mini/aot-compiler.c:			objfile = g_strdup_printf ("%s." AS_OBJECT_FILE_SUFFIX, acfg->image->name);
mini/aot-compiler.c:		objfile = g_strdup_printf ("%s." AS_OBJECT_FILE_SUFFIX, acfg->tmpfname);
mini/aot-compiler.c:	g_string_append (acfg->as_args, "-c -x assembler");
mini/aot-compiler.c:			acfg->as_args ? acfg->as_args->str : "", 
mini/aot-compiler.c:			wrap_path (objfile), wrap_path (acfg->tmpfname));
mini/aot-compiler.c:	if (acfg->llvm && !acfg->llvm_owriter) {
mini/aot-compiler.c:			acfg->as_args ? acfg->as_args->str : "",
mini/aot-compiler.c:			wrap_path (acfg->llvm_ofile), wrap_path (acfg->llvm_sfile));
mini/aot-compiler.c:	if (acfg->aot_opts.static_link) {
mini/aot-compiler.c:		aot_printf (acfg, "Linking symbol: '%s'.\n", acfg->static_linking_symbol);
mini/aot-compiler.c:	if (acfg->aot_opts.outfile)
mini/aot-compiler.c:		outfile_name = g_strdup_printf ("%s", acfg->aot_opts.outfile);
mini/aot-compiler.c:		outfile_name = g_strdup_printf ("%s%s", acfg->image->name, MONO_SOLIB_EXT);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		llvm_ofile = g_strdup_printf ("\"%s\"", acfg->llvm_ofile);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:		wrap_path (g_strdup_printf ("%s." AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);
mini/aot-compiler.c:	if (acfg->aot_opts.tool_prefix) {
mini/aot-compiler.c:								   wrap_path (g_strdup_printf ("%s." AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);
mini/aot-compiler.c:									  wrap_path (g_strdup_printf ("%s." AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);
mini/aot-compiler.c:		if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	/*com = g_strdup_printf ("strip --strip-unneeded %s%s", acfg->image->name, MONO_SOLIB_EXT);
mini/aot-compiler.c:	if (!acfg->aot_opts.save_temps)
mini/aot-compiler.c:	if (acfg->aot_opts.save_temps)
mini/aot-compiler.c:		unlink (acfg->tmpfname);
mini/aot-compiler.c:	acfg->profile_data = g_list_append (acfg->profile_data, data);
mini/aot-compiler.c:			if (acfg->aot_opts.verbose)
mini/aot-compiler.c:			if (acfg->aot_opts.verbose)
mini/aot-compiler.c:			if (acfg->aot_opts.verbose)
mini/aot-compiler.c:	if (acfg->aot_opts.profile_only) {
mini/aot-compiler.c:			g_hash_table_insert (acfg->profile_methods, m, m);
mini/aot-compiler.c:		if (((ctx->class_inst && inst_references_image (ctx->class_inst, acfg->image)) ||
mini/aot-compiler.c:			 (ctx->method_inst && inst_references_image (ctx->method_inst, acfg->image))) &&
mini/aot-compiler.c:		} else if (m->klass->image == acfg->image &&
mini/aot-compiler.c:			((ctx->class_inst && is_local_inst (ctx->class_inst, acfg->image)) ||
mini/aot-compiler.c:			 (ctx->method_inst && is_local_inst (ctx->method_inst, acfg->image))) &&
mini/aot-compiler.c:	acfg->methods = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->method_indexes = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->method_depth = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->plt_offset_to_entry = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->patch_to_plt_entry = g_new0 (GHashTable*, MONO_PATCH_INFO_NUM);
mini/aot-compiler.c:	acfg->method_to_cfg = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->token_info_hash = g_hash_table_new_full (NULL, NULL, NULL, NULL);
mini/aot-compiler.c:	acfg->method_to_pinvoke_import = g_hash_table_new_full (NULL, NULL, NULL, g_free);
mini/aot-compiler.c:	acfg->image_hash = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->image_table = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->globals = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->image = image;
mini/aot-compiler.c:	acfg->opts = opts;
mini/aot-compiler.c:	acfg->simd_opts = mono_arch_cpu_enumerate_simd_versions ();
mini/aot-compiler.c:	acfg->mempool = mono_mempool_new ();
mini/aot-compiler.c:	acfg->extra_methods = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->unwind_info_offsets = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->unwind_ops = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->method_label_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
mini/aot-compiler.c:	acfg->method_order = g_ptr_array_new ();
mini/aot-compiler.c:	acfg->export_names = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->klass_blob_hash = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->method_blob_hash = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	acfg->plt_entry_debug_sym_cache = g_hash_table_new (g_str_hash, g_str_equal);
mini/aot-compiler.c:	acfg->gsharedvt_in_signatures = g_hash_table_new ((GHashFunc)mono_signature_hash, (GEqualFunc)mono_metadata_signature_equal);
mini/aot-compiler.c:	acfg->gsharedvt_out_signatures = g_hash_table_new ((GHashFunc)mono_signature_hash, (GEqualFunc)mono_metadata_signature_equal);
mini/aot-compiler.c:	acfg->profile_methods = g_hash_table_new (NULL, NULL);
mini/aot-compiler.c:	mono_os_mutex_init_recursive (&acfg->mutex);
mini/aot-compiler.c:	init_got_info (&acfg->got_info);
mini/aot-compiler.c:	init_got_info (&acfg->llvm_got_info);
mini/aot-compiler.c:	mono_img_writer_destroy (acfg->w);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i)
mini/aot-compiler.c:		if (acfg->cfgs [i])
mini/aot-compiler.c:			mono_destroy_compile (acfg->cfgs [i]);
mini/aot-compiler.c:	g_free (acfg->cfgs);
mini/aot-compiler.c:	g_free (acfg->static_linking_symbol);
mini/aot-compiler.c:	g_free (acfg->got_symbol);
mini/aot-compiler.c:	g_free (acfg->plt_symbol);
mini/aot-compiler.c:	g_ptr_array_free (acfg->methods, TRUE);
mini/aot-compiler.c:	g_ptr_array_free (acfg->image_table, TRUE);
mini/aot-compiler.c:	g_ptr_array_free (acfg->globals, TRUE);
mini/aot-compiler.c:	g_ptr_array_free (acfg->unwind_ops, TRUE);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_indexes);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_depth);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->plt_offset_to_entry);
mini/aot-compiler.c:		if (acfg->patch_to_plt_entry [i])
mini/aot-compiler.c:			g_hash_table_destroy (acfg->patch_to_plt_entry [i]);
mini/aot-compiler.c:	g_free (acfg->patch_to_plt_entry);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_to_cfg);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->token_info_hash);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_to_pinvoke_import);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->image_hash);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->unwind_info_offsets);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_label_hash);
mini/aot-compiler.c:	if (acfg->typespec_classes)
mini/aot-compiler.c:		g_hash_table_destroy (acfg->typespec_classes);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->export_names);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->plt_entry_debug_sym_cache);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->klass_blob_hash);
mini/aot-compiler.c:	g_hash_table_destroy (acfg->method_blob_hash);
mini/aot-compiler.c:	got_info_free (&acfg->got_info);
mini/aot-compiler.c:	got_info_free (&acfg->llvm_got_info);
mini/aot-compiler.c:	mono_mempool_destroy (acfg->mempool);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		cfg = acfg->cfgs [i];
mini/aot-compiler.c:		method = cfg->orig_method;
mini/aot-compiler.c:		mono_json_writer_printf (&writer, "\"%d\",\n", cfg->code_size);
mini/aot-compiler.c:	for (i = 0; i < acfg->plt_offset; ++i) {
mini/aot-compiler.c:		plt_entry = g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));
mini/aot-compiler.c:	for (i = 0; i < acfg->got_info.got_patches->len; ++i) {
mini/aot-compiler.c:		MonoJumpInfo *ji = g_ptr_array_index (acfg->got_info.got_patches, i);
mini/aot-compiler.c:	dumpname = g_strdup_printf ("%s.json", g_path_get_basename (acfg->image->name));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji->data.image = acfg->image;
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:		ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:		ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:	ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));
mini/aot-compiler.c:		ji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoAotCompile));
mini/aot-compiler.c:	acfg->nshared_got_entries = acfg->got_offset;
mini/aot-compiler.c:	memset (&acfg->aot_opts, 0, sizeof (acfg->aot_opts));
mini/aot-compiler.c:	acfg->aot_opts.write_symbols = TRUE;
mini/aot-compiler.c:	acfg->aot_opts.ntrampolines = 4096;
mini/aot-compiler.c:	acfg->aot_opts.nrgctx_trampolines = 4096;
mini/aot-compiler.c:	acfg->aot_opts.nimt_trampolines = 512;
mini/aot-compiler.c:	acfg->aot_opts.nrgctx_fetch_trampolines = 128;
mini/aot-compiler.c:	acfg->aot_opts.ngsharedvt_arg_trampolines = 512;
mini/aot-compiler.c:	acfg->aot_opts.llvm_path = g_strdup ("");
mini/aot-compiler.c:	acfg->aot_opts.temp_path = g_strdup ("");
mini/aot-compiler.c:	acfg->aot_opts.use_trampolines_page = TRUE;
mini/aot-compiler.c:	mono_aot_parse_options (aot_options, &acfg->aot_opts);
mini/aot-compiler.c:	if (acfg->aot_opts.logfile) {
mini/aot-compiler.c:		acfg->logfile = fopen (acfg->aot_opts.logfile, "a+");
mini/aot-compiler.c:	if (acfg->aot_opts.data_outfile) {
mini/aot-compiler.c:		acfg->data_outfile = fopen (acfg->aot_opts.data_outfile, "w+");
mini/aot-compiler.c:		if (!acfg->data_outfile) {
mini/aot-compiler.c:			aot_printerrf (acfg, "Unable to create file '%s': %s\n", acfg->aot_opts.data_outfile, strerror (errno));
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_SEPARATE_DATA);
mini/aot-compiler.c:	//acfg->aot_opts.print_skipped_methods = TRUE;
mini/aot-compiler.c:	if (acfg->opts & MONO_OPT_GSHAREDVT) {
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only || mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))
mini/aot-compiler.c:		acfg->opts |= MONO_OPT_GSHAREDVT;
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:	if (acfg->opts & MONO_OPT_GSHAREDVT)
mini/aot-compiler.c:	generate_aotid ((guint8*) &acfg->image->aotid);
mini/aot-compiler.c:	char *aotid = mono_guid_to_string (acfg->image->aotid);
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts)) {
mini/aot-compiler.c:	if (acfg->aot_opts.direct_pinvoke && !acfg->aot_opts.static_link) {
mini/aot-compiler.c:	if (acfg->aot_opts.static_link)
mini/aot-compiler.c:		acfg->aot_opts.asm_writer = TRUE;
mini/aot-compiler.c:	if (acfg->aot_opts.soft_debug) {
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_DEBUG);
mini/aot-compiler.c:	if (mono_use_llvm || acfg->aot_opts.llvm) {
mini/aot-compiler.c:		acfg->llvm = TRUE;
mini/aot-compiler.c:		acfg->aot_opts.asm_writer = TRUE;
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_WITH_LLVM);
mini/aot-compiler.c:		if (acfg->aot_opts.soft_debug) {
mini/aot-compiler.c:		if (acfg->aot_opts.asm_only && !acfg->aot_opts.llvm_outfile) {
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts))
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_FULL_AOT);
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_SAFEPOINTS);
mini/aot-compiler.c:	if (acfg->aot_opts.instances_logfile_path) {
mini/aot-compiler.c:		acfg->instances_logfile = fopen (acfg->aot_opts.instances_logfile_path, "w");
mini/aot-compiler.c:		if (!acfg->instances_logfile) {
mini/aot-compiler.c:			aot_printerrf (acfg, "Unable to create logfile: '%s'.\n", acfg->aot_opts.instances_logfile_path);
mini/aot-compiler.c:	if (acfg->aot_opts.profile_files) {
mini/aot-compiler.c:		for (l = acfg->aot_opts.profile_files; l; l = l->next) {
mini/aot-compiler.c:       for (method_index = 0; method_index < acfg->image->tables [MONO_TABLE_METHOD].rows; ++method_index) {
mini/aot-compiler.c:		   g_ptr_array_add (acfg->method_order,GUINT_TO_POINTER (method_index));
mini/aot-compiler.c:	acfg->num_trampolines [MONO_AOT_TRAMP_SPECIFIC] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.ntrampolines : 0;
mini/aot-compiler.c:	acfg->num_trampolines [MONO_AOT_TRAMP_STATIC_RGCTX] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.nrgctx_trampolines : 0;
mini/aot-compiler.c:	acfg->num_trampolines [MONO_AOT_TRAMP_IMT] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.nimt_trampolines : 0;
mini/aot-compiler.c:	if (acfg->opts & MONO_OPT_GSHAREDVT)
mini/aot-compiler.c:		acfg->num_trampolines [MONO_AOT_TRAMP_GSHAREDVT_ARG] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.ngsharedvt_arg_trampolines : 0;
mini/aot-compiler.c:	acfg->temp_prefix = mono_img_writer_get_temp_label_prefix (NULL);
mini/aot-compiler.c:	if (mono_use_llvm || acfg->aot_opts.llvm) {
mini/aot-compiler.c:		if (!acfg->aot_opts.asm_only && acfg->llvm_owriter_supported) {
mini/aot-compiler.c:			acfg->llvm_owriter = TRUE;
mini/aot-compiler.c:		} else if (acfg->aot_opts.llvm_outfile) {
mini/aot-compiler.c:			int len = strlen (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:			if (len >= 2 && acfg->aot_opts.llvm_outfile [len - 2] == '.' && acfg->aot_opts.llvm_outfile [len - 1] == 'o')
mini/aot-compiler.c:				acfg->llvm_owriter = TRUE;
mini/aot-compiler.c:	if (acfg->llvm && acfg->thumb_mixed)
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_LLVM_THUMB);
mini/aot-compiler.c:	if (acfg->aot_opts.llvm_only)
mini/aot-compiler.c:		acfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_LLVM_ONLY);
mini/aot-compiler.c:	acfg->assembly_name_sym = g_strdup (acfg->image->assembly->aname.name);
mini/aot-compiler.c:	for (p = acfg->assembly_name_sym; *p; ++p) {
mini/aot-compiler.c:	acfg->global_prefix = g_strdup_printf ("mono_aot_%s", acfg->assembly_name_sym);
mini/aot-compiler.c:	acfg->plt_symbol = g_strdup_printf ("%s_plt", acfg->global_prefix);
mini/aot-compiler.c:	acfg->got_symbol = g_strdup_printf ("%s_got", acfg->global_prefix);
mini/aot-compiler.c: 	if (acfg->llvm) {
mini/aot-compiler.c:		acfg->llvm_got_symbol = g_strdup_printf ("%s_llvm_got", acfg->global_prefix);
mini/aot-compiler.c:		acfg->llvm_eh_frame_symbol = g_strdup_printf ("%s_eh_frame", acfg->global_prefix);
mini/aot-compiler.c:	acfg->method_index = 1;
mini/aot-compiler.c:	if (mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))
mini/aot-compiler.c:		for (l = acfg->profile_data; l; l = l->next)
mini/aot-compiler.c:		for (l = acfg->profile_data; l; l = l->next)
mini/aot-compiler.c:	acfg->cfgs_size = acfg->methods->len + 32;
mini/aot-compiler.c:	acfg->cfgs = g_new0 (MonoCompile*, acfg->cfgs_size);
mini/aot-compiler.c:	acfg->plt_offset = 1;
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		mono_llvm_create_aot_module (acfg->image->assembly, acfg->global_prefix, TRUE, acfg->aot_opts.static_link, acfg->aot_opts.llvm_only);
mini/aot-compiler.c:	acfg->stats.jit_time = TV_ELAPSED (atv, btv);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:		if (acfg->aot_opts.asm_only) {
mini/aot-compiler.c:			if (acfg->aot_opts.outfile) {
mini/aot-compiler.c:				acfg->tmpfname = g_strdup_printf ("%s", acfg->aot_opts.outfile);
mini/aot-compiler.c:				acfg->tmpbasename = g_strdup (acfg->tmpfname);
mini/aot-compiler.c:				acfg->tmpbasename = g_strdup_printf ("%s", acfg->image->name);
mini/aot-compiler.c:				acfg->tmpfname = g_strdup_printf ("%s.s", acfg->tmpbasename);
mini/aot-compiler.c:			g_assert (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:			acfg->llvm_sfile = g_strdup (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:			if (acfg->llvm_owriter)
mini/aot-compiler.c:				acfg->llvm_ofile = g_strdup (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:				acfg->llvm_sfile = g_strdup (acfg->aot_opts.llvm_outfile);
mini/aot-compiler.c:			acfg->tmpbasename = (strcmp (acfg->aot_opts.temp_path, "") == 0) ?
mini/aot-compiler.c:				g_build_filename (acfg->aot_opts.temp_path, "temp", NULL);
mini/aot-compiler.c:			acfg->tmpfname = g_strdup_printf ("%s.s", acfg->tmpbasename);
mini/aot-compiler.c:			acfg->llvm_sfile = g_strdup_printf ("%s-llvm.s", acfg->tmpbasename);
mini/aot-compiler.c:			acfg->llvm_ofile = g_strdup_printf ("%s-llvm.o", acfg->tmpbasename);
mini/aot-compiler.c:	if (acfg->aot_opts.asm_only && !acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		if (acfg->aot_opts.outfile)
mini/aot-compiler.c:			acfg->tmpfname = g_strdup_printf ("%s", acfg->aot_opts.outfile);
mini/aot-compiler.c:			acfg->tmpfname = g_strdup_printf ("%s.s", acfg->image->name);
mini/aot-compiler.c:		acfg->fp = fopen (acfg->tmpfname, "w+");
mini/aot-compiler.c:		int i = g_file_open_tmp ("mono_aot_XXXXXX", &acfg->tmpfname, NULL);
mini/aot-compiler.c:		acfg->fp = fdopen (i, "w+");
mini/aot-compiler.c:	if (acfg->fp == 0 && !acfg->aot_opts.llvm_only) {
mini/aot-compiler.c:		aot_printerrf (acfg, "Unable to open file '%s': %s\n", acfg->tmpfname, strerror (errno));
mini/aot-compiler.c:	if (acfg->fp)
mini/aot-compiler.c:		acfg->w = mono_img_writer_create (acfg->fp, FALSE);
mini/aot-compiler.c:	for (i = 0; i < acfg->nmethods; ++i) {
mini/aot-compiler.c:		if (acfg->cfgs [i]) {
mini/aot-compiler.c:			MonoCompile *cfg = acfg->cfgs [i];
mini/aot-compiler.c:			int method_index = get_method_index (acfg, cfg->orig_method);
mini/aot-compiler.c:				cfg->asm_symbol = g_strdup_printf ("%s%s", acfg->llvm_label_prefix, cfg->llvm_method_name);
mini/aot-compiler.c:			else if (acfg->global_symbols || acfg->llvm)
mini/aot-compiler.c:				cfg->asm_symbol = get_debug_sym (cfg->orig_method, "", acfg->method_label_hash);
mini/aot-compiler.c:				cfg->asm_symbol = g_strdup_printf ("%s%sm_%x", acfg->temp_prefix, acfg->llvm_label_prefix, method_index);
mini/aot-compiler.c:			cfg->asm_debug_symbol = cfg->asm_symbol;
mini/aot-compiler.c:	if (acfg->aot_opts.dwarf_debug && acfg->aot_opts.gnu_asm) {
mini/aot-compiler.c:		acfg->gas_line_numbers = TRUE;
mini/aot-compiler.c:	if ((!acfg->aot_opts.nodebug || acfg->aot_opts.dwarf_debug) && acfg->has_jitted_code) {
mini/aot-compiler.c:		if (acfg->aot_opts.dwarf_debug && !mono_debug_enabled ()) {
mini/aot-compiler.c:		acfg->dwarf = mono_dwarf_writer_create (acfg->w, NULL, 0, !acfg->gas_line_numbers);
mini/aot-compiler.c:	if (acfg->w)
mini/aot-compiler.c:		mono_img_writer_emit_start (acfg->w);
mini/aot-compiler.c:	if (acfg->dwarf)
mini/aot-compiler.c:		mono_dwarf_writer_emit_base_info (acfg->dwarf, g_path_get_basename (acfg->image->name), mono_unwind_get_cie_program ());
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:		acfg->gc_name_offset = add_to_blob (acfg, (guint8*)gc_name, strlen (gc_name) + 1);
mini/aot-compiler.c:	if (acfg->dwarf) {
mini/aot-compiler.c:		mono_dwarf_writer_close (acfg->dwarf);
mini/aot-compiler.c:	if (acfg->need_pt_gnu_stack) {
mini/aot-compiler.c:		fprintf (acfg->fp, "\n.section	.note.GNU-stack,\"\",@progbits\n");
mini/aot-compiler.c:	if (acfg->aot_opts.data_outfile)
mini/aot-compiler.c:		fclose (acfg->data_outfile);
mini/aot-compiler.c:	if (acfg->llvm) {
mini/aot-compiler.c:	acfg->stats.gen_time = TV_ELAPSED (atv, btv);
mini/aot-compiler.c:	if (acfg->llvm)
mini/aot-compiler.c:		sprintf (llvm_stats_msg, ", LLVM: %d (%d%%)", acfg->stats.llvm_count, acfg->stats.mcount ? (acfg->stats.llvm_count * 100) / acfg->stats.mcount : 100);
mini/aot-compiler.c:	all_sizes = acfg->stats.code_size + acfg->stats.info_size + acfg->stats.ex_info_size + acfg->stats.unwind_info_size + acfg->stats.class_info_size + acfg->stats.got_info_size + acfg->stats.offsets_size + acfg->stats.plt_size;
mini/aot-compiler.c:				(int)acfg->stats.code_size, (int)(acfg->stats.code_size * 100 / all_sizes),
mini/aot-compiler.c:				(int)acfg->stats.info_size, (int)(acfg->stats.info_size * 100 / all_sizes),
mini/aot-compiler.c:				(int)acfg->stats.ex_info_size, (int)(acfg->stats.ex_info_size * 100 / all_sizes),
mini/aot-compiler.c:				(int)acfg->stats.unwind_info_size, (int)(acfg->stats.unwind_info_size * 100 / all_sizes),
mini/aot-compiler.c:				(int)acfg->stats.class_info_size, (int)(acfg->stats.class_info_size * 100 / all_sizes),
mini/aot-compiler.c:				acfg->stats.plt_size ? (int)acfg->stats.plt_size : (int)acfg->plt_offset, acfg->stats.plt_size ? (int)(acfg->stats.plt_size * 100 / all_sizes) : 0,
mini/aot-compiler.c:				(int)acfg->stats.got_info_size, (int)(acfg->stats.got_info_size * 100 / all_sizes),
mini/aot-compiler.c:				(int)acfg->stats.offsets_size, (int)(acfg->stats.offsets_size * 100 / all_sizes),
mini/aot-compiler.c:			(int)(acfg->got_offset * sizeof (gpointer)));
mini/aot-compiler.c:			acfg->stats.ccount, acfg->stats.mcount, acfg->stats.mcount ? (acfg->stats.ccount * 100) / acfg->stats.mcount : 100,
mini/aot-compiler.c:			acfg->stats.methods_without_got_slots, acfg->stats.mcount ? (acfg->stats.methods_without_got_slots * 100) / acfg->stats.mcount : 100,
mini/aot-compiler.c:			acfg->stats.direct_calls, acfg->stats.all_calls ? (acfg->stats.direct_calls * 100) / acfg->stats.all_calls : 100);
mini/aot-compiler.c:	if (acfg->stats.genericcount)
mini/aot-compiler.c:		aot_printf (acfg, "%d methods are generic (%d%%)\n", acfg->stats.genericcount, acfg->stats.mcount ? (acfg->stats.genericcount * 100) / acfg->stats.mcount : 100);
mini/aot-compiler.c:	if (acfg->stats.abscount)
mini/aot-compiler.c:		aot_printf (acfg, "%d methods contain absolute addresses (%d%%)\n", acfg->stats.abscount, acfg->stats.mcount ? (acfg->stats.abscount * 100) / acfg->stats.mcount : 100);
mini/aot-compiler.c:	if (acfg->stats.lmfcount)
mini/aot-compiler.c:		aot_printf (acfg, "%d methods contain lmf pointers (%d%%)\n", acfg->stats.lmfcount, acfg->stats.mcount ? (acfg->stats.lmfcount * 100) / acfg->stats.mcount : 100);
mini/aot-compiler.c:	if (acfg->stats.ocount)
mini/aot-compiler.c:		aot_printf (acfg, "%d methods have other problems (%d%%)\n", acfg->stats.ocount, acfg->stats.mcount ? (acfg->stats.ocount * 100) / acfg->stats.mcount : 100);
mini/aot-compiler.c:	if (acfg->w) {
mini/aot-compiler.c:		res = mono_img_writer_emit_writeout (acfg->w);
mini/aot-compiler.c:	acfg->stats.link_time = TV_ELAPSED (atv, btv);
mini/aot-compiler.c:	if (acfg->aot_opts.stats) {
mini/aot-compiler.c:			if (acfg->stats.got_slot_types [i])
mini/aot-compiler.c:				aot_printf (acfg, "\t%s: %d (%d)\n", get_patch_name (i), acfg->stats.got_slot_types [i], acfg->stats.got_slot_info_sizes [i]);
mini/aot-compiler.c:		aot_printf (acfg, "\tNormal:    %d\n", acfg->stats.method_categories [METHOD_CAT_NORMAL]);
mini/aot-compiler.c:		aot_printf (acfg, "\tInstance:  %d\n", acfg->stats.method_categories [METHOD_CAT_INST]);
mini/aot-compiler.c:		aot_printf (acfg, "\tGSharedvt: %d\n", acfg->stats.method_categories [METHOD_CAT_GSHAREDVT]);
mini/aot-compiler.c:		aot_printf (acfg, "\tWrapper:   %d\n", acfg->stats.method_categories [METHOD_CAT_WRAPPER]);
mini/aot-compiler.c:	aot_printf (acfg, "JIT time: %d ms, Generation time: %d ms, Assembly+Link time: %d ms.\n", acfg->stats.jit_time / 1000, acfg->stats.gen_time / 1000, acfg->stats.link_time / 1000);
mini/aot-compiler.c:	if (acfg->aot_opts.dump_json)
mini/branch-opts.c:	MonoMethodHeader *header = cfg->header;
mini/branch-opts.c:	if (!(cfg->opt & MONO_OPT_EXCEPTION))
mini/branch-opts.c:				tbb = cfg->cil_offset_to_bb [clause->handler_offset];
mini/branch-opts.c:						jump->inst_i1 = (MonoInst *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst));
mini/branch-opts.c:						if (cfg->verbose_level > 2) 
mini/branch-opts.c:							g_print ("found exception to optimize - returning branch to BB%d (%s) (instead of throw) for method %s:%s\n", targetbb->block_num, clause->data.catch_class->name, cfg->method->klass->name, cfg->method->name);
mini/branch-opts.c:		tmp_bblocks = mono_mempool_alloc0 (cfg->mempool, sizeof (MonoBasicBlock*) * bb->out_count);
mini/branch-opts.c:	if (!(cfg->opt & MONO_OPT_CMOV))
mini/branch-opts.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/branch-opts.c:			if (cfg->verbose_level > 2) {
mini/branch-opts.c:			if (cfg->ret)
mini/branch-opts.c:				ret = ins1->dreg == cfg->ret->dreg;
mini/branch-opts.c:				move->dreg = cfg->ret->dreg;
mini/branch-opts.c:			if ((bb->out_bb [0]->in_count == 1) && (bb->out_bb [0] != cfg->bb_exit) &&
mini/branch-opts.c:			if (cfg->ret && ins1->dreg == cfg->ret->dreg)
mini/branch-opts.c:			if (!(cfg->opt & MONO_OPT_DEADCE))
mini/branch-opts.c:			if (cfg->verbose_level > 2) {
mini/branch-opts.c:			if ((bb->out_bb [0]->in_count == 1) && (bb->out_bb [0] != cfg->bb_exit) &&
mini/branch-opts.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/branch-opts.c:		if (cfg->verbose_level > 2) {
mini/branch-opts.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/branch-opts.c:		if (cfg->opt & MONO_OPT_BRANCH)
mini/branch-opts.c:		if (cfg->opt & (MONO_OPT_CONSPROP | MONO_OPT_COPYPROP))
mini/branch-opts.c:		if (cfg->opt & MONO_OPT_DEADCE)
mini/branch-opts.c:	if ((previous_bb == cfg->bb_entry) && (bb->next_bb != target_bb)) {
mini/branch-opts.c:		if (cfg->verbose_level > 1) {
mini/branch-opts.c:		if (previous_bb != cfg->bb_entry && mono_bb_is_fall_through (cfg, previous_bb)) {
mini/branch-opts.c:		for (prev_bb = cfg->bb_entry; prev_bb && prev_bb->next_bb != bbn; prev_bb = prev_bb->next_bb)
mini/branch-opts.c:	for (bbn = cfg->bb_entry; bbn->next_bb && bbn->next_bb != bb; bbn = bbn->next_bb)
mini/branch-opts.c:	for (bbn = cfg->bb_entry; bbn->next_bb; bbn = bbn->next_bb)
mini/branch-opts.c:	for (tmp_bb = cfg->bb_entry; tmp_bb && tmp_bb->next_bb != bb; tmp_bb = tmp_bb->next_bb)
mini/branch-opts.c:	if (cfg->verbose_level > 3) {
mini/branch-opts.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/branch-opts.c:	for (previous_bb = cfg->bb_entry, bb = previous_bb->next_bb; bb != NULL; previous_bb = previous_bb->next_bb, bb = bb->next_bb) {
mini/branch-opts.c:					new_bb->block_num = cfg->num_bblocks++;
mini/branch-opts.c:						if (previous_bb != cfg->bb_entry) {
mini/branch-opts.c:							new_bb_after_entry->block_num = cfg->num_bblocks++;
mini/branch-opts.c:							if (cfg->verbose_level > 2) {
mini/branch-opts.c:					if (cfg->verbose_level > 2) {
mini/branch-opts.c:	if (cfg->verbose_level > 3) {
mini/branch-opts.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/branch-opts.c:	if (cfg->num_bblocks > 1000)
mini/branch-opts.c:		niterations = cfg->num_bblocks * 2;
mini/branch-opts.c:		for (previous_bb = cfg->bb_entry, bb = cfg->bb_entry->next_bb; bb; previous_bb = bb, bb = bb->next_bb) {
mini/branch-opts.c:			if ((bbn = bb->next_bb) && bbn->in_count == 0 && bbn != cfg->bb_exit && bb->region == bbn->region) {
mini/branch-opts.c:				if (cfg->verbose_level > 2)
mini/branch-opts.c:					if (cfg->verbose_level > 2)
mini/branch-opts.c:						if (cfg->verbose_level > 2)
mini/branch-opts.c:						if (bbn != cfg->bb_exit) {
mini/branch-opts.c:							if (cfg->verbose_level > 2)
mini/branch-opts.c:			if ((bbn = bb->next_bb) && bbn->in_count == 0 && bbn != cfg->bb_exit && bb->region == bbn->region) {
mini/branch-opts.c:				if (cfg->verbose_level > 2) {
mini/branch-opts.c:						if (cfg->verbose_level > 2)
mini/branch-opts.c:						if (cfg->verbose_level > 2)		
mini/branch-opts.c:						if (cfg->verbose_level > 2)
mini/branch-opts.c:					if (bbn && bb->region == bbn->region && bbn->in_count == 1 && cfg->enable_extended_bblocks && bbn != cfg->bb_exit && !bb->extended && !bbn->out_of_line && !mono_bblocks_linked (bbn, bb)) {
mini/branch-opts.c:						if (cfg->verbose_level > 2)
mini/branch-opts.c:					if (bb->last_ins->inst_false_bb && bb->last_ins->inst_false_bb->out_of_line && (bb->region == bb->last_ins->inst_false_bb->region) && !cfg->disable_out_of_line_bblocks) {
mini/branch-opts.c:						if (cfg->verbose_level > 2)
mini/cfgdump.c:	ConstantPoolEntry *entry = (ConstantPoolEntry *) mono_mempool_alloc0 (cfg->mempool, sizeof (ConstantPoolEntry));
mini/cfgdump.c:	write (cfg->gdump_ctx->fd, &b, 1);
mini/cfgdump.c:	write (cfg->gdump_ctx->fd, &swap, 2);
mini/cfgdump.c:	write (cfg->gdump_ctx->fd, &swap, 4);
mini/cfgdump.c:	int *cp_id= (int *) mono_mempool_alloc0 (cfg->mempool, sizeof (int));
mini/cfgdump.c:	*cp_id = cfg->gdump_ctx->next_cp_id;
mini/cfgdump.c:	g_hash_table_insert (cfg->gdump_ctx->constant_pool, entry, cp_id);
mini/cfgdump.c:	write_short (cfg, cfg->gdump_ctx->next_cp_id++);
mini/cfgdump.c:	short *cp_index = (short *) g_hash_table_lookup (cfg->gdump_ctx->constant_pool, entry);
mini/cfgdump.c:	if (cfg->gdump_ctx == NULL)
mini/cfgdump.c:	char *title = (char *) mono_mempool_alloc0 (cfg->mempool, 0x2000);
mini/cfgdump.c:	sprintf (title, "%s::%s", cfg->method->klass->name, cfg->method->name);
mini/cfgdump.c:	write_pool (cfg, create_cp_entry (cfg, (void *) cfg->method->name, PT_STRING));
mini/cfgdump.c:	write_pool (cfg, create_cp_entry (cfg, (void *) cfg->method, PT_METHOD));
mini/cfgdump.c:	if (cfg->gdump_ctx == NULL)
mini/cfgdump.c:	cfg->gdump_ctx = NULL;
mini/cfgdump.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/cfgdump.c:			void *id = g_hash_table_lookup (cfg->gdump_ctx->insn2id, insn);
mini/cfgdump.c:			int *new_id = (int *) mono_mempool_alloc0 (cfg->mempool, sizeof (int));
mini/cfgdump.c:			*new_id = cfg->gdump_ctx->next_insn_id++;
mini/cfgdump.c:			g_hash_table_insert (cfg->gdump_ctx->insn2id, insn, new_id);
mini/cfgdump.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/cfgdump.c:			int *id = (int *) g_hash_table_lookup (cfg->gdump_ctx->insn2id, insn);
mini/cfgdump.c:			write_byte (cfg, cfg->bb_entry->code != insn);
mini/cfgdump.c:				next_id = (int *) g_hash_table_lookup (cfg->gdump_ctx->insn2id, insn->next);
mini/cfgdump.c:						next_id = (int *) g_hash_table_lookup (cfg->gdump_ctx->insn2id, bb->out_bb[i]->code);
mini/cfgdump.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/cfgdump.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/cfgdump.c:			int *id = (int *) g_hash_table_lookup (cfg->gdump_ctx->insn2id, insn);
mini/cfgdump.c:	cfg->gdump_ctx = NULL;
mini/cfgdump.c:		gboolean failed = !mono_method_desc_full_match (desc, cfg->method);
mini/cfgdump.c:		if (strcmp (cfg->method->name, name) != 0)
mini/cfgdump.c:	g_debug ("cfg_dump: create context for \"%s::%s\"", cfg->method->klass->name, cfg->method->name);
mini/cfgdump.c:	MonoGraphDumper *ctx = (MonoGraphDumper *) mono_mempool_alloc0 (cfg->mempool, sizeof (MonoGraphDumper));
mini/cfgdump.c:	cfg->gdump_ctx = ctx;
mini/cfgdump.c:	if (cfg->gdump_ctx == NULL)
mini/debug-mini.c:	cfg->debug_info = info;
mini/debug-mini.c:	info = (MiniDebugMethodInfo *) cfg->debug_info;
mini/debug-mini.c:	mono_class_init (cfg->method->klass);
mini/debug-mini.c:	header = cfg->header;
mini/debug-mini.c:	info = (MiniDebugMethodInfo *) cfg->debug_info;
mini/debug-mini.c:	method = cfg->method;
mini/debug-mini.c:	header = cfg->header;
mini/debug-mini.c:	jit->code_start = cfg->native_code;
mini/debug-mini.c:	jit->epilogue_begin = cfg->epilog_begin;
mini/debug-mini.c:	jit->code_size = cfg->code_len;
mini/debug-mini.c:			write_variable (cfg->locals [i], &jit->locals [i]);
mini/debug-mini.c:			write_variable (cfg->args [0], jit->this_var);
mini/debug-mini.c:			write_variable (cfg->args [i + sig->hasthis], &jit->params [i]);
mini/debug-mini.c:		if (cfg->gsharedvt_info_var) {
mini/debug-mini.c:			write_variable (cfg->gsharedvt_info_var, jit->gsharedvt_info_var);
mini/debug-mini.c:			write_variable (cfg->gsharedvt_locals_var, jit->gsharedvt_locals_var);
mini/debug-mini.c:	mono_debug_add_method (cfg->method_to_register, jit, cfg->domain);
mini/debug-mini.c:	info = (MiniDebugMethodInfo *) cfg->debug_info;
mini/debug-mini.c:		cfg->debug_info = NULL;	
mini/debug-mini.c:	info = (MiniDebugMethodInfo *) cfg->debug_info;
mini/debug-mini.c:	header = cfg->header;
mini/debug-mini.c:	info = (MiniDebugMethodInfo *) cfg->debug_info;
mini/debug-mini.c:	header = cfg->header;
mini/debug-mini.c:	/* Can't use cfg->debug_info as it is freed by close_method () */
mini/debug-mini.c:	jit = mono_debug_find_method (cfg->method, mono_domain_get ());
mini/decompose.c:		if (cfg->backend->ilp32 && SIZEOF_REGISTER == 8)
mini/decompose.c:		if (cfg->backend->ilp32 && SIZEOF_REGISTER == 8)
mini/decompose.c:		if (cfg->backend->ilp32 && SIZEOF_REGISTER == 8)
mini/decompose.c:		if (cfg->backend->ilp32 && SIZEOF_REGISTER == 8)
mini/decompose.c:		if (cfg->backend->emulate_div && mono_arch_opcode_needs_emulation (cfg, ins->opcode))
mini/decompose.c:			if (cfg->backend->need_div_check) {
mini/decompose.c:		if (cfg->backend->emulate_div && mono_arch_opcode_needs_emulation (cfg, ins->opcode))
mini/decompose.c:			if (cfg->backend->need_div_check) {
mini/decompose.c:		if (cfg->backend->need_div_check) {
mini/decompose.c:			cfg->has_emulated_ops = TRUE;
mini/decompose.c:			ins = cfg->cbb->last_ins;
mini/decompose.c:	cfg->cbb = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/decompose.c:	first_bb = cfg->cbb;
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/decompose.c:		cfg->cbb->code = cfg->cbb->last_ins = NULL;
mini/decompose.c:			if (cfg->cbb->code || (cfg->cbb != first_bb)) {
mini/decompose.c:				mono_replace_ins (cfg, bb, tree, &new_prev, first_bb, cfg->cbb);
mini/decompose.c:				cfg->cbb = first_bb;
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/decompose.c:	cfg->cbb = (MonoBasicBlock *)mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/decompose.c:	first_bb = cfg->cbb;
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/decompose.c:		if (cfg->verbose_level > 2) mono_print_bb (bb, "BEFORE LOWER-VTYPE-OPTS ");
mini/decompose.c:		cfg->cbb->code = cfg->cbb->last_ins = NULL;
mini/decompose.c:					if (cfg->compute_gc_maps) {
mini/decompose.c:						MONO_ADD_INS (cfg->cbb, tmp);
mini/decompose.c:					if (COMPILE_LLVM (cfg) && !mini_is_gsharedvt_klass (ins->klass) && !cfg->gen_write_barriers)
mini/decompose.c:						MONO_ADD_INS (cfg->cbb, ((MonoInst*)call2));
mini/decompose.c:				g_assert (cfg->cbb == first_bb);
mini/decompose.c:				if (cfg->cbb->code || (cfg->cbb != first_bb)) {
mini/decompose.c:					mono_replace_ins (cfg, bb, ins, &prev, first_bb, cfg->cbb);
mini/decompose.c:					cfg->cbb = first_bb;
mini/decompose.c:		if (cfg->verbose_level > 2) mono_print_bb (bb, "AFTER LOWER-VTYPE-OPTS ");
mini/decompose.c:	if (!cfg->domainvar)
mini/decompose.c:		cfg->domainvar = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/decompose.c:	return cfg->domainvar;
mini/decompose.c:	cfg->cbb = (MonoBasicBlock *)mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/decompose.c:	first_bb = cfg->cbb;
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/decompose.c:		if (cfg->verbose_level > 3) mono_print_bb (bb, "BEFORE DECOMPOSE-ARRAY-ACCESS-OPTS ");
mini/decompose.c:		cfg->cbb->code = cfg->cbb->last_ins = NULL;
mini/decompose.c:					MONO_ADD_INS (cfg->cbb, dest);
mini/decompose.c:					if (cfg->opt & MONO_OPT_SHARED) {
mini/decompose.c:						MonoVTable *vtable = mono_class_vtable (cfg->domain, array_class);
mini/decompose.c:						MONO_ADD_INS (cfg->cbb, iargs [0]);
mini/decompose.c:				g_assert (cfg->cbb == first_bb);
mini/decompose.c:				if (cfg->cbb->code || (cfg->cbb != first_bb)) {
mini/decompose.c:					mono_replace_ins (cfg, bb, ins, &prev, first_bb, cfg->cbb);
mini/decompose.c:					cfg->cbb = first_bb;
mini/decompose.c:		if (cfg->verbose_level > 3) mono_print_bb (bb, "AFTER DECOMPOSE-ARRAY-ACCESS-OPTS ");
mini/decompose.c:	cfg->cbb = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/decompose.c:	first_bb = cfg->cbb;
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/decompose.c:		if (cfg->verbose_level > 3) mono_print_bb (bb, "BEFORE HANDLE-SOFT-FLOAT ");
mini/decompose.c:		cfg->cbb->code = cfg->cbb->last_ins = NULL;
mini/decompose.c:						MONO_ADD_INS (cfg->cbb, (MonoInst*)call2);
mini/decompose.c:					MONO_ADD_INS (cfg->cbb, cmp);
mini/decompose.c:					br->inst_many_bb = mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * 2);
mini/decompose.c:					MONO_ADD_INS (cfg->cbb, br);
mini/decompose.c:					MONO_ADD_INS (cfg->cbb, cmp);
mini/decompose.c:				g_assert (cfg->cbb == first_bb);
mini/decompose.c:				if (cfg->cbb->code || (cfg->cbb != first_bb)) {
mini/decompose.c:					mono_replace_ins (cfg, bb, ins, &prev, first_bb, cfg->cbb);
mini/decompose.c:					cfg->cbb = first_bb;
mini/decompose.c:		if (cfg->verbose_level > 3) mono_print_bb (bb, "AFTER HANDLE-SOFT-FLOAT ");
mini/decompose.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/decompose.c:				args = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst*) * info->sig->param_count);
mini/decompose.c:				cfg->cbb = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/decompose.c:				first_bb = cfg->cbb;
mini/decompose.c:				if (cfg->cbb->code || (cfg->cbb != first_bb)) {
mini/decompose.c:					mono_replace_ins (cfg, bb, ins, &ins->prev, first_bb, cfg->cbb);
mini/decompose.c:					cfg->cbb = first_bb;
mini/decompose.c:		if (cfg->opt & (MONO_OPT_CONSPROP | MONO_OPT_COPYPROP))
mini/dominators.c:	g_assert (!(cfg->comp_done & MONO_COMP_DOM));
mini/dominators.c:	bitsize = mono_bitset_alloc_size (cfg->num_bblocks, 0);
mini/dominators.c:	entry = cfg->bblocks [0];
mini/dominators.c:	doms = g_new0 (MonoBasicBlock*, cfg->num_bblocks);
mini/dominators.c:	if (cfg->verbose_level > 1) {
mini/dominators.c:		for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:			MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:		for (bindex = 0; bindex < cfg->num_bblocks; ++bindex) {
mini/dominators.c:			MonoBasicBlock *bb = cfg->bblocks [bindex];
mini/dominators.c:			if (bb != cfg->bblocks [0])
mini/dominators.c:				if (bb == cfg->bblocks [0])
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:		mem = (char *)mono_mempool_alloc0 (cfg->mempool, bitsize);
mini/dominators.c:		bb->dominators = dominators = mono_bitset_mem_new (mem, cfg->num_bblocks, 0);
mini/dominators.c:				bb->idom->dominated = g_slist_prepend_mempool (cfg->mempool, bb->idom->dominated, bb);
mini/dominators.c:	cfg->comp_done |= MONO_COMP_DOM | MONO_COMP_IDOM;
mini/dominators.c:	if (cfg->verbose_level > 1) {
mini/dominators.c:		printf ("DTREE %s %d\n", mono_method_full_name (cfg->method, TRUE),
mini/dominators.c:			cfg->header->num_clauses);
mini/dominators.c:		for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:			MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:	g_assert (!(cfg->comp_done & MONO_COMP_DFRONTIER));
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i)
mini/dominators.c:		cfg->bblocks [i]->flags &= ~BB_VISITED;
mini/dominators.c:	bitsize = mono_bitset_alloc_size (cfg->num_bblocks, 0);
mini/dominators.c:	mem = (char *)mono_mempool_alloc0 (cfg->mempool, bitsize * cfg->num_bblocks);
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:		bb->dfrontier = mono_bitset_mem_new (mem, cfg->num_bblocks, 0);
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:				if (p->dfn || (p == cfg->bblocks [0])) {
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/dominators.c:		printf ("DFRONT %s BB%d: ", mono_method_full_name (cfg->method, TRUE), bb->block_num);
mini/dominators.c:	cfg->comp_done |= MONO_COMP_DFRONTIER;
mini/dominators.c:	if ((dom_flags & MONO_COMP_DOM) && !(cfg->comp_done & MONO_COMP_DOM))
mini/dominators.c:	if ((dom_flags & MONO_COMP_DFRONTIER) && !(cfg->comp_done & MONO_COMP_DFRONTIER))
mini/dominators.c:	g_assert (!(cfg->comp_done & MONO_COMP_LOOPS));
mini/dominators.c:	in_loop_blocks = mono_bitset_new (cfg->num_bblocks + 1, 0);
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		MonoBasicBlock *n = cfg->bblocks [i];
mini/dominators.c:				h->loop_blocks = g_list_prepend_mempool (cfg->mempool, h->loop_blocks, h);
mini/dominators.c:					h->loop_blocks = g_list_prepend_mempool (cfg->mempool, h->loop_blocks, cb);
mini/dominators.c:					h->loop_blocks = g_list_prepend_mempool (cfg->mempool, h->loop_blocks, h);
mini/dominators.c:	cfg->comp_done |= MONO_COMP_LOOPS;
mini/dominators.c:	bb_indexes = g_new0 (int, cfg->num_bblocks);
mini/dominators.c:		for (i = 0, bb = cfg->bb_entry; bb; i ++, bb = bb->next_bb) {
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		if (cfg->bblocks [i]->loop_blocks) {
mini/dominators.c:			MonoBasicBlock *h = cfg->bblocks [i];
mini/dominators.c:	if (cfg->verbose_level > 1) {
mini/dominators.c:		for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:			if (cfg->bblocks [i]->loop_blocks) {
mini/dominators.c:				MonoBasicBlock *h = (MonoBasicBlock *)cfg->bblocks [i]->loop_blocks->data;
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		if (cfg->bblocks[i]->dominated) {
mini/dominators.c:			cfg->bblocks[i]->dominated = NULL;
mini/dominators.c:	cfg->comp_done &= ~MONO_COMP_IDOM;   
mini/dominators.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/dominators.c:		cfg->bblocks[i]->nesting = 0;
mini/dominators.c:		cfg->bblocks[i]->loop_blocks = NULL;
mini/dominators.c:	cfg->comp_done &= ~MONO_COMP_LOOPS;   
mini/dominators.c:    if (cfg->comp_done & MONO_COMP_IDOM)
mini/dominators.c:    if (cfg->comp_done & MONO_COMP_LOOPS)
mini/driver.c:			if (cfg->exception_type == MONO_EXCEPTION_NONE) {
mini/driver.c:					func = (TestMethod)(gpointer)cfg->native_code;
mini/driver.c:					func = (TestMethod)(gpointer)cfg->native_code;
mini/driver.c:				code_size += cfg->code_len;
mini/driver.c:		if (cfg->exception_type != MONO_EXCEPTION_NONE) {
mini/driver.c:			printf ("Compilation of %s failed with exception '%s':\n", mono_method_full_name (cfg->method, TRUE), cfg->exception_message);
mini/driver.c:		if ((mono_graph_options & MONO_GRAPH_CFG_SSA) && !(cfg->comp_done & MONO_COMP_SSA)) {
mini/dwarfwriter.c:	if (cfg->varinfo) {
mini/dwarfwriter.c:		for (j = 0; j < cfg->num_varinfo; ++j) {
mini/dwarfwriter.c:			if (cfg->varinfo [j] == ins)
mini/dwarfwriter.c:		if (j < cfg->num_varinfo) {
mini/graph.c:	for (i = 1; i < cfg->num_bblocks; ++i) {
mini/graph.c:		bb = cfg->bblocks [i];
mini/graph.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/graph.c:	g_assert ((cfg->comp_done & MONO_COMP_IDOM));
mini/graph.c:	fprintf (fp, "digraph %s {\n", convert_name (cfg->method->name));
mini/graph.c:	fprintf (fp, "label=\"Dominator tree for %s\";\n", mono_method_full_name (cfg->method, TRUE));
mini/graph.c:	fprintf (fp, "digraph %s {\n", convert_name (cfg->method->name));
mini/graph.c:	fprintf (fp, "label=\"CFG for %s\";\n", mono_method_full_name (cfg->method, TRUE));
mini/graph.c:	fprintf (fp, "digraph %s {\n", convert_name (cfg->method->name));
mini/graph.c:	fprintf (fp, "label=\"CFG for %s\";\n", mono_method_full_name (cfg->method, TRUE));
mini/graph.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/graph.c:		if (bb == cfg->bb_exit)
mini/graph.c:		if ((cfg->comp_done & MONO_COMP_REACHABILITY) && (bb->flags & BB_REACHABLE))
mini/helpers.c:	mono_bitset_foreach_bit (set, i, cfg->num_bblocks) {
mini/helpers.c:			g_print (" [BB%d]", cfg->bblocks [i]->block_num);
mini/helpers.c:			g_print (" BB%d", cfg->bblocks [i]->block_num);
mini/helpers.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/image-writer.c:	acfg->labels = g_hash_table_new (g_str_hash, g_str_equal);
mini/image-writer.c:	if (acfg->cur_section && acfg->cur_section->subsection == subsection_index
mini/image-writer.c:			&& strcmp (acfg->cur_section->name, section_name) == 0)
mini/image-writer.c:	for (section = acfg->sections; section; section = section->next) {
mini/image-writer.c:			acfg->cur_section = section;
mini/image-writer.c:		section->next = acfg->sections;
mini/image-writer.c:		acfg->sections = section;
mini/image-writer.c:		acfg->cur_section = section;
mini/image-writer.c:	acfg->cur_section->addr = addr;
mini/image-writer.c:	acfg->cur_section->has_addr = TRUE;
mini/image-writer.c:	symbol->section = acfg->cur_section;
mini/image-writer.c:	symbol->next = acfg->symbols;
mini/image-writer.c:	acfg->symbols = symbol;
mini/image-writer.c:	label->section = acfg->cur_section;
mini/image-writer.c:	label->offset = acfg->cur_section->cur_offset;
mini/image-writer.c:	g_hash_table_insert (acfg->labels, label->name, label);
mini/image-writer.c:	bin_writer_emit_ensure_buffer (acfg->cur_section, size);
mini/image-writer.c:	memcpy (acfg->cur_section->data + acfg->cur_section->cur_offset, buf, size);
mini/image-writer.c:	acfg->cur_section->cur_offset += size;
mini/image-writer.c:	int offset = acfg->cur_section->cur_offset;
mini/image-writer.c:	add = offset - acfg->cur_section->cur_offset;
mini/image-writer.c:		bin_writer_emit_ensure_buffer (acfg->cur_section, add);
mini/image-writer.c:		acfg->cur_section->cur_offset += add;
mini/image-writer.c:		acfg->cur_section->cur_offset += sizeof (gpointer);
mini/image-writer.c:	reloc->section = acfg->cur_section;
mini/image-writer.c:	reloc->section_offset = acfg->cur_section->cur_offset;
mini/image-writer.c:	reloc->next = acfg->relocations;
mini/image-writer.c:	acfg->relocations = reloc;
mini/image-writer.c:		acfg->num_relocs++;
mini/image-writer.c:		//g_print ("reloc: %s at %d\n", target, acfg->cur_section->cur_offset);
mini/image-writer.c:	acfg->cur_section->cur_offset += sizeof (gpointer);
mini/image-writer.c:	bin_writer_emit_ensure_buffer (acfg->cur_section, 2);
mini/image-writer.c:	data = acfg->cur_section->data + acfg->cur_section->cur_offset;
mini/image-writer.c:	acfg->cur_section->cur_offset += 2;
mini/image-writer.c:	bin_writer_emit_ensure_buffer (acfg->cur_section, 4);
mini/image-writer.c:	data = acfg->cur_section->data + acfg->cur_section->cur_offset;
mini/image-writer.c:	acfg->cur_section->cur_offset += 4;
mini/image-writer.c:	reloc = (BinReloc *)mono_mempool_alloc0 (acfg->mempool, sizeof (BinReloc));
mini/image-writer.c:	reloc->val1 = mono_mempool_strdup (acfg->mempool, end);
mini/image-writer.c:		reloc->val2_section = acfg->cur_section;
mini/image-writer.c:		reloc->val2_offset = acfg->cur_section->cur_offset;
mini/image-writer.c:		reloc->val2 = mono_mempool_strdup (acfg->mempool, start);
mini/image-writer.c:	reloc->section = acfg->cur_section;
mini/image-writer.c:	reloc->section_offset = acfg->cur_section->cur_offset;
mini/image-writer.c:	reloc->next = acfg->relocations;
mini/image-writer.c:	acfg->relocations = reloc;
mini/image-writer.c:	acfg->cur_section->cur_offset += 4;
mini/image-writer.c:		acfg->num_relocs++;
mini/image-writer.c:		g_print ("reloc: %s - %s + %d at %d\n", end, start, offset, acfg->cur_section->cur_offset - 4);
mini/image-writer.c:	bin_writer_emit_ensure_buffer (acfg->cur_section, num);
mini/image-writer.c:	acfg->cur_section->cur_offset += num;
mini/image-writer.c:	if (acfg->fp)
mini/image-writer.c:		fwrite (val, size, nmemb, acfg->fp);
mini/image-writer.c:		g_assert (acfg->out_buf_pos + (size * nmemb) <= acfg->out_buf_size);
mini/image-writer.c:		memcpy (acfg->out_buf + acfg->out_buf_pos, val, size * nmemb);
mini/image-writer.c:		acfg->out_buf_pos += (size * nmemb);
mini/image-writer.c:	if (acfg->fp)
mini/image-writer.c:		fseek (acfg->fp, offset, SEEK_SET);
mini/image-writer.c:		acfg->out_buf_pos = offset;
mini/image-writer.c:	lab = g_hash_table_lookup (acfg->labels, name);
mini/image-writer.c:	for (reloc = acfg->relocations; reloc; reloc = reloc->next) {
mini/image-writer.c:	for (s = acfg->sections; s; s = s->next) {
mini/image-writer.c:	for (s = acfg->sections; s; s = s->next) {
mini/image-writer.c:	if (!acfg->fp) {
mini/image-writer.c:		acfg->out_buf_size = file_size;
mini/image-writer.c:		acfg->out_buf = g_malloc (acfg->out_buf_size);
mini/image-writer.c:	for (s = acfg->sections; s; s = s->next) {
mini/image-writer.c:		if (!acfg->fp)
mini/image-writer.c:			g_assert (acfg->out_buf_pos == s->file_offset);
mini/image-writer.c:	if (acfg->fp)
mini/image-writer.c:		fclose (acfg->fp);
mini/image-writer.c:	for (sect = acfg->sections; sect; sect = sect->next) {
mini/image-writer.c:			for (sect = acfg->sections; sect; sect = sect->next) {
mini/image-writer.c:	for (symbol = acfg->symbols; symbol; symbol = symbol->next) {
mini/image-writer.c:	lab = (BinLabel *)g_hash_table_lookup (acfg->labels, name);
mini/image-writer.c:		for (symbol = acfg->symbols; symbol; symbol = symbol->next)
mini/image-writer.c:		for (section = acfg->sections; section; section = section->next) {
mini/image-writer.c:	for (symbol = acfg->symbols; symbol; symbol = symbol->next) {
mini/image-writer.c:		lab = (BinLabel *)g_hash_table_lookup (acfg->labels, symbol->name);
mini/image-writer.c:			BinLabel *elab = (BinLabel *)g_hash_table_lookup (acfg->labels, symbol->end_label);
mini/image-writer.c:		for (section = acfg->sections; section; section = section->next) {
mini/image-writer.c:	for (symbol = acfg->symbols; symbol; symbol = symbol->next) {
mini/image-writer.c:		lab = (BinLabel *)g_hash_table_lookup (acfg->labels, symbol->name);
mini/image-writer.c:	rr = g_new0 (ElfRelocA, acfg->num_relocs);
mini/image-writer.c:	for (reloc = acfg->relocations; reloc; reloc = reloc->next) {
mini/image-writer.c:			g_assert (i <= acfg->num_relocs);
mini/image-writer.c:	rr = g_new0 (ElfReloc, acfg->num_relocs);
mini/image-writer.c:	for (reloc = acfg->relocations; reloc; reloc = reloc->next) {
mini/image-writer.c:			g_assert (i <= acfg->num_relocs);
mini/image-writer.c:	size = sizeof (ElfReloc) * acfg->num_relocs;
mini/image-writer.c:	size = sizeof (ElfRelocA) * acfg->num_relocs;
mini/image-writer.c:	dynamic [i].d_un.d_val = acfg->num_relocs;
mini/image-writer.c:	if (!acfg->fp) {
mini/image-writer.c:		acfg->out_buf_size = file_offset + sizeof (secth);
mini/image-writer.c:		acfg->out_buf = (guint8 *)g_malloc (acfg->out_buf_size);
mini/image-writer.c:	bin_writer_fwrite (acfg, relocs, sizeof (ElfReloc), acfg->num_relocs);
mini/image-writer.c:	if (acfg->fp)
mini/image-writer.c:		fclose (acfg->fp);
mini/image-writer.c:	fprintf (acfg->fp, ".subsections_via_symbols\n");
mini/image-writer.c:	fclose (acfg->fp);
mini/image-writer.c:	if (acfg->mode == EMIT_NONE)
mini/image-writer.c:	fprintf (acfg->fp, "\n");
mini/image-writer.c:	acfg->mode = EMIT_NONE;
mini/image-writer.c:		fprintf (acfg->fp, "%s\n", ".data");
mini/image-writer.c:		fprintf (acfg->fp, ".section __DWARF, __%s,regular,debug\n", section_name + 1);
mini/image-writer.c:		fprintf (acfg->fp, "%s\n", section_name);
mini/image-writer.c:		fprintf (acfg->fp, "%s %d\n", section_name, subsection_index);
mini/image-writer.c:		fprintf (acfg->fp, ".section \"%s\"\n", section_name);
mini/image-writer.c:		fprintf (acfg->fp, ".subsection %d\n", subsection_index);
mini/image-writer.c:	fprintf (acfg->fp, ".section %s\n", section_name);
mini/image-writer.c:		fprintf (acfg->fp, "%s %d\n", section_name, subsection_index);
mini/image-writer.c:		fprintf (acfg->fp, ".section \"%s\"\n", section_name);
mini/image-writer.c:		fprintf (acfg->fp, ".subsection %d\n", subsection_index);
mini/image-writer.c:		if (strcmp (acfg->current_section, data_sections [i]) == 0) {
mini/image-writer.c:		fprintf (acfg->fp, "\t.def %s; .scl %d; .type 32; .endef\n", name, (global == TRUE ? GLOBAL_SYMBOL_DEF_SCL : LOCAL_SYMBOL_DEF_SCL));
mini/image-writer.c:			fprintf (acfg->fp, "\t.data\n");
mini/image-writer.c:	fprintf (acfg->fp, "\t.type %s,#%s\n", name, stype);
mini/image-writer.c:	fprintf (acfg->fp, "\t.type %s,@%s\n", name, stype);
mini/image-writer.c:	fprintf (acfg->fp, "\t.globl %s\n", name);
mini/image-writer.c:	fprintf (acfg->fp, "\t.local %s\n", name);
mini/image-writer.c:	fprintf (acfg->fp, "\t.size %s,%s-%s\n", name, end_label, name);
mini/image-writer.c:	fprintf (acfg->fp, "%s:\n", get_label (name));
mini/image-writer.c:	fprintf (acfg->fp, "\t%s \"%s\"\n", AS_STRING_DIRECTIVE, value);
mini/image-writer.c:	fprintf (acfg->fp, "\n");
mini/image-writer.c:	fprintf (acfg->fp, "\t.align %d\n", ilog2 (size));
mini/image-writer.c:	fprintf (acfg->fp, "\t.align %d\t; ilog2\n", ilog2(size));
mini/image-writer.c:	fprintf (acfg->fp, "\t.balign %d\n", size);
mini/image-writer.c:	fprintf (acfg->fp, "\t.align %d\n", ilog2 (size));
mini/image-writer.c:	fprintf (acfg->fp, "\t.align %d\n", size);
mini/image-writer.c:	fprintf (acfg->fp, "\t.align %d, 0x%0x\n", ilog2 (size), fill);
mini/image-writer.c:	fprintf (acfg->fp, "\t%s %s\n", AS_POINTER_DIRECTIVE, target ? target : "0");
mini/image-writer.c:	if (acfg->mode != EMIT_BYTE) {
mini/image-writer.c:		acfg->mode = EMIT_BYTE;
mini/image-writer.c:		acfg->col_count = 0;
mini/image-writer.c:	for (i = 0; i < size; ++i, ++acfg->col_count) {
mini/image-writer.c:		if ((acfg->col_count % 32) == 0)
mini/image-writer.c:			fprintf (acfg->fp, "\n\t.byte %d", buf [i]);
mini/image-writer.c:			fputs (byte_to_str + (buf [i] * 8), acfg->fp);
mini/image-writer.c:	if (acfg->mode != EMIT_WORD) {
mini/image-writer.c:		acfg->mode = EMIT_WORD;
mini/image-writer.c:		acfg->col_count = 0;
mini/image-writer.c:	if ((acfg->col_count++ % 8) == 0)
mini/image-writer.c:		fprintf (acfg->fp, "\n\t%s ", AS_INT16_DIRECTIVE);
mini/image-writer.c:		fprintf (acfg->fp, ", ");
mini/image-writer.c:	fprintf (acfg->fp, "%d", value);
mini/image-writer.c:	if (acfg->mode != EMIT_LONG) {
mini/image-writer.c:		acfg->mode = EMIT_LONG;
mini/image-writer.c:		acfg->col_count = 0;
mini/image-writer.c:	if ((acfg->col_count++ % 8) == 0)
mini/image-writer.c:		fprintf (acfg->fp, "\n\t%s ", AS_INT32_DIRECTIVE);
mini/image-writer.c:		fprintf (acfg->fp, ",");
mini/image-writer.c:	fprintf (acfg->fp, "%d", value);
mini/image-writer.c:	if (acfg->mode != EMIT_LONG) {
mini/image-writer.c:		acfg->mode = EMIT_LONG;
mini/image-writer.c:		acfg->col_count = 0;
mini/image-writer.c:	sprintf (symbol, "LTMP_SYM%d", acfg->label_gen);
mini/image-writer.c:	acfg->label_gen ++;
mini/image-writer.c:		fprintf (acfg->fp, "\n%s=%s - %s + %d", symbol, end, start, offset);
mini/image-writer.c:		fprintf (acfg->fp, "\n%s=%s - %s %d", symbol, end, start, offset);
mini/image-writer.c:		fprintf (acfg->fp, "\n%s=%s - %s", symbol, end, start);
mini/image-writer.c:	fprintf (acfg->fp, "\n\t%s ", AS_INT32_DIRECTIVE);
mini/image-writer.c:	fprintf (acfg->fp, "%s", symbol);
mini/image-writer.c:		sprintf (symbol, "%sDIFF_SYM%d", AS_TEMP_LABEL_PREFIX, acfg->label_gen);
mini/image-writer.c:		acfg->label_gen ++;
mini/image-writer.c:		fprintf (acfg->fp, "\n%s=%s - %s", symbol, end, start);
mini/image-writer.c:		fprintf (acfg->fp, "\n\t%s ", AS_INT32_DIRECTIVE);
mini/image-writer.c:		fprintf (acfg->fp, "%s", symbol);
mini/image-writer.c:	if ((acfg->col_count++ % 8) == 0)
mini/image-writer.c:		fprintf (acfg->fp, "\n\t%s ", AS_INT32_DIRECTIVE);
mini/image-writer.c:		fprintf (acfg->fp, ",");
mini/image-writer.c:		fprintf (acfg->fp, "%s - %s + %d", end, start, offset);
mini/image-writer.c:		fprintf (acfg->fp, "%s - %s %d", end, start, offset);
mini/image-writer.c:		fprintf (acfg->fp, "%s - %s", end, start);
mini/image-writer.c:	fprintf (acfg->fp, "\t%s %d\n", AS_SKIP_DIRECTIVE, num);
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	acfg->current_section = section_name;
mini/image-writer.c:	acfg->current_subsection = subsection_index;
mini/image-writer.c:	g_assert (acfg->stack_pos < 16 - 1);
mini/image-writer.c:	acfg->section_stack [acfg->stack_pos] = acfg->current_section;
mini/image-writer.c:	acfg->subsection_stack [acfg->stack_pos] = acfg->current_subsection;
mini/image-writer.c:	acfg->stack_pos ++;
mini/image-writer.c:	g_assert (acfg->stack_pos > 0);
mini/image-writer.c:	acfg->stack_pos --;
mini/image-writer.c:	mono_img_writer_emit_section_change (acfg, acfg->section_stack [acfg->stack_pos], acfg->subsection_stack [acfg->stack_pos]);
mini/image-writer.c:	if (!acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (!acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (acfg->use_bin_writer)
mini/image-writer.c:	if (!acfg->use_bin_writer)
mini/image-writer.c:	g_assert (acfg->use_bin_writer);
mini/image-writer.c:	buf = acfg->out_buf;
mini/image-writer.c:	*size = acfg->out_buf_size;
mini/image-writer.c:	acfg->out_buf = NULL;
mini/image-writer.c:	return acfg->use_bin_writer;
mini/image-writer.c:	return acfg->fp;
mini/ir-emit.h:	return cfg->next_vreg ++;
mini/ir-emit.h:	return cfg->next_vreg ++;
mini/ir-emit.h:	guint32 res = cfg->next_vreg;
mini/ir-emit.h:	cfg->next_vreg += 3;
mini/ir-emit.h:		return cfg->next_vreg ++;
mini/ir-emit.h:	if (cfg->compute_gc_maps)
mini/ir-emit.h:	if (cfg->compute_gc_maps)
mini/ir-emit.h: * the cil_code is set to the cfg->ip address. 
mini/ir-emit.h:        MONO_INST_NEW ((cfg), (dest), cfg->compile_aot ? OP_GOT_ENTRY : OP_PCONST); \
mini/ir-emit.h:		if (cfg->compile_aot) {					\
mini/ir-emit.h:        MONO_INST_NEW ((cfg), (dest), cfg->compile_aot ? OP_AOTCONST : OP_PCONST); \
mini/ir-emit.h:#define NEW_VTABLECONST(cfg,dest,vtable) NEW_AOTCONST ((cfg), (dest), MONO_PATCH_INFO_VTABLE, cfg->compile_aot ? (gpointer)((vtable)->klass) : (vtable))
mini/ir-emit.h:		if (cfg->compile_aot) { \
mini/ir-emit.h:		if (cfg->compile_aot) {											\
mini/ir-emit.h:		if ((cfg->opt & MONO_OPT_SHARED) || cfg->compile_aot) {				 \
mini/ir-emit.h:	use->sreg1 = cfg->gsharedvt_info_var->dreg;
mini/ir-emit.h:	MONO_ADD_INS (cfg->cbb, use);
mini/ir-emit.h:	use->sreg1 = cfg->gsharedvt_locals_var->dreg;
mini/ir-emit.h:	MONO_ADD_INS (cfg->cbb, use);
mini/ir-emit.h:			  if (G_UNLIKELY (cfg->gsharedvt) && mini_is_gsharedvt_variable_type ((var)->inst_vtype)) { handle_gsharedvt_ldaddr ((cfg)); } \
mini/ir-emit.h:#define NEW_TEMPLOADA(cfg,dest,num) NEW_VARLOADA ((cfg), (dest), cfg->varinfo [(num)], cfg->varinfo [(num)]->inst_vtype)
mini/ir-emit.h:#define NEW_ARGLOAD(cfg,dest,num) NEW_VARLOAD ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)])
mini/ir-emit.h:#define NEW_LOCLOAD(cfg,dest,num) NEW_VARLOAD ((cfg), (dest), cfg->locals [(num)], header->locals [(num)])
mini/ir-emit.h:#define NEW_ARGSTORE(cfg,dest,num,inst) NEW_VARSTORE ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)], (inst))
mini/ir-emit.h:	    (dest)->klass = cfg->ret->klass;	\
mini/ir-emit.h:	    (dest)->sreg1 = cfg->vret_addr->dreg;   \
mini/ir-emit.h:	MONO_INST_NEW ((cfg), (dest), cfg->gen_sdb_seq_points ? OP_SEQ_POINT : OP_IL_SEQ_POINT); \
mini/ir-emit.h:#define EMIT_NEW_VTABLECONST(cfg,dest,vtable) do { NEW_AOTCONST ((cfg), (dest), MONO_PATCH_INFO_VTABLE, cfg->compile_aot ? (gpointer)((vtable)->klass) : (vtable)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
mini/ir-emit.h:			EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)]);	\
mini/ir-emit.h:			EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->locals [(num)], header->locals [(num)]);	\
mini/ir-emit.h:			EMIT_NEW_VARSTORE_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)], (inst));	\
mini/ir-emit.h:        MONO_INST_NEW ((cfg), (inst), cfg->compile_aot ? OP_AOTCONST : OP_PCONST); \
mini/ir-emit.h:	    MONO_ADD_INS (cfg->cbb, inst); \
mini/ir-emit.h:	    MONO_ADD_INS (cfg->cbb, inst); \
mini/ir-emit.h:	    MONO_ADD_INS (cfg->cbb, inst); \
mini/ir-emit.h:	    MONO_ADD_INS (cfg->cbb, inst); \
mini/ir-emit.h:	(bblock)->block_num = cfg->num_bblocks++; \
mini/ir-emit.h:			cfg->cil_offset_to_bb [(b)->cil_code - cfg->cil_start] = (b);	\
mini/ir-emit.h:		(b)->real_offset = cfg->real_offset;	\
mini/ir-emit.h:		    ins->inst_many_bb = mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);	\
mini/ir-emit.h:            if (g_getenv ("COUNT2") && ccount == atoi (g_getenv ("COUNT2")) - 1) { printf ("HIT: %d\n", cfg->cbb->block_num); } \
mini/ir-emit.h:                 cfg->cbb->extended = TRUE; \
mini/ir-emit.h:		    ins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);	\
mini/ir-emit.h:            if (!cfg->enable_extended_bblocks) { \
mini/ir-emit.h:				cfg->cbb->extended = TRUE; \
mini/ir-emit.h:		ins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);	\
mini/ir-emit.h:        if (cfg->cbb->last_ins && MONO_IS_COND_BRANCH_OP (cfg->cbb->last_ins) && !cfg->cbb->last_ins->inst_false_bb) { \
mini/ir-emit.h:            cfg->cbb->last_ins->inst_false_bb = (bblock); \
mini/ir-emit.h:        } else if (! (cfg->cbb->last_ins && ((cfg->cbb->last_ins->opcode == OP_BR) || (cfg->cbb->last_ins->opcode == OP_BR_REG) || MONO_IS_COND_BRANCH_OP (cfg->cbb->last_ins)))) \
mini/ir-emit.h:		if (cfg->explicit_null_checks) {							  \
mini/ir-emit.h:		cfg->flags |= MONO_CFG_HAS_CHECK_THIS;	 \
mini/ir-emit.h:		if (cfg->explicit_null_checks) {		 \
mini/ir-emit.h:	    MONO_ADD_INS (cfg->cbb, inst); \
mini/ir-emit.h:		if (!(cfg->opt & MONO_OPT_UNSAFE)) {							\
mini/ir-emit.h:		if (!(cfg->opt & MONO_OPT_ABCREM)) {							\
mini/linear-scan.c:	if (!cfg->disable_reuse_registers && vars && (((MonoMethodVar*)vars->data)->interval != NULL)) {
mini/linear-scan.c:	printf ("Linears scan for %s\n", mono_method_full_name (cfg->method, TRUE));
mini/linear-scan.c:		if (!cfg->disable_reuse_registers) {
mini/linear-scan.c:			if ((gains [vmv->reg] > mono_arch_regalloc_cost (cfg, vmv)) && (cfg->varinfo [vmv->idx]->opcode != OP_REGVAR)) {
mini/linear-scan.c:				if (cfg->verbose_level > 2) {
mini/linear-scan.c:					printf ("ALLOCATED R%d(%d) TO HREG %d COST %d\n", cfg->varinfo [vmv->idx]->dreg, vmv->idx, vmv->reg, vmv->spill_costs);
mini/linear-scan.c:				cfg->varinfo [vmv->idx]->opcode = OP_REGVAR;
mini/linear-scan.c:				cfg->varinfo [vmv->idx]->dreg = vmv->reg;
mini/linear-scan.c:				if (cfg->verbose_level > 2)
mini/linear-scan.c:			if (cfg->verbose_level > 2)
mini/linear-scan.c:	cfg->stat_n_regvars = n_regvars;
mini/linear-scan.c:	if (cfg->verbose_level > 2)
mini/linear-scan.c:	MonoInst *ins = cfg->varinfo [vmv->idx];
mini/linear-scan.c:		LSCAN_DEBUG (printf ("VAR R%d %08x %08x C%d\n", cfg->varinfo [vmv->idx]->dreg, vmv->range.first_use.abs_pos, 
mini/linear-scan.c:	LSCAN_DEBUG (printf ("Linear Scan 2 for %s:\n", mono_method_full_name (cfg->method, TRUE)));
mini/linear-scan.c:		LSCAN_DEBUG (printf ("Processing R%d: ", cfg->varinfo [current->idx]->dreg));
mini/linear-scan.c:					LSCAN_DEBUG (printf ("Interval R%d has expired\n", cfg->varinfo [v->idx]->dreg));
mini/linear-scan.c:					LSCAN_DEBUG (printf ("Interval R%d became inactive\n", cfg->varinfo [v->idx]->dreg));
mini/linear-scan.c:					LSCAN_DEBUG (printf ("\tInterval R%d has expired\n", cfg->varinfo [v->idx]->dreg));
mini/linear-scan.c:					LSCAN_DEBUG (printf ("\tInterval R%d became active\n", cfg->varinfo [v->idx]->dreg));
mini/linear-scan.c:			LSCAN_DEBUG (printf ("\tAssigned hreg %d to R%d\n", reg, cfg->varinfo [current->idx]->dreg));
mini/linear-scan.c:					LSCAN_DEBUG (printf ("\tSpilled R%d\n", cfg->varinfo [vmv->idx]->dreg));
mini/linear-scan.c:			gains [i] -= cfg->method->save_lmf ? 1 : 2;
mini/linear-scan.c:			if ((gains [reg_index] > regalloc_cost (cfg, vmv)) && (cfg->varinfo [vmv->idx]->opcode != OP_REGVAR)) {
mini/linear-scan.c:				if (cfg->verbose_level > 2)
mini/linear-scan.c:					printf ("REGVAR R%d G%d C%d %s\n", cfg->varinfo [vmv->idx]->dreg, gains [reg_index], regalloc_cost (cfg, vmv), mono_arch_regname (vmv->reg));
mini/linear-scan.c:				cfg->varinfo [vmv->idx]->opcode = OP_REGVAR;
mini/linear-scan.c:				cfg->varinfo [vmv->idx]->dreg = vmv->reg;
mini/linear-scan.c:				if (cfg->verbose_level > 2)
mini/linear-scan.c:					printf ("COSTLY: %s R%d G%d C%d %s\n", mono_method_full_name (cfg->method, TRUE), cfg->varinfo [vmv->idx]->dreg, gains [reg_index], regalloc_cost (cfg, vmv), mono_arch_regname (vmv->reg));
mini/linear-scan.c:	cfg->stat_n_regvars = n_regvars;
mini/liveness.c:			cfg->varinfo [vi->idx]->flags |= MONO_INST_VOLATILE;
mini/liveness.c:				cfg->varinfo [vi->idx]->flags |= MONO_INST_VOLATILE;
mini/liveness.c:	MonoMethodHeader *header = cfg->header;
mini/liveness.c:	outer_try = (gboolean *)mono_mempool_alloc0 (cfg->mempool, sizeof (gboolean) * header->num_clauses);
mini/liveness.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/liveness.c:		if (cfg->verbose_level > 2)
mini/liveness.c:	MonoMethodVar *vars = cfg->vars;
mini/liveness.c:		if (cfg->verbose_level > 1) {
mini/liveness.c:			if (cfg->verbose_level > 1)
mini/liveness.c:				if (cfg->verbose_level > 1)
mini/liveness.c:				if (cfg->verbose_level > 1)
mini/liveness.c:	int i, j, max_vars = cfg->num_varinfo;
mini/liveness.c:	if (cfg->verbose_level > 1)
mini/liveness.c:	g_assert (!(cfg->comp_done & MONO_COMP_LIVENESS));
mini/liveness.c:	cfg->comp_done |= MONO_COMP_LIVENESS;
mini/liveness.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/liveness.c:		bb->gen_set = mono_bitset_mp_new (cfg->mempool, bitsize, max_vars);
mini/liveness.c:		bb->kill_set = mono_bitset_mp_new (cfg->mempool, bitsize, max_vars);
mini/liveness.c:		if (cfg->verbose_level > 1) {
mini/liveness.c:		if (cfg->verbose_level > 1) {
mini/liveness.c:	in_worklist = g_new0 (gboolean, cfg->num_bblocks + 1);
mini/liveness.c:	worklist = g_new (MonoBasicBlock *, cfg->num_bblocks + 1);
mini/liveness.c:	for (i = 0; i < cfg->num_bblocks; i ++) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/liveness.c:		bb->live_out_set = mono_bitset_mp_new (cfg->mempool, bitsize, max_vars);
mini/liveness.c:	if (cfg->verbose_level > 1)
mini/liveness.c:		if (cfg->verbose_level > 1) {
mini/liveness.c:				out_bb->live_in_set = mono_bitset_mp_new_noinit (cfg->mempool, bitsize, max_vars);
mini/liveness.c:				bb->live_in_set = mono_bitset_mp_new_noinit (cfg->mempool, bitsize, max_vars);
mini/liveness.c:				 * cfg->bblocks array...
mini/liveness.c:					if (cfg->verbose_level > 1)
mini/liveness.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/liveness.c:	if (cfg->verbose_level > 1)
mini/liveness.c:		printf ("IT: %d %d.\n", cfg->num_bblocks, out_iter);
mini/liveness.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/liveness.c:			bb->live_in_set = mono_bitset_mp_new (cfg->mempool, bitsize, max_vars);
mini/liveness.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/liveness.c:		MonoMethodVar *vars = cfg->vars;
mini/liveness.c:		if (cfg->varinfo [vi->idx]->opcode == OP_ARG) {
mini/liveness.c:			if (vi->range.last_use.abs_pos == 0 && !(cfg->varinfo [vi->idx]->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT))) {
mini/liveness.c:				 if (!cfg->disable_deadce_vars && !(cfg->gshared && mono_method_signature (cfg->method)->hasthis && cfg->varinfo [vi->idx] == cfg->args [0]))
mini/liveness.c:					 cfg->varinfo [vi->idx]->flags |= MONO_INST_IS_DEAD;
mini/liveness.c:	if (cfg->verbose_level > 1) {
mini/liveness.c:		for (i = cfg->num_bblocks - 1; i >= 0; i--) {
mini/liveness.c:			MonoBasicBlock *bb = cfg->bblocks [i];
mini/liveness.c:	if (!cfg->disable_initlocals_opt)
mini/liveness.c:	if (cfg->compile_aot)
mini/liveness.c:	used = mono_bitset_new (cfg->next_vreg + 1, 0);
mini/liveness.c:	initlocals_bb = cfg->bb_entry->next_bb;
mini/liveness.c:			if (var && !mono_bitset_test_fast (used, ins->dreg) && !mono_bitset_test_fast (initlocals_bb->live_out_set, var->inst_c0) && (var != cfg->ret) && !(var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT))) {
mini/liveness.c:				if (cfg->disable_initlocals_opt_refs && var->type == STACK_OBJ)
mini/liveness.c:		new_range = (MonoLiveRange2 *)mono_mempool_alloc (cfg->mempool, sizeof (MonoLiveRange2));
mini/liveness.c:	*i1 = (MonoLiveInterval *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoLiveInterval));
mini/liveness.c:	*i2 = (MonoLiveInterval *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoLiveInterval));
mini/liveness.c:#define LIVENESS_DEBUG(a) do { if (cfg->verbose_level > 1) do { a; } while (0); } while (0)
mini/liveness.c:				if (!cfg->disable_deadce_vars && (var != cfg->ret) && !(var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) && ((ins->opcode == OP_ICONST) || (ins->opcode == OP_I8CONST) || (ins->opcode == OP_R8CONST)) && !(var->flags & MONO_INST_VOLATILE)) {
mini/liveness.c:	if (cfg->num_bblocks >= (1 << (32 - BB_ID_SHIFT - 1)))
mini/liveness.c:	for (bnum = cfg->num_bblocks - 1; bnum >= 0; --bnum) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [bnum];
mini/liveness.c:	LIVENESS_DEBUG (printf ("LIVENESS 2 %s\n", mono_method_full_name (cfg->method, TRUE)));
mini/liveness.c:	if (strstr (cfg->method->name, "test_") != cfg->method->name)
mini/liveness.c:	max_vars = cfg->num_varinfo;
mini/liveness.c:	reverse = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * reverse_len);
mini/liveness.c:		vi->interval = (MonoLiveInterval *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoLiveInterval));
mini/liveness.c:	for (bnum = cfg->num_bblocks - 1; bnum >= 0; --bnum) {
mini/liveness.c:		MonoBasicBlock *bb = cfg->bblocks [bnum];
mini/liveness.c:		if (bnum < cfg->num_bblocks - 1)
mini/liveness.c:			block_to = (cfg->bblocks [bnum + 1]->dfn << BB_ID_SHIFT) + 1;
mini/liveness.c:					LIVENESS_DEBUG (printf ("Var R%d live at exit, set last_use to %x\n", cfg->varinfo [k]->dreg, block_to));
mini/liveness.c:		if (cfg->ret)
mini/liveness.c:			last_use [cfg->ret->inst_c0] = block_to;
mini/liveness.c:				MonoInst **new_reverse = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * new_reverse_len);
mini/liveness.c:				LIVENESS_DEBUG (printf ("Var R%d live at enter, add range to R%d: [%x, %x)\n", cfg->varinfo [idx]->dreg, cfg->varinfo [idx]->dreg, block_from, last_use [idx]));
mini/liveness.c:		if (cfg->varinfo [vi->idx]->opcode == OP_ARG)
mini/liveness.c:		LIVENESS_DEBUG (printf ("LIVENESS R%d: ", cfg->varinfo [idx]->dreg));
mini/liveness.c:		last->param_slots = g_slist_prepend_mempool (cfg->mempool, last->param_slots, ins);
mini/liveness.c:		GCCallSite *callsite = (GCCallSite *)mono_mempool_alloc0 (cfg->mempool, sizeof (GCCallSite));
mini/liveness.c:		callsite->liveness = (guint8 *)mono_mempool_alloc0 (cfg->mempool, ALIGN_TO (cfg->num_varinfo, 8) / 8);
mini/liveness.c:		for (i = 0; i < cfg->num_varinfo; ++i) {
mini/liveness.c:		*callsites = g_slist_prepend_mempool (cfg->mempool, *callsites, callsite);
mini/liveness.c:	max_vars = cfg->num_varinfo;
mini/liveness.c:	vreg_to_varinfo = g_new0 (MonoMethodVar*, cfg->next_vreg);
mini/liveness.c:	reverse = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * reverse_len);
mini/liveness.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/liveness.c:				if ((bits_out & 1) && cfg->varinfo [k]->flags & MONO_INST_GC_TRACK) {
mini/liveness.c:					int vreg = get_vreg_from_var (cfg, cfg->varinfo [k]);
mini/liveness.c:				MonoInst **new_reverse = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * new_reverse_len);
mini/lldb.c:	udata.code = cfg->native_code;
mini/lldb.c:	if (cfg->method->dynamic) {
mini/lldb.c:		mono_code_manager_foreach (cfg->dynamic_info->code_mp, find_code_region, &udata);
mini/lldb.c:		g_hash_table_insert (dyn_codegen_regions, cfg->method, GINT_TO_POINTER (region_id));
mini/lldb.c:		mono_domain_code_foreach (cfg->domain, find_code_region, &udata);
mini/lldb.c:	entry->code = (gsize)cfg->native_code;
mini/lldb.c:	entry->code_size = cfg->code_size;
mini/lldb.c:	emit_unwind_info (cfg->unwind_ops, buf);
mini/lldb.c:	char *s = mono_method_full_name (cfg->method, TRUE);
mini/lldb.c:	minfo = mono_debug_lookup_method (cfg->method);
mini/lldb.c:	MonoSeqPointInfo *seq_points = cfg->seq_point_info;
mini/lldb.c:			//printf ("%s %x %d %d\n", cfg->method->name, locs [i].native_offset, sp->il_offset, sp->line);
mini/local-propagation.c:			if (cfg->backend->disable_div_with_mul)
mini/local-propagation.c:			if (cfg->backend->disable_div_with_mul)
mini/local-propagation.c:	int initial_max_vregs = cfg->next_vreg;
mini/local-propagation.c:	max = cfg->next_vreg;
mini/local-propagation.c:	defs = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * cfg->next_vreg);
mini/local-propagation.c:	def_index = (gint32 *)mono_mempool_alloc (cfg->mempool, sizeof (guint32) * cfg->next_vreg);
mini/local-propagation.c:	cfg->cbb = bb_opt = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoBasicBlock));
mini/local-propagation.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/local-propagation.c:						if (cfg->verbose_level > 2) printf ("CCOPY: R%d -> R%d\n", sreg, vreg);
mini/local-propagation.c:					if (cfg->verbose_level > 2) printf ("CCOPY/2: R%d -> R%d\n", sreg, vreg);
mini/local-propagation.c:					 * was defined. cfg->frame_reg is assumed to remain constant.
mini/local-propagation.c:					if ((def->sreg1 == cfg->frame_reg) || ((mono_inst_next (def, filter) == ins) && (def->dreg != def->sreg1))) {
mini/local-propagation.c:			g_assert (cfg->cbb == bb_opt);
mini/local-propagation.c:			if (mono_strength_reduction_ins (cfg, ins, &spec) && max < cfg->next_vreg) {
mini/local-propagation.c:				guint32 additional_vregs = cfg->next_vreg - initial_max_vregs;
mini/local-propagation.c:				defs = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * max);
mini/local-propagation.c:				def_index = (gint32 *)mono_mempool_alloc (cfg->mempool, sizeof (guint32) * max);
mini/local-propagation.c:			if (cfg->cbb->code || (cfg->cbb != bb_opt)) {
mini/local-propagation.c:				mono_replace_ins (cfg, bb, ins, &ins->prev, bb_opt, cfg->cbb);
mini/local-propagation.c:				cfg->cbb = bb_opt;
mini/local-propagation.c:				if (def && (def->opcode == OP_ADD_IMM) && (def->sreg1 == cfg->frame_reg) && (MONO_IS_STORE_MEMBASE (ins))) {
mini/local-propagation.c:					/* cfg->frame_reg is assumed to remain constant */
mini/local-propagation.c:	used = mono_bitset_mp_new_noinit (cfg->mempool, cfg->next_vreg + 1);
mini/local-propagation.c:	defined = mono_bitset_mp_new_noinit (cfg->mempool, cfg->next_vreg + 1);
mini/local-propagation.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/local-propagation.c:					if (cfg->verbose_level > 2) {
mini/method-to-ir.c:	if ((cfg->method != cfg->current_method) && (cfg->current_method->wrapper_type == MONO_WRAPPER_NONE)) { \
mini/method-to-ir.c:		if (cfg->exception_type != MONO_EXCEPTION_NONE)	\
mini/method-to-ir.c:		if (cfg->gshared) {									\
mini/method-to-ir.c:	if (cfg->gsharedvt) {												\
mini/method-to-ir.c:		mono_error_set_out_of_memory (&cfg->error, "");					\
mini/method-to-ir.c:		cfg->exception_ptr = klass; \
mini/method-to-ir.c:		if (!mono_error_ok (&cfg->error)) { \
mini/method-to-ir.c:#define MONO_CHECK_THIS(ins) (mono_method_signature (cfg->method)->hasthis && ((ins)->opcode == OP_MOVE) && ((ins)->sreg1 == cfg->args [0]->dreg))
mini/method-to-ir.c:		return cfg->r4fp ? OP_RMOVE : OP_FMOVE;
mini/method-to-ir.c:		g_assert (cfg->gshared);
mini/method-to-ir.c:	mono_error_set_generic_error (&cfg->error, "System", "FieldAccessException", "Field `%s' is inaccessible from method `%s'\n", field_fname, method_fname);
mini/method-to-ir.c:	if (cfg->verbose_level >= 2)
mini/method-to-ir.c:	if (cfg->verbose_level > 2)											\
mini/method-to-ir.c:		printf ("sharing failed for method %s.%s.%s/%d opcode %s line %d\n", cfg->current_method->klass->name_space, cfg->current_method->klass->name, cfg->current_method->name, cfg->current_method->signature->param_count, mono_opcode_name ((opcode)), line);
mini/method-to-ir.c:	cfg->exception_message = g_strdup_printf ("gsharedvt failed for method %s.%s.%s/%d opcode %s %s:%d", cfg->current_method->klass->name_space, cfg->current_method->klass->name, cfg->current_method->name, cfg->current_method->signature->param_count, mono_opcode_name ((opcode)), file, line);
mini/method-to-ir.c:	if (cfg->verbose_level >= 2)
mini/method-to-ir.c:		printf ("%s\n", cfg->exception_message);
mini/method-to-ir.c:	if (cfg->gsharedvt) { \
mini/method-to-ir.c:		if (cfg->verbose_level > 2)									\
mini/method-to-ir.c:		(tblock) = cfg->cil_offset_to_bb [(ip) - cfg->cil_start]; \
mini/method-to-ir.c:	if (cfg->r4fp &&
mini/method-to-ir.c:		ins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);	\
mini/method-to-ir.c:		link_bblock (cfg, cfg->cbb, tblock);	\
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, (next_block));	\
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);	\
mini/method-to-ir.c:        MONO_ADD_INS (cfg->cbb, cmp); \
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);	\
mini/method-to-ir.c:			printf ("edge from IL%04x to IL_%04x\n", from->cil_code - cfg->cil_code, to->cil_code - cfg->cil_code);
mini/method-to-ir.c:			printf ("edge from IL%04x to exit\n", from->cil_code - cfg->cil_code);
mini/method-to-ir.c:			printf ("edge from entry to IL_%04x\n", to->cil_code - cfg->cil_code);
mini/method-to-ir.c:		newa = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * (from->out_count + 1));
mini/method-to-ir.c:		newa = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (gpointer) * (to->in_count + 1));
mini/method-to-ir.c:	MonoMethodHeader *header = cfg->header;
mini/method-to-ir.c:	MonoMethodHeader *header = cfg->header;
mini/method-to-ir.c:	MonoMethodHeader *header = cfg->header;
mini/method-to-ir.c:	var = (MonoInst *)g_hash_table_lookup (cfg->spvars, GINT_TO_POINTER (region));
mini/method-to-ir.c:	g_hash_table_insert (cfg->spvars, GINT_TO_POINTER (region), var);
mini/method-to-ir.c:	return (MonoInst *)g_hash_table_lookup (cfg->exvars, GINT_TO_POINTER (offset));
mini/method-to-ir.c:	var = (MonoInst *)g_hash_table_lookup (cfg->exvars, GINT_TO_POINTER (offset));
mini/method-to-ir.c:	g_hash_table_insert (cfg->exvars, GINT_TO_POINTER (offset), var);
mini/method-to-ir.c:		inst->type = cfg->r4_stack_type;
mini/method-to-ir.c:		g_assert (cfg->gshared);
mini/method-to-ir.c:			g_assert (cfg->gsharedvt);
mini/method-to-ir.c:		ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:		ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:	if (!cfg->domainvar)
mini/method-to-ir.c:		cfg->domainvar = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:	return cfg->domainvar;
mini/method-to-ir.c:	if (!cfg->compile_aot || !cfg->backend->need_got_var)
mini/method-to-ir.c:	if (!cfg->got_var) {
mini/method-to-ir.c:		cfg->got_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:	return cfg->got_var;
mini/method-to-ir.c:	g_assert (cfg->gshared);
mini/method-to-ir.c:	g_assert (will_get_mono_vtable_var (cfg->method));
mini/method-to-ir.c:	if (!cfg->rgctx_var) {
mini/method-to-ir.c:		cfg->rgctx_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:		cfg->rgctx_var->flags |= MONO_INST_VOLATILE;
mini/method-to-ir.c:	return cfg->rgctx_var;
mini/method-to-ir.c:		return cfg->r4_stack_type;
mini/method-to-ir.c:	if (slot >= cfg->header->max_stack)
mini/method-to-ir.c:		if ((vnum = cfg->intvars [pos]))
mini/method-to-ir.c:			return cfg->varinfo [vnum];
mini/method-to-ir.c:		cfg->intvars [pos] = res->inst_c0;
mini/method-to-ir.c:	if (cfg->compile_aot && !cfg->generic_context && (mono_metadata_token_table (token) > 0)) {
mini/method-to-ir.c:		MonoJumpInfoToken *jump_info_token = (MonoJumpInfoToken *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoToken));
mini/method-to-ir.c:		g_hash_table_insert (cfg->token_info_hash, key, jump_info_token);
mini/method-to-ir.c: * If the stack merge fails at a join point, cfg->unverifiable is set.
mini/method-to-ir.c:	MonoBasicBlock *bb = cfg->cbb;
mini/method-to-ir.c:	if (cfg->verbose_level > 3)
mini/method-to-ir.c:			bb->out_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * count);
mini/method-to-ir.c:				if (cfg->inlined_method)
mini/method-to-ir.c:				cfg->unverifiable = TRUE;
mini/method-to-ir.c:	cfg->cbb = bb;
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:					if (cfg->verbose_level > 3)
mini/method-to-ir.c:	if (cfg->compile_aot) {
mini/method-to-ir.c:		target = mono_resolve_patch_target (NULL, cfg->domain, NULL, &ji, FALSE, &error);
mini/method-to-ir.c:	if (!cfg->backend->no_unaligned_access && SIZEOF_REGISTER == 8) {
mini/method-to-ir.c:	if (!cfg->backend->no_unaligned_access && SIZEOF_REGISTER == 8) {
mini/method-to-ir.c:	if (cfg->compile_aot)
mini/method-to-ir.c:	if (cfg->compile_aot)
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, fast_tls);
mini/method-to-ir.c:	if (cfg->compile_aot) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, fast_tls);
mini/method-to-ir.c:	if (cfg->compile_aot) {
mini/method-to-ir.c:	if (!cfg->lmf_ir)
mini/method-to-ir.c:	if (cfg->lmf_ir_mono_lmf) {
mini/method-to-ir.c:		EMIT_NEW_VARLOADA (cfg, lmf_vara_ins, cfg->lmf_var, NULL);
mini/method-to-ir.c:		if (!cfg->lmf_addr_var)
mini/method-to-ir.c:			cfg->lmf_addr_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:		lmf_ins->dreg = cfg->lmf_addr_var->dreg;
mini/method-to-ir.c:		EMIT_NEW_VARLOADA (cfg, ins, cfg->lmf_var, NULL);
mini/method-to-ir.c:		EMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, prev_lmf_reg, cfg->lmf_addr_var->dreg, 0);
mini/method-to-ir.c:		EMIT_NEW_STORE_MEMBASE (cfg, ins, OP_STORE_MEMBASE_REG, cfg->lmf_addr_var->dreg, 0, lmf_reg);
mini/method-to-ir.c:	if (!cfg->lmf_ir)
mini/method-to-ir.c: 	EMIT_NEW_VARLOADA (cfg, ins, cfg->lmf_var, NULL);
mini/method-to-ir.c:	if (cfg->lmf_ir_mono_lmf) {
mini/method-to-ir.c:		if (!cfg->lmf_addr_var)
mini/method-to-ir.c:			cfg->lmf_addr_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:		lmf_addr_reg = cfg->lmf_addr_var->dreg;
mini/method-to-ir.c:	if (cfg->method != cfg->current_method)
mini/method-to-ir.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE) {
mini/method-to-ir.c:		EMIT_NEW_METHODCONST (cfg, iargs [0], cfg->method);
mini/method-to-ir.c:		if (cfg->r4fp)
mini/method-to-ir.c:		if (arg->type != cfg->r4_stack_type)
mini/method-to-ir.c:		g_assert (cfg->gshared);
mini/method-to-ir.c:			if (args [i]->type != cfg->r4_stack_type)
mini/method-to-ir.c:	if (cfg->gshared)
mini/method-to-ir.c:	if (cfg->gshared)
mini/method-to-ir.c:			if (cfg->gsharedvt && mini_is_gsharedvt_signature (mono_method_signature (cmethod)))
mini/method-to-ir.c:	if (cfg->llvm_only)
mini/method-to-ir.c:			call->vret_var = cfg->vret_addr;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, loada);
mini/method-to-ir.c:	cfg->param_area = MAX (cfg->param_area, call->stack_usage);
mini/method-to-ir.c:	cfg->flags |= MONO_CFG_HAS_CALLS;
mini/method-to-ir.c:	cfg->uses_rgctx_reg = TRUE;
mini/method-to-ir.c:	if (cfg->check_pinvoke_callconv && cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
mini/method-to-ir.c:		WrapperInfo *info = mono_marshal_get_wrapper_info (cfg->method);
mini/method-to-ir.c:		if (!cfg->stack_inbalance_var)
mini/method-to-ir.c:			cfg->stack_inbalance_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:		ins->dreg = cfg->stack_inbalance_var->dreg;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, (MonoInst*)call);
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		ins->sreg1 = cfg->stack_inbalance_var->dreg;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		MONO_EMIT_NEW_BIALU (cfg, OP_COMPARE, -1, cfg->stack_inbalance_var->dreg, sp_reg);
mini/method-to-ir.c:	if (cfg->llvm_only && (mono_class_is_interface (method->klass)))
mini/method-to-ir.c:		MonoMethodSignature *ctor_sig = mono_metadata_signature_dup_mempool (cfg->mempool, sig);
mini/method-to-ir.c:		g_assert (cfg->gshared);
mini/method-to-ir.c:	if (cfg->llvm_only && !call_target && virtual_ && (method->flags & METHOD_ATTRIBUTE_VIRTUAL))
mini/method-to-ir.c:		if (!cfg->llvm_only && (method->klass->parent == mono_defaults.multicastdelegate_class) && !strcmp (method->name, "Invoke")) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, (MonoInst*)call);
mini/method-to-ir.c:		if ((!cfg->compile_aot || enable_for_aot) && 
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, (MonoInst*)call);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, (MonoInst*)call);
mini/method-to-ir.c:	MonoJumpInfo *ji = mono_patch_info_new (cfg->mempool, 0, patch_type, data);
mini/method-to-ir.c:	if (cfg->abs_patches == NULL)
mini/method-to-ir.c:		cfg->abs_patches = g_hash_table_new (NULL, NULL);
mini/method-to-ir.c:	g_hash_table_insert (cfg->abs_patches, ji, ji);
mini/method-to-ir.c:		args = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst*) * (fsig->param_count + 2));
mini/method-to-ir.c:	g_assert (cfg->llvm_only);
mini/method-to-ir.c:	if (cfg->compile_llvm && !cfg->llvm_only)
mini/method-to-ir.c:	if (cfg->gen_sdb_seq_points || cfg->disable_direct_icalls)
mini/method-to-ir.c:	if (!cfg->gen_write_barriers)
mini/method-to-ir.c:	if (cfg->backend->have_card_table_wb && !cfg->compile_aot && card_table && nursery_shift_bits > 0 && !COMPILE_LLVM (cfg)) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, wbarrier);
mini/method-to-ir.c:	} else if (card_table && !cfg->compile_aot && !mono_gc_card_table_nursery_check ()) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, load_inst);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, iargs [0]);
mini/method-to-ir.c:	if (cfg->gshared)
mini/method-to-ir.c:	if (cfg->gen_write_barriers && (klass->has_references || size_ins) && !native) {
mini/method-to-ir.c:		if (!((dest->opcode == OP_ADD_IMM && dest->sreg1 == cfg->frame_reg) ||
mini/method-to-ir.c:			if (!size_ins && (cfg->opt & MONO_OPT_INTRINS) && mono_emit_wb_aware_memcpy (cfg, klass, iargs, n, align)) {
mini/method-to-ir.c:				if (!cfg->compile_aot)
mini/method-to-ir.c:	if (!size_ins && (cfg->opt & MONO_OPT_INTRINS) && n <= sizeof (gpointer) * 8) {
mini/method-to-ir.c:	g_assert (cfg->gshared);
mini/method-to-ir.c:		EMIT_NEW_VARLOAD (cfg, this_ins, cfg->this_arg, &mono_defaults.object_class->byval_arg);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (cfg->llvm_only)
mini/method-to-ir.c:	MonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_CLASS, klass, rgctx_type);
mini/method-to-ir.c:	MonoInst *rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	MonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_SIGNATURE, sig, rgctx_type);
mini/method-to-ir.c:	MonoInst *rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	call_info = (MonoJumpInfoGSharedVtCall *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoGSharedVtCall));
mini/method-to-ir.c:	entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_GSHAREDVT_CALL, call_info, rgctx_type);
mini/method-to-ir.c:	rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	info = (MonoJumpInfoVirtMethod *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfoVirtMethod));
mini/method-to-ir.c:	entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_VIRT_METHOD, info, rgctx_type);
mini/method-to-ir.c:	rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_GSHAREDVT_METHOD, info, MONO_RGCTX_INFO_METHOD_GSHAREDVT_INFO);
mini/method-to-ir.c:	rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:		MonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_METHODCONST, cmethod, rgctx_type);
mini/method-to-ir.c:		MonoInst *rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	MonoJumpInfoRgctxEntry *entry = mono_patch_info_rgctx_entry_new (cfg->mempool, cfg->method, context_used & MONO_GENERIC_CONTEXT_USED_METHOD, MONO_PATCH_INFO_FIELD, field, rgctx_type);
mini/method-to-ir.c:	MonoInst *rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:	MonoGSharedVtMethodInfo *info = cfg->gsharedvt_info;
mini/method-to-ir.c:		new_entries = (MonoRuntimeGenericContextInfoTemplate *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRuntimeGenericContextInfoTemplate) * new_count_entries);
mini/method-to-ir.c:	EMIT_NEW_LOAD_MEMBASE (cfg, ins, OP_LOAD_MEMBASE, dreg, cfg->gsharedvt_info_var->dreg, MONO_STRUCT_OFFSET (MonoGSharedVtMethodRuntimeInfo, entries) + (idx * sizeof (gpointer)));
mini/method-to-ir.c:		MonoVTable *vtable = mono_class_vtable (cfg->domain, klass);
mini/method-to-ir.c:	if (!COMPILE_LLVM (cfg) && cfg->backend->have_op_generic_class_init) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (cfg->gen_seq_points && cfg->method == method) {
mini/method-to-ir.c:		NEW_SEQ_POINT (cfg, ins, ip - cfg->header->code, intr_loc);
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (cfg->opt & MONO_OPT_SHARED) {
mini/method-to-ir.c:		if (cfg->compile_aot) {
mini/method-to-ir.c:			if (!(vtable = mono_class_vtable (cfg->domain, array_class)))
mini/method-to-ir.c:			if (!(vtable = mono_class_vtable (cfg->domain, array_class)))
mini/method-to-ir.c:		if (cfg->llvm_only) {
mini/method-to-ir.c:			cfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, mono_method_signature (method));
mini/method-to-ir.c:			rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:			MonoVTable *vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, add);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, addr);
mini/method-to-ir.c:		unbox_sig = (MonoMethodSignature *)mono_mempool_alloc0 (cfg->mempool, MONO_SIZEOF_METHOD_SIGNATURE + (1 * sizeof (MonoType *)));
mini/method-to-ir.c:		if (cfg->llvm_only)
mini/method-to-ir.c:		if (cfg->opt & MONO_OPT_SHARED)
mini/method-to-ir.c:		if (cfg->opt & MONO_OPT_SHARED) {
mini/method-to-ir.c:		if (managed_alloc && !(cfg->opt & MONO_OPT_SHARED)) {
mini/method-to-ir.c:	if (cfg->opt & MONO_OPT_SHARED) {
mini/method-to-ir.c:	} else if (cfg->compile_aot && cfg->cbb->out_of_line && klass->type_token && klass->image == mono_defaults.corlib && !mono_class_is_ginst (klass)) {
mini/method-to-ir.c:		MonoVTable *vtable = mono_class_vtable (cfg->domain, klass);
mini/method-to-ir.c:			cfg->exception_ptr = klass;
mini/method-to-ir.c:			if (cfg->llvm_only && cfg->gsharedvt) {
mini/method-to-ir.c:				MonoInst *rgctx = emit_get_rgctx (cfg, cfg->method, context_used);
mini/method-to-ir.c:				MonoVTable *vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:			box_sig = (MonoMethodSignature *)mono_mempool_alloc0 (cfg->mempool, MONO_SIZEOF_METHOD_SIGNATURE + (1 * sizeof (MonoType *)));
mini/method-to-ir.c:			if (cfg->llvm_only)
mini/method-to-ir.c:	if (virtual_ && !cfg->llvm_only) {
mini/method-to-ir.c:		if (cfg->gen_write_barriers) {
mini/method-to-ir.c:	if (!method->dynamic && !(cfg->opt & MONO_OPT_SHARED)) {
mini/method-to-ir.c: 	if (cfg->llvm_only) {
mini/method-to-ir.c:	if (cfg->compile_aot) {
mini/method-to-ir.c:		del_tramp = (MonoDelegateClassMethodPair *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoDelegateClassMethodPair));
mini/method-to-ir.c:			trampoline = mono_create_delegate_virtual_trampoline (cfg->domain, klass, context_used ? NULL : method);
mini/method-to-ir.c:			trampoline = mono_create_delegate_trampoline_info (cfg->domain, klass, context_used ? NULL : method);
mini/method-to-ir.c:	cfg->flags |= MONO_CFG_HAS_VARARGS;
mini/method-to-ir.c:	cfg->exception_message = g_strdup ("array-new");
mini/method-to-ir.c:	cfg->disable_llvm = TRUE;
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, add);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (!cfg->got_var || cfg->got_var_allocated)
mini/method-to-ir.c:	getaddr->cil_code = cfg->header->code;
mini/method-to-ir.c:	getaddr->dreg = cfg->got_var->dreg;
mini/method-to-ir.c:	if (cfg->bb_entry->code) {
mini/method-to-ir.c:		getaddr->next = cfg->bb_entry->code;
mini/method-to-ir.c:		cfg->bb_entry->code = getaddr;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->bb_entry, getaddr);
mini/method-to-ir.c:	cfg->got_var_allocated = TRUE;
mini/method-to-ir.c:	NEW_DUMMY_USE (cfg, dummy_use, cfg->got_var);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->bb_exit, dummy_use);
mini/method-to-ir.c:	if (cfg->disable_inline)
mini/method-to-ir.c:	if (cfg->gsharedvt)
mini/method-to-ir.c:	if (cfg->inline_depth > 10)
mini/method-to-ir.c:	if (cfg->gshared && method->klass->has_cctor && mini_class_check_context_used (cfg, method->klass))
mini/method-to-ir.c:	if (!(cfg->opt & MONO_OPT_SHARED)) {
mini/method-to-ir.c:				vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:				if (!cfg->compile_aot) {
mini/method-to-ir.c:			if (cfg->run_cctors && method->klass->has_cctor) {
mini/method-to-ir.c:				vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:			vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:	if (g_list_find (cfg->dont_inline, method))
mini/method-to-ir.c:	if (!cfg->compile_aot) {
mini/method-to-ir.c:		if (cfg->method == method)
mini/method-to-ir.c:		g_assert (cfg->gshared);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (!cfg->backend->emulate_mul_div && rank == 2 && (cfg->opt & MONO_OPT_INTRINS) && !mini_is_gsharedvt_variable_klass (eclass)) {
mini/method-to-ir.c:	if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:			if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:	if (cfg->opt & MONO_OPT_SIMD) {
mini/method-to-ir.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		if (cfg->opt & MONO_OPT_CMOV) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			cfg->cbb->has_array_access = TRUE;
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_ARRAY_ACCESS;
mini/method-to-ir.c:		} else if (!cfg->backend->emulate_mul_div && strcmp (cmethod->name, "InternalGetHashCode") == 0 && fsig->param_count == 1 && !mono_gc_is_moving ()) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		if (strcmp (cmethod->name, "GetGenericValueImpl") == 0 && fsig->param_count + fsig->hasthis == 3 && !cfg->gsharedvt)
mini/method-to-ir.c:		else if (strcmp (cmethod->name, "SetGenericValueImpl") == 0 && fsig->param_count + fsig->hasthis == 3 && !cfg->gsharedvt)
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		if (!cfg->llvm_only && strcmp (cmethod->name, "Read") == 0 && fsig->param_count == 1 && (fsig->params [0]->type == MONO_TYPE_I8)) {
mini/method-to-ir.c:			if (!cfg->llvm_only && mono_arch_opcode_supported (OP_ATOMIC_LOAD_I8)) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, load_ins);
mini/method-to-ir.c:				cfg->has_atomic_add_i4 = TRUE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins_iconst);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->has_atomic_add_i4 = TRUE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins_iconst);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->has_atomic_add_i4 = TRUE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->has_atomic_exchange_i4 = TRUE;
mini/method-to-ir.c:				cfg->has_atomic_exchange_i4 = TRUE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, f2i);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, i2f);
mini/method-to-ir.c:			if (cfg->gen_write_barriers && is_ref)
mini/method-to-ir.c:				cfg->has_atomic_cas_i4 = TRUE;
mini/method-to-ir.c:				cfg->has_atomic_cas_i4 = TRUE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, f2i_new);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, f2i_cmp);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, i2f);
mini/method-to-ir.c:			if (cfg->gen_write_barriers && is_ref)
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, cmp);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ceq);
mini/method-to-ir.c:			cfg->has_atomic_cas_i4 = TRUE;
mini/method-to-ir.c:		if (!cfg->llvm_only && !strcmp (cmethod->name, "Read") && fsig->param_count == 1) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:					ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:		if (!cfg->llvm_only && !strcmp (cmethod->name, "Write") && fsig->param_count == 2) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				if (cfg->gen_write_barriers && is_ref)
mini/method-to-ir.c:			if (should_insert_brekpoint (cfg->method)) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		if (cfg->llvm_only && !strcmp (cmethod->name, "GetExecutingAssembly")) {
mini/method-to-ir.c:			EMIT_NEW_AOTCONST (cfg, assembly_ins, MONO_PATCH_INFO_IMAGE, cfg->method->klass->image);
mini/method-to-ir.c:		if (cfg->llvm_only && !strcmp (cmethod->name, "GetCurrentMethod")) {
mini/method-to-ir.c:			MonoMethod *declaring = cfg->method;
mini/method-to-ir.c:				declaring = ((MonoMethodInflated*)cfg->method)->declaring;
mini/method-to-ir.c:			cfg->no_inline = TRUE;
mini/method-to-ir.c:			if (cfg->method != cfg->current_method)
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		if ((cfg->backend->have_objc_get_selector || cfg->compile_llvm) &&
mini/method-to-ir.c:		    cfg->compile_aot) {
mini/method-to-ir.c:			s = mono_ldstr_utf8 (ji->image, mono_metadata_token_index (ji->token), &cfg->error);
mini/method-to-ir.c:			return_val_if_nok (&cfg->error, NULL);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (cfg->opt & MONO_OPT_SIMD) {
mini/method-to-ir.c:		if (strcmp (method->name, "InternalAllocateStr") == 0 && !(mono_profiler_events & MONO_PROFILE_ALLOCATIONS) && !(cfg->opt & MONO_OPT_SHARED)) {
mini/method-to-ir.c:			MonoVTable *vtable = mono_class_vtable (cfg->domain, method->klass);
mini/method-to-ir.c:		cfg->args [i] = temp;
mini/method-to-ir.c:		/* This uses cfg->args [i] which is set by the preceeding line */
mini/method-to-ir.c:	} else if (cfg->r4fp && t == MONO_TYPE_R4) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	} else if (cfg->r4fp && t == MONO_TYPE_R4) {
mini/method-to-ir.c:	MonoInst *var = cfg->locals [local];
mini/method-to-ir.c:		EMIT_NEW_LOCSTORE (cfg, store, local, cfg->cbb->last_ins);
mini/method-to-ir.c:	g_assert (cfg->exception_type == MONO_EXCEPTION_NONE);
mini/method-to-ir.c:	if ((! inline_always) && ! check_inline_caller_method_name_limit (cfg->method))
mini/method-to-ir.c:	if (cfg->verbose_level > 2)
mini/method-to-ir.c:		printf ("INLINE START %p %s -> %s\n", cmethod,  mono_method_full_name (cfg->method, TRUE), mono_method_full_name (cmethod, TRUE));
mini/method-to-ir.c:		cfg->stat_inlineable_methods++;
mini/method-to-ir.c:			mono_error_move (&cfg->error, &error);
mini/method-to-ir.c:	prev_locals = cfg->locals;
mini/method-to-ir.c:	cfg->locals = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, cheader->num_locals * sizeof (MonoInst*));
mini/method-to-ir.c:		cfg->locals [i] = mono_compile_create_var (cfg, cheader->locals [i], OP_LOCAL);
mini/method-to-ir.c:	ebblock->block_num = cfg->num_bblocks++;
mini/method-to-ir.c:	prev_args = cfg->args;
mini/method-to-ir.c:	prev_arg_types = cfg->arg_types;
mini/method-to-ir.c:	prev_inlined_method = cfg->inlined_method;
mini/method-to-ir.c:	cfg->inlined_method = cmethod;
mini/method-to-ir.c:	cfg->ret_var_set = FALSE;
mini/method-to-ir.c:	cfg->inline_depth ++;
mini/method-to-ir.c:	prev_real_offset = cfg->real_offset;
mini/method-to-ir.c:	prev_cbb_hash = cfg->cbb_hash;
mini/method-to-ir.c:	prev_cil_offset_to_bb = cfg->cil_offset_to_bb;
mini/method-to-ir.c:	prev_cil_offset_to_bb_len = cfg->cil_offset_to_bb_len;
mini/method-to-ir.c:	prev_cil_start = cfg->cil_start;
mini/method-to-ir.c:	prev_ip = cfg->ip;
mini/method-to-ir.c:	prev_cbb = cfg->cbb;
mini/method-to-ir.c:	prev_current_method = cfg->current_method;
mini/method-to-ir.c:	prev_generic_context = cfg->generic_context;
mini/method-to-ir.c:	prev_ret_var_set = cfg->ret_var_set;
mini/method-to-ir.c:	prev_disable_inline = cfg->disable_inline;
mini/method-to-ir.c:	ret_var_set = cfg->ret_var_set;
mini/method-to-ir.c:	cfg->inlined_method = prev_inlined_method;
mini/method-to-ir.c:	cfg->real_offset = prev_real_offset;
mini/method-to-ir.c:	cfg->cbb_hash = prev_cbb_hash;
mini/method-to-ir.c:	cfg->cil_offset_to_bb = prev_cil_offset_to_bb;
mini/method-to-ir.c:	cfg->cil_offset_to_bb_len = prev_cil_offset_to_bb_len;
mini/method-to-ir.c:	cfg->cil_start = prev_cil_start;
mini/method-to-ir.c:	cfg->ip = prev_ip;
mini/method-to-ir.c:	cfg->locals = prev_locals;
mini/method-to-ir.c:	cfg->args = prev_args;
mini/method-to-ir.c:	cfg->arg_types = prev_arg_types;
mini/method-to-ir.c:	cfg->current_method = prev_current_method;
mini/method-to-ir.c:	cfg->generic_context = prev_generic_context;
mini/method-to-ir.c:	cfg->ret_var_set = prev_ret_var_set;
mini/method-to-ir.c:	cfg->disable_inline = prev_disable_inline;
mini/method-to-ir.c:	cfg->inline_depth --;
mini/method-to-ir.c:		if (cfg->verbose_level > 2)
mini/method-to-ir.c:			printf ("INLINE END %s -> %s\n", mono_method_full_name (cfg->method, TRUE), mono_method_full_name (cmethod, TRUE));
mini/method-to-ir.c:		cfg->stat_inlined_methods++;
mini/method-to-ir.c:				cfg->cbb = prev;
mini/method-to-ir.c:					cfg->cbb = prev_cbb;
mini/method-to-ir.c:				cfg->cbb = ebblock;
mini/method-to-ir.c:						cfg->cbb = bb;
mini/method-to-ir.c:			cfg->cbb = ebblock;
mini/method-to-ir.c:		cfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, cheader);
mini/method-to-ir.c:		if (cfg->verbose_level > 2)
mini/method-to-ir.c:		cfg->exception_type = MONO_EXCEPTION_NONE;
mini/method-to-ir.c:		cfg->cbb = prev_cbb;
mini/method-to-ir.c:	cfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, cheader);
mini/method-to-ir.c:#define CHECK_UNVERIFIABLE(cfg) if (cfg->unverifiable) UNVERIFIED
mini/method-to-ir.c:	MonoBasicBlock *b = cfg->cil_offset_to_bb [ip - cfg->cil_start];
mini/method-to-ir.c:				bblock = cfg->cil_offset_to_bb [(bb_start) - start];
mini/method-to-ir.c:	MonoMethod *method = mini_get_method_allow_open (m, token, klass, context, cfg ? &cfg->error : &error);
mini/method-to-ir.c:	if (method && cfg && !cfg->gshared && mono_class_is_open_constructed_type (&method->klass->byval_arg)) {
mini/method-to-ir.c:		mono_error_set_bad_image (&cfg->error, cfg->method->klass->image, "Method with open type while not compiling gshared");
mini/method-to-ir.c:	cfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, header);
mini/method-to-ir.c:	if ((opcode == OP_MOVE) && cfg->cbb->last_ins == sp [0]  &&
mini/method-to-ir.c:	if (ip + 6 < end && (ip [0] == CEE_PREFIX1) && (ip [1] == CEE_INITOBJ) && ip_in_bb (cfg, cfg->cbb, ip + 1)) {
mini/method-to-ir.c:		klass = mini_get_class (cfg->current_method, token, cfg->generic_context);
mini/method-to-ir.c:	gboolean is_gsharedvt = cfg->gsharedvt && mini_is_gsharedvt_variable_signature (fsig);
mini/method-to-ir.c:		cfg->cbb->last_ins->flags |= MONO_INST_LIKELY;
mini/method-to-ir.c:	if (cfg->method->save_lmf)
mini/method-to-ir.c:			mono_class_vtable (cfg->domain, cmethod->klass);
mini/method-to-ir.c:				MonoVTable *vtable = mono_class_vtable (cfg->domain, cmethod->klass);
mini/method-to-ir.c:	if (cmethod && (cfg->opt & MONO_OPT_INTRINS) && (ins = mini_emit_inst_for_ctor (cfg, cmethod, fsig, sp))) {
mini/method-to-ir.c:	} else if ((cfg->opt & MONO_OPT_INLINE) && cmethod && !context_used && !vtable_arg &&
mini/method-to-ir.c:		if ((costs = inline_method (cfg, cmethod, fsig, sp, ip, cfg->real_offset, FALSE))) {
mini/method-to-ir.c:			cfg->real_offset += 5;
mini/method-to-ir.c:			if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig))
mini/method-to-ir.c:	} else if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {
mini/method-to-ir.c:		if (cfg->llvm_only) {
mini/method-to-ir.c:				 !mono_class_generic_sharing_enabled (cmethod->klass)) || cfg->gsharedvt)) {
mini/method-to-ir.c:		if (cfg->llvm_only) {
mini/method-to-ir.c:	MonoType *ret_type = mini_get_underlying_type (mono_method_signature (cfg->method)->ret);
mini/method-to-ir.c:		if (!cfg->vret_addr) {
mini/method-to-ir.c:			EMIT_NEW_VARSTORE (cfg, ins, cfg->ret, ret_type, val);
mini/method-to-ir.c:			mono_arch_emit_setret (cfg, cfg->method, conv);
mini/method-to-ir.c:			mono_arch_emit_setret (cfg, cfg->method, val);
mini/method-to-ir.c:		mono_arch_emit_setret (cfg, cfg->method, val);
mini/method-to-ir.c:	cfg->disable_inline = is_jit_optimizer_disabled (method);
mini/method-to-ir.c:	header = mono_method_get_header_checked (method, &cfg->error);
mini/method-to-ir.c:		cfg->headers_to_free = g_slist_prepend_mempool (cfg->mempool, cfg->headers_to_free, header);
mini/method-to-ir.c:	cfg->cil_start = ip;
mini/method-to-ir.c:	cfg->stat_cil_code_size += header->code_size;
mini/method-to-ir.c:	seq_points = cfg->gen_seq_points && cfg->method == method;
mini/method-to-ir.c:	if (cfg->gen_sdb_seq_points && cfg->method == method) {
mini/method-to-ir.c:			seq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);
mini/method-to-ir.c:			seq_point_set_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);
mini/method-to-ir.c:			seq_point_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);
mini/method-to-ir.c:			seq_point_set_locs = mono_bitset_mem_new (mono_mempool_alloc0 (cfg->mempool, mono_bitset_alloc_size (header->code_size, 0)), header->code_size, 0);
mini/method-to-ir.c:	if ((cfg->opt & MONO_OPT_UNSAFE) && cfg->backend->have_dummy_init)
mini/method-to-ir.c:	if (!dont_verify && mini_assembly_can_skip_verification (cfg->domain, method)) {
mini/method-to-ir.c:	cfg->generic_context = generic_context;
mini/method-to-ir.c:	if (!cfg->gshared)
mini/method-to-ir.c:	if (cfg->method == method) {
mini/method-to-ir.c:		cfg->real_offset = 0;
mini/method-to-ir.c:		cfg->real_offset = inline_offset;
mini/method-to-ir.c:	cfg->cil_offset_to_bb = (MonoBasicBlock **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoBasicBlock*) * header->code_size);
mini/method-to-ir.c:	cfg->cil_offset_to_bb_len = header->code_size;
mini/method-to-ir.c:	cfg->current_method = method;
mini/method-to-ir.c:	if (cfg->verbose_level > 2)
mini/method-to-ir.c:	param_types = (MonoType **)mono_mempool_alloc (cfg->mempool, sizeof (MonoType*) * num_args);
mini/method-to-ir.c:	cfg->arg_types = param_types;
mini/method-to-ir.c:	cfg->dont_inline = g_list_prepend (cfg->dont_inline, method);
mini/method-to-ir.c:	if (cfg->method == method) {
mini/method-to-ir.c:		if (cfg->prof_options & MONO_PROFILE_INS_COVERAGE)
mini/method-to-ir.c:			cfg->coverage_info = mono_profiler_coverage_alloc (cfg->method, header->code_size);
mini/method-to-ir.c:		cfg->bb_entry = start_bblock;
mini/method-to-ir.c:		cfg->bb_exit = end_bblock;
mini/method-to-ir.c:		g_assert (cfg->num_bblocks == 2);
mini/method-to-ir.c:		arg_array = cfg->args;
mini/method-to-ir.c:			cfg->spvars = g_hash_table_new (NULL, NULL);
mini/method-to-ir.c:			cfg->exvars = g_hash_table_new (NULL, NULL);
mini/method-to-ir.c:				tblock->in_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*));
mini/method-to-ir.c:				cfg->cbb = tblock;
mini/method-to-ir.c:				if (!cfg->compile_llvm) {
mini/method-to-ir.c:					tblock->in_stack = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*));
mini/method-to-ir.c:					cfg->gshared &&
mini/method-to-ir.c:		cfg->cbb = start_bblock;
mini/method-to-ir.c:		cfg->args = arg_array;
mini/method-to-ir.c:	cfg->cbb = tblock;
mini/method-to-ir.c:	cfg->ip = ip;
mini/method-to-ir.c:	if (cfg->method == method) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:	if (cfg->method == method)
mini/method-to-ir.c:		cfg->bb_init = init_localsbb;
mini/method-to-ir.c:	init_localsbb->real_offset = cfg->real_offset;
mini/method-to-ir.c:	init_localsbb->next_bb = cfg->cbb;
mini/method-to-ir.c:	link_bblock (cfg, init_localsbb, cfg->cbb);
mini/method-to-ir.c:	cfg->cbb = init_localsbb;
mini/method-to-ir.c:	if (cfg->gsharedvt && cfg->method == method) {
mini/method-to-ir.c:		info = (MonoGSharedVtMethodInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoGSharedVtMethodInfo));
mini/method-to-ir.c:		info->method = cfg->method;
mini/method-to-ir.c:		info->entries = (MonoRuntimeGenericContextInfoTemplate *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoRuntimeGenericContextInfoTemplate) * info->count_entries);
mini/method-to-ir.c:		cfg->gsharedvt_info = info;
mini/method-to-ir.c:		cfg->gsharedvt_info_var = var;
mini/method-to-ir.c:		cfg->gsharedvt_locals_var = locals_var;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		cfg->gsharedvt_locals_var_ins = ins;
mini/method-to-ir.c:		cfg->flags |= MONO_CFG_HAS_ALLOCA;
mini/method-to-ir.c:	if (get_basic_blocks (cfg, header, cfg->real_offset, ip, end, &err_pos)) {
mini/method-to-ir.c:	if (cfg->method == method)
mini/method-to-ir.c:		mono_debug_init_method (cfg, cfg->cbb, breakpoint_id);
mini/method-to-ir.c:	if (cfg->gshared && method == cfg->method) {
mini/method-to-ir.c:			cfg->args [0]->flags |= MONO_INST_VOLATILE;
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, arg_ins);
mini/method-to-ir.c:		original_bb = bb = mono_basic_block_split (method, &cfg->error, header);
mini/method-to-ir.c:	stack_start = sp = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst*) * (header->max_stack + 1));
mini/method-to-ir.c:		if (cfg->method == method)
mini/method-to-ir.c:			cfg->real_offset = ip - header->code;
mini/method-to-ir.c:			cfg->real_offset = inline_offset;
mini/method-to-ir.c:		cfg->ip = ip;
mini/method-to-ir.c:			cfg->cbb->cil_length = ip - cfg->cbb->cil_code;
mini/method-to-ir.c:			cfg->cbb->next_bb = tblock;
mini/method-to-ir.c:			cfg->cbb = tblock;
mini/method-to-ir.c:			for (i = 0; i < cfg->cbb->in_scount; ++i) {
mini/method-to-ir.c:				if (cfg->verbose_level > 3)
mini/method-to-ir.c:					printf ("loading %d from temp %d\n", i, (int)cfg->cbb->in_stack [i]->inst_c0);
mini/method-to-ir.c:				EMIT_NEW_TEMPLOAD (cfg, ins, cfg->cbb->in_stack [i]->inst_c0);
mini/method-to-ir.c:			if ((tblock = cfg->cil_offset_to_bb [ip - cfg->cil_start]) && (tblock != cfg->cbb)) {
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:				cfg->cbb->next_bb = tblock;
mini/method-to-ir.c:				cfg->cbb = tblock;
mini/method-to-ir.c:				for (i = 0; i < cfg->cbb->in_scount; ++i) {
mini/method-to-ir.c:					if (cfg->verbose_level > 3)
mini/method-to-ir.c:						printf ("loading %d from temp %d\n", i, (int)cfg->cbb->in_stack [i]->inst_c0);
mini/method-to-ir.c:					EMIT_NEW_TEMPLOAD (cfg, ins, cfg->cbb->in_stack [i]->inst_c0);
mini/method-to-ir.c:				if (cfg->verbose_level > 3) printf ("SKIPPING DEAD OP at %x\n", ip_offset);
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			gboolean intr_loc = ip == header->code || (!cfg->cbb->last_ins && cfg->header->num_clauses);
mini/method-to-ir.c:			//if (!(cfg->cbb->last_ins && cfg->cbb->last_ins->opcode == OP_SEQ_POINT)) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:		cfg->cbb->real_offset = cfg->real_offset;
mini/method-to-ir.c:		if ((cfg->method == method) && cfg->coverage_info) {
mini/method-to-ir.c:			cfg->coverage_info->data [cil_offset].cil_code = ip;
mini/method-to-ir.c:			ins->inst_p0 = &(cfg->coverage_info->data [cil_offset].count);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			EMIT_NEW_PCONST (cfg, ins, &(cfg->coverage_info->data [cil_offset].count));
mini/method-to-ir.c:		if (cfg->verbose_level > 3)
mini/method-to-ir.c:			printf ("converting (in B%d: stack: %d) %s", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (cfg->keep_cil_nops)
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (should_insert_brekpoint (cfg->method)) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (cfg->compile_aot)
mini/method-to-ir.c:			f = (float *)mono_domain_alloc (cfg->domain, sizeof (float));
mini/method-to-ir.c:				ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:				ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (cfg->compile_aot)
mini/method-to-ir.c:			d = (double *)mono_domain_alloc (cfg->domain, sizeof (double));
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (cfg->gshared && mono_method_check_context_used (cmethod))
mini/method-to-ir.c:			if (cfg->llvm_only) {
mini/method-to-ir.c:				args = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * n);
mini/method-to-ir.c:				if (cfg->ret)
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:			} else if (cfg->backend->have_op_tail_call) {
mini/method-to-ir.c:				call->args = (MonoInst **)mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * n);
mini/method-to-ir.c:					call->vret_var = cfg->vret_addr;
mini/method-to-ir.c:				cfg->param_area = MAX(cfg->param_area, call->stack_usage);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, (MonoInst*)call);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			fsig = mini_get_signature (method, token, generic_context, &cfg->error);
mini/method-to-ir.c:			if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {
mini/method-to-ir.c:				if (cfg->llvm_only)
mini/method-to-ir.c:				if ((constrained_class->byval_arg.type == MONO_TYPE_VAR || constrained_class->byval_arg.type == MONO_TYPE_MVAR) && cfg->gshared) {
mini/method-to-ir.c:					if (cfg->verbose_level > 2)
mini/method-to-ir.c:						  cfg->gshared)) {
mini/method-to-ir.c:						cmethod = mono_get_method_constrained_with_method (image, cil_method, constrained_class, generic_context, &cfg->error);
mini/method-to-ir.c:					if (cfg->verbose_level > 2)
mini/method-to-ir.c:					if ((constrained_class->byval_arg.type == MONO_TYPE_VAR || constrained_class->byval_arg.type == MONO_TYPE_MVAR) && cfg->gshared) {
mini/method-to-ir.c:						cmethod = mono_get_method_constrained_checked (image, token, constrained_class, generic_context, &cil_method, &cfg->error);
mini/method-to-ir.c:			if (!dont_verify && !cfg->skip_visibility) {
mini/method-to-ir.c:					target_method = mini_get_method_allow_open (method, token, NULL, &(mono_method_get_generic_container (method_definition)->context), &cfg->error);
mini/method-to-ir.c:				if (!virtual_ && mono_class_is_marshalbyref (cmethod->klass) && (cmethod->flags & test_flags) == expected_flags && cfg->method->wrapper_type == MONO_WRAPPER_NONE)
mini/method-to-ir.c:				MonoMethod *wrapper = mono_marshal_get_native_wrapper (cmethod, TRUE, cfg->compile_aot);
mini/method-to-ir.c:				fsig = mono_method_get_signature_checked (cmethod, image, token, generic_context, &cfg->error);
mini/method-to-ir.c:			if (cfg->llvm_only && !cfg->method->wrapper_type && (!cmethod || cmethod->is_inflated))
mini/method-to-ir.c:				cfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, fsig);
mini/method-to-ir.c:			  if (cfg->gsharedvt) {
mini/method-to-ir.c:			if (!cfg->gshared && mono_class_is_gtd (cmethod->klass))
mini/method-to-ir.c:			if (!cfg->gshared)
mini/method-to-ir.c:						cfg->cbb = end_bb;
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_INTRINS) && (ins = mini_emit_inst_for_sharable_method (cfg, cmethod, fsig, sp))) {
mini/method-to-ir.c:			if (cfg->gshared && cmethod->klass != method->klass && mono_class_is_ginst (cmethod->klass) && mono_method_is_generic_sharable (cmethod, TRUE) && mono_class_needs_cctor_run (cmethod->klass, method)) {
mini/method-to-ir.c:			if (cfg->gshared) {
mini/method-to-ir.c:						((cfg->method->flags & METHOD_ATTRIBUTE_STATIC) || cfg->method->klass->valuetype))
mini/method-to-ir.c:					MonoVTable *vtable = mono_class_vtable (cfg->domain, cmethod->klass);
mini/method-to-ir.c:				if (!cfg->compile_aot) {
mini/method-to-ir.c:				!(cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) &&
mini/method-to-ir.c:				!cfg->llvm_only) {
mini/method-to-ir.c:				if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig))
mini/method-to-ir.c:				if (cfg->backend->have_generalized_imt_trampoline && cfg->backend->gshared_supported && cmethod->wrapper_type == MONO_WRAPPER_NONE) {
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, store);
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_INTRINS) && (ins = mini_emit_inst_for_method (cfg, cmethod, fsig, sp))) {
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_INLINE) &&
mini/method-to-ir.c:				costs = inline_method (cfg, cmethod, fsig, sp, ip, cfg->real_offset, always);
mini/method-to-ir.c:					cfg->real_offset += 5;
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_TAILC) && call_opcode == CEE_CALL && cmethod == method && ip [5] == CEE_RET && !vtable_arg) {
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:					link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:					if (ip_in_bb (cfg, cfg->cbb, ip + 5))
mini/method-to-ir.c:			if (cfg->method->wrapper_type == MONO_WRAPPER_SYNCHRONIZED) {
mini/method-to-ir.c:				MonoMethod *orig = mono_marshal_method_from_wrapper (cfg->method);
mini/method-to-ir.c:			if (cfg->gsharedvt && (mini_is_gsharedvt_signature (fsig) || cmethod->is_inflated || mono_class_is_ginst (cmethod->klass)) &&
mini/method-to-ir.c:				(!(cfg->llvm_only && virtual_ && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL)))) {
mini/method-to-ir.c:				if (cfg->llvm_only) {
mini/method-to-ir.c:				g_assert (cfg->gshared && cmethod);
mini/method-to-ir.c:				if (cfg->llvm_only) {
mini/method-to-ir.c:					if (cfg->gsharedvt && mini_is_gsharedvt_variable_signature (fsig))
mini/method-to-ir.c:				wrapper = mono_marshal_get_native_wrapper (cmethod, TRUE, cfg->compile_aot);
mini/method-to-ir.c:				costs = inline_method (cfg, wrapper, fsig, sp, ip, cfg->real_offset, TRUE);
mini/method-to-ir.c:				cfg->real_offset += 5;
mini/method-to-ir.c:					if (cfg->gen_write_barriers && val->type == STACK_OBJ && !MONO_INS_IS_PCONST_NULL (val))
mini/method-to-ir.c:					if (cfg->gen_write_barriers && mini_is_gsharedvt_klass (cmethod->klass))
mini/method-to-ir.c:				!vtable_arg && !cfg->gshared && is_supported_tail_call (cfg, method, cmethod, fsig, call_opcode))
mini/method-to-ir.c:				//printf ("HIT: %s -> %s\n", mono_method_full_name (cfg->method, TRUE), mono_method_full_name (cmethod, TRUE));
mini/method-to-ir.c:				if (cfg->backend->have_op_tail_call) {
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:					link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:					if (tblock == cfg->cbb || tblock->in_count == 0)
mini/method-to-ir.c:			if (cfg->llvm_only && virtual_ && cmethod && (cmethod->flags & METHOD_ATTRIBUTE_VIRTUAL)) {
mini/method-to-ir.c:			if (tail_call && !cfg->llvm_only) {
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:				if (tblock == cfg->cbb || tblock->in_count == 0)
mini/method-to-ir.c:			if (cfg->llvm_only && cmethod && method_needs_stack_walk (cfg, cmethod)) {
mini/method-to-ir.c:			if (cfg->method != method) {
mini/method-to-ir.c:				if (return_var && cfg->cbb->in_count) {
mini/method-to-ir.c:					cfg->ret_var_set = TRUE;
mini/method-to-ir.c:				if (cfg->lmf_var && cfg->cbb->in_count && !cfg->llvm_only)
mini/method-to-ir.c:				if (cfg->ret) {
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, cmp);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			ins->inst_many_bb = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof(gpointer)*2);
mini/method-to-ir.c:			targets = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (MonoBasicBlock*) * n);
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, default_bblock);
mini/method-to-ir.c:					link_bblock (cfg, cfg->cbb, targets [i]);
mini/method-to-ir.c:				mono_unlink_bblock (cfg, cfg->cbb, default_bblock);
mini/method-to-ir.c:					mono_unlink_bblock (cfg, cfg->cbb, targets [i]);
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, targets [i]);
mini/method-to-ir.c:			table = (MonoJumpInfoBBTable *)mono_mempool_alloc (cfg->mempool, sizeof (MonoJumpInfoBBTable));
mini/method-to-ir.c:			if (!cfg->compile_aot)
mini/method-to-ir.c:			cfg->cbb->has_jump_table = 1;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				if (cfg->compile_aot) {
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				ins->type = cfg->r4_stack_type;
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			if (cfg->gen_write_barriers && *ip == CEE_STIND_REF && method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER && !MONO_INS_IS_PCONST_NULL (sp [1]))
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, load);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, store);
mini/method-to-ir.c:				if (cfg->gen_write_barriers && cfg->method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER)
mini/method-to-ir.c:			if ((loc_index != -1) && ip_in_bb (cfg, cfg->cbb, ip + 5)) {
mini/method-to-ir.c:				ins->dreg = cfg->locals [loc_index]->dreg;
mini/method-to-ir.c:			if (((ip [5] == CEE_STOBJ) && ip_in_bb (cfg, cfg->cbb, ip + 5) && read32 (ip + 6) == token) && !generic_class_is_reference_type (cfg, klass) && !(ins_flag & MONO_INST_VOLATILE)) {
mini/method-to-ir.c:				if (cfg->compile_aot)
mini/method-to-ir.c:				if (cfg->opt & MONO_OPT_SHARED) {
mini/method-to-ir.c:					if (cfg->compile_aot) {
mini/method-to-ir.c:						cfg->ldstr_list = g_list_prepend (cfg->ldstr_list, GINT_TO_POINTER (n));
mini/method-to-ir.c:					mono_ldstr_checked (cfg->domain, image, mono_metadata_token_index (n), &cfg->error);
mini/method-to-ir.c:					if (cfg->cbb->out_of_line) {
mini/method-to-ir.c:					if (cfg->compile_aot) {
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:						ins->inst_p0 = mono_ldstr_checked (cfg->domain, image, mono_metadata_token_index (n), &cfg->error);
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			fsig = mono_method_get_signature_checked (cmethod, image, token, generic_context, &cfg->error);
mini/method-to-ir.c:			if (cfg->gshared && cmethod && cmethod->klass != method->klass && mono_class_is_ginst (cmethod->klass) && mono_method_is_generic_sharable (cmethod, TRUE) && mono_class_needs_cctor_run (cmethod->klass, method)) {
mini/method-to-ir.c:			if (cfg->gsharedvt) {
mini/method-to-ir.c:			if (cfg->cbb->out_of_line && cmethod->klass->image == mono_defaults.corlib &&
mini/method-to-ir.c:					if (!cfg->compile_aot)
mini/method-to-ir.c:						vtable = mono_class_vtable (cfg->domain, cmethod->klass);
mini/method-to-ir.c:						if (cfg->verbose_level > 2)
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_TYPE_CHECK;
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, res);
mini/method-to-ir.c:					cfg->flags |= MONO_CFG_HAS_TYPE_CHECK;
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_INTRINS) &&
mini/method-to-ir.c:			    ip_in_bb (cfg, cfg->cbb, ip + 5 + 6 + 5) &&
mini/method-to-ir.c:				ip + 5 < end && ip_in_bb (cfg, cfg->cbb, ip + 5) &&
mini/method-to-ir.c:				if (cfg->verbose_level > 3) {
mini/method-to-ir.c:					printf ("converting (in B%d: stack: %d) %s", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));
mini/method-to-ir.c:				mono_link_bblock (cfg, cfg->cbb, true_bb);
mini/method-to-ir.c:				mono_link_bblock (cfg, cfg->cbb, false_bb);
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				field = mono_field_from_token_checked (image, token, &klass, generic_context, &cfg->error);
mini/method-to-ir.c:			if (!dont_verify && !cfg->skip_visibility && !mono_method_can_access_field (method, field))
mini/method-to-ir.c:					if (cfg->opt & MONO_OPT_INLINE || cfg->compile_aot) {
mini/method-to-ir.c:											   iargs, ip, cfg->real_offset, TRUE);
mini/method-to-ir.c:						cfg->real_offset += 5;
mini/method-to-ir.c:					if (cfg->gen_write_barriers && mini_type_to_stind (cfg, field->type) == CEE_STIND_REF && !MONO_INS_IS_PCONST_NULL (sp [1])) {
mini/method-to-ir.c:				if (cfg->opt & MONO_OPT_INLINE || cfg->compile_aot) {
mini/method-to-ir.c:										   iargs, ip, cfg->real_offset, TRUE);
mini/method-to-ir.c:					cfg->real_offset += 5;
mini/method-to-ir.c:					if (sp [0]->opcode == OP_LDADDR && klass->simd_type && cfg->opt & MONO_OPT_SIMD) {
mini/method-to-ir.c:				mono_error_set_field_load (&cfg->error, field->parent, field->name, "Using static instructions with literal field");
mini/method-to-ir.c:			if (!context_used && !(cfg->opt & MONO_OPT_SHARED)) {
mini/method-to-ir.c:				mono_class_vtable (cfg->domain, klass);
mini/method-to-ir.c:			mono_domain_lock (cfg->domain);
mini/method-to-ir.c:			if (cfg->domain->special_static_fields)
mini/method-to-ir.c:				addr = g_hash_table_lookup (cfg->domain->special_static_fields, field);
mini/method-to-ir.c:			mono_domain_unlock (cfg->domain);
mini/method-to-ir.c:			if (is_special_static && ((gsize)addr & 0x80000000) == 0 && thread_ins && !(cfg->opt & MONO_OPT_SHARED) && !context_used) {
mini/method-to-ir.c:				if (context_used && cfg->gsharedvt && mini_is_gsharedvt_klass (klass))
mini/method-to-ir.c:				if (cfg->compile_aot) {
mini/method-to-ir.c:			} else if ((cfg->opt & MONO_OPT_SHARED) ||
mini/method-to-ir.c:					(cfg->compile_aot && is_special_static) ||
mini/method-to-ir.c:				} else if ((cfg->opt & MONO_OPT_SHARED) || (cfg->compile_aot && addr)) {
mini/method-to-ir.c:				if (!cfg->compile_aot)
mini/method-to-ir.c:					vtable = mono_class_vtable (cfg->domain, klass);
mini/method-to-ir.c:							if (cfg->verbose_level > 2)
mini/method-to-ir.c:						if (cfg->run_cctors) {
mini/method-to-ir.c:							if (!mono_runtime_class_init_full (vtable, &cfg->error)) {
mini/method-to-ir.c:					if (cfg->compile_aot)
mini/method-to-ir.c:					vtable = mono_class_vtable (cfg->domain, klass);
mini/method-to-ir.c:						(!context_used && !((cfg->opt & MONO_OPT_SHARED) || cfg->compile_aot) && vtable->initialized))) {
mini/method-to-ir.c:			if (cfg->gen_write_barriers && cfg->method->wrapper_type != MONO_WRAPPER_WRITE_BARRIER &&
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				if (cfg->opt & MONO_OPT_SHARED) {
mini/method-to-ir.c:					mono_class_vtable (cfg->domain, array_type);
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:					cfg->flags |= MONO_CFG_HAS_ARRAY_ACCESS;
mini/method-to-ir.c:					cfg->cbb->has_array_access = TRUE;
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_INTRINS) && ip + 6 < end && ip_in_bb (cfg, cfg->cbb, ip + 6) && (len_ins->opcode == OP_ICONST) && (data_ptr = initialize_array_data (method, cfg->compile_aot, ip, klass, len_ins->inst_c0, &data_size, &field_token))) {
mini/method-to-ir.c:				if (cfg->compile_aot) {
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_ARRAY_ACCESS;
mini/method-to-ir.c:			cfg->cbb->has_array_access = TRUE;
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_LDELEMA;
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_LDELEMA;
mini/method-to-ir.c:			cfg->flags |= MONO_CFG_HAS_LDELEMA;
mini/method-to-ir.c:			if (cfg->llvm_only) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				handle = mono_ldtoken_checked (image, n, &handle_class, generic_context, &cfg->error);
mini/method-to-ir.c:			if (cfg->gshared) {
mini/method-to-ir.c:			if ((cfg->opt & MONO_OPT_SHARED) &&
mini/method-to-ir.c:				if ((ip + 5 < end) && ip_in_bb (cfg, cfg->cbb, ip + 5) && 
mini/method-to-ir.c:					} else if (cfg->compile_aot) {
mini/method-to-ir.c:						MonoReflectionType *rt = mono_type_get_object_checked (cfg->domain, (MonoType *)handle, &cfg->error);
mini/method-to-ir.c:					} else if (cfg->compile_aot) {
mini/method-to-ir.c:			cfg->cbb->out_of_line = TRUE;
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			cfg->cbb->try_end = (intptr_t)(ip - header->code);
mini/method-to-ir.c:					tblock = cfg->cil_offset_to_bb [clause->handler_offset];
mini/method-to-ir.c:					link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:					cfg->cbb->has_call_handler = 1;
mini/method-to-ir.c:						GET_BBLOCK (cfg, tblock, cfg->cil_start + clause->handler_offset + clause->handler_len - 1);
mini/method-to-ir.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:			link_bblock (cfg, cfg->cbb, tblock);
mini/method-to-ir.c:				if (cfg->compile_aot) {
mini/method-to-ir.c:					if (cfg->direct_pinvoke && ip + 6 < end && (ip [6] == CEE_POP)) {
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, iargs [0]);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, iargs [1]);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				g_assert (cfg->ret);
mini/method-to-ir.c:				if (!cfg->vret_addr) {
mini/method-to-ir.c:					g_assert (cfg->ret_var_is_local);
mini/method-to-ir.c:					EMIT_NEW_VARLOADA (cfg, ins, cfg->ret, cfg->ret->inst_vtype);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:				cfg->cbb->out_of_line = TRUE;
mini/method-to-ir.c:				if (!cfg->dyn_call_var) {
mini/method-to-ir.c:					cfg->dyn_call_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:					cfg->dyn_call_var->flags |= MONO_INST_VOLATILE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->param_area = MAX (cfg->param_area, cfg->backend->dyn_call_param_area);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->orig_domain_var = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/method-to-ir.c:				MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->orig_domain_var->dreg, ins->dreg);
mini/method-to-ir.c:					if (cfg->compile_aot) {
mini/method-to-ir.c:						EMIT_NEW_PCONST (cfg, domain_ins, cfg->domain);
mini/method-to-ir.c:				EMIT_NEW_PCONST (cfg, args [0], cfg->compile_aot ? NULL : cfg->domain);
mini/method-to-ir.c:				if (cfg->compile_aot) {
mini/method-to-ir.c:				MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->orig_domain_var->dreg, ins->dreg);
mini/method-to-ir.c:				EMIT_NEW_UNALU (cfg, args [0], OP_MOVE, dreg, cfg->orig_domain_var->dreg);
mini/method-to-ir.c:				fsig = mini_get_signature (method, token, generic_context, &cfg->error);
mini/method-to-ir.c:				if (cfg->llvm_only)
mini/method-to-ir.c:					cfg->signatures = g_slist_prepend_mempool (cfg->mempool, cfg->signatures, fsig);
mini/method-to-ir.c:				if (cfg->llvm_only) {
mini/method-to-ir.c:					if (cfg->gsharedvt && mini_is_gsharedvt_variable_signature (fsig)) {
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:						cfg->flags |= MONO_CFG_HAS_ALLOCA;
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, addr);
mini/method-to-ir.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:						cfg->flags |= MONO_CFG_HAS_ALLOCA;
mini/method-to-ir.c:					if (cfg->gsharedvt && mini_is_gsharedvt_signature (fsig)) {
mini/method-to-ir.c:				EMIT_NEW_PCONST (cfg, ins, cfg->compile_aot ? NULL : cfg->domain);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, cmp);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				if (!dont_verify && !cfg->skip_visibility && !mono_method_can_access_method (method, cmethod))
mini/method-to-ir.c:				if ((sp > stack_start) && (ip + 6 + 5 < end) && ip_in_bb (cfg, cfg->cbb, ip + 6) && (ip [6] == CEE_NEWOBJ)) {
mini/method-to-ir.c:						if (invoke_context_used == 0 || cfg->llvm_only) {
mini/method-to-ir.c:							if (cfg->verbose_level > 3)
mini/method-to-ir.c:								g_print ("converting (in B%d: stack: %d) %s", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));
mini/method-to-ir.c:				if ((sp > stack_start) && (ip + 6 + 5 < end) && ip_in_bb (cfg, cfg->cbb, ip + 6) && (ip [6] == CEE_NEWOBJ) && (ip > header->code && ip [-1] == CEE_DUP)) {
mini/method-to-ir.c:						if (invoke_context_used == 0 || cfg->llvm_only) {
mini/method-to-ir.c:							if (cfg->verbose_level > 3)
mini/method-to-ir.c:								g_print ("converting (in B%d: stack: %d) %s", cfg->cbb->block_num, (int)(sp - stack_start), mono_disasm_code_one (NULL, method, ip, NULL));
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				if (cfg->method != method) 
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->flags |= MONO_CFG_HAS_ALLOCA;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				cfg->flags |= MONO_CFG_HAS_TAIL;
mini/method-to-ir.c:				if ((ip [1] == CEE_CPBLK) && !(ins_flag & MONO_INST_VOLATILE) && (cfg->opt & MONO_OPT_INTRINS) && (sp [2]->opcode == OP_ICONST) && ((n = sp [2]->inst_c0) <= sizeof (gpointer) * 5)) {
mini/method-to-ir.c:				} else if ((ip [1] == CEE_INITBLK) && !(ins_flag & MONO_INST_VOLATILE) && (cfg->opt & MONO_OPT_INTRINS) && (sp [2]->opcode == OP_ICONST) && ((n = sp [2]->inst_c0) <= sizeof (gpointer) * 5) && (sp [1]->opcode == OP_ICONST) && (sp [1]->inst_c0 == 0)) {
mini/method-to-ir.c:				cfg->cbb->flags |= BB_EXCEPTION_UNSAFE;
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/method-to-ir.c:				link_bblock (cfg, cfg->cbb, end_bblock);
mini/method-to-ir.c:					MonoType *type = mono_type_create_from_typespec_checked (image, token, &cfg->error);
mini/method-to-ir.c:	cfg->cbb->cil_length = ip - cfg->cbb->cil_code;
mini/method-to-ir.c:	if (cfg->cbb->next_bb) {
mini/method-to-ir.c:		MonoBasicBlock *bb = cfg->cbb;
mini/method-to-ir.c:		cfg->cbb->next_bb = end_bblock;
mini/method-to-ir.c:	if (cfg->method == method && cfg->domainvar) {
mini/method-to-ir.c:		cfg->cbb = init_localsbb;
mini/method-to-ir.c:		NEW_TEMPSTORE (cfg, store, cfg->domainvar->inst_c0, get_domain);
mini/method-to-ir.c:		MONO_ADD_INS (cfg->cbb, store);
mini/method-to-ir.c:	if (cfg->compile_aot)
mini/method-to-ir.c:	if (cfg->method == method && cfg->got_var)
mini/method-to-ir.c:		cfg->cbb = init_localsbb;
mini/method-to-ir.c:		cfg->ip = NULL;
mini/method-to-ir.c:	if (cfg->init_ref_vars && cfg->method == method) {
mini/method-to-ir.c:		for (i = 0; i < cfg->num_varinfo; ++i) {
mini/method-to-ir.c:			MonoInst *ins = cfg->varinfo [i];
mini/method-to-ir.c:	if (cfg->lmf_var && cfg->method == method && !cfg->llvm_only) {
mini/method-to-ir.c:		cfg->cbb = init_localsbb;
mini/method-to-ir.c:	cfg->cbb = init_localsbb;
mini/method-to-ir.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/method-to-ir.c:	if (seq_points && cfg->gen_sdb_seq_points) {
mini/method-to-ir.c:		MONO_ADD_INS (cfg->bb_exit, ins);
mini/method-to-ir.c:	cfg->ip = NULL;
mini/method-to-ir.c:	if (cfg->method == method) {
mini/method-to-ir.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/method-to-ir.c:			if (bb == cfg->bb_init)
mini/method-to-ir.c:			if (cfg->spvars)
mini/method-to-ir.c:			if (cfg->verbose_level > 2)
mini/method-to-ir.c:	if ((cfg->verbose_level > 2) && (cfg->method == method)) 
mini/method-to-ir.c:	g_assert (!mono_error_ok (&cfg->error));
mini/method-to-ir.c:	g_assert (cfg->exception_type != MONO_EXCEPTION_NONE);
mini/method-to-ir.c:	cfg->dont_inline = g_list_remove (cfg->dont_inline, method);
mini/method-to-ir.c:	if (cfg->exception_type)
mini/method-to-ir.c:		if ((load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32) || (load_opcode == OP_LOADI8_MEMBASE))
mini/method-to-ir.c:		if (cfg->backend->ilp32 && load_opcode == OP_LOAD_MEMBASE)
mini/method-to-ir.c:		if ((load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32) || (load_opcode == OP_LOADI8_MEMBASE))
mini/method-to-ir.c:	if ((load_opcode == OP_LOADI4_MEMBASE) || (load_opcode == OP_LOADU4_MEMBASE) || (load_opcode == OP_LOAD_MEMBASE && cfg->backend->ilp32)) {
mini/method-to-ir.c:	} else if ((load_opcode == OP_LOADI8_MEMBASE) || (load_opcode == OP_LOAD_MEMBASE && !cfg->backend->ilp32)) {
mini/method-to-ir.c:	vreg_to_bb = (gint32 *)mono_mempool_alloc0 (cfg->mempool, sizeof (gint32*) * cfg->next_vreg + 1);
mini/method-to-ir.c:	if (cfg->uses_simd_intrinsics)
mini/method-to-ir.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/method-to-ir.c:		if (cfg->verbose_level > 2)
mini/method-to-ir.c:		cfg->cbb = bb;
mini/method-to-ir.c:			if (G_UNLIKELY (cfg->verbose_level > 2))
mini/method-to-ir.c:						if (cfg->verbose_level > 2)
mini/method-to-ir.c:						if (G_UNLIKELY (cfg->verbose_level > 2))
mini/method-to-ir.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/method-to-ir.c:		MonoInst *var = cfg->varinfo [i];
mini/method-to-ir.c:			if (var->type == STACK_VTYPE && cfg->gsharedvt && mini_is_gsharedvt_variable_type (var->inst_vtype))
mini/method-to-ir.c:			if ((var->opcode != OP_ARG) && (var != cfg->ret) && !(var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) && (vreg_to_bb [var->dreg] != -1) && (var->klass->byval_arg.type != MONO_TYPE_R4) && !cfg->disable_vreg_to_lvreg && var != cfg->gsharedvt_info_var && var != cfg->gsharedvt_locals_var && var != cfg->lmf_addr_var) {
mini/method-to-ir.c:				if (cfg->compile_aot && vreg_to_bb [var->dreg]) {
mini/method-to-ir.c:				if (G_UNLIKELY (cfg->verbose_level > 2))
mini/method-to-ir.c:				cfg->vreg_to_inst [var->dreg] = NULL;
mini/method-to-ir.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/method-to-ir.c:		MonoInst *var = cfg->varinfo [i];
mini/method-to-ir.c:		if (pos < i && cfg->locals_start == i)
mini/method-to-ir.c:			cfg->locals_start = pos;
mini/method-to-ir.c:				cfg->varinfo [pos] = cfg->varinfo [i];
mini/method-to-ir.c:				cfg->varinfo [pos]->inst_c0 = pos;
mini/method-to-ir.c:				memcpy (&cfg->vars [pos], &cfg->vars [i], sizeof (MonoMethodVar));
mini/method-to-ir.c:				cfg->vars [pos].idx = pos;
mini/method-to-ir.c:				if (cfg->varinfo [pos]->type == STACK_I8) {
mini/method-to-ir.c:					var1 = get_vreg_to_inst (cfg, MONO_LVREG_LS (cfg->varinfo [pos]->dreg));
mini/method-to-ir.c:					var1 = get_vreg_to_inst (cfg, MONO_LVREG_MS (cfg->varinfo [pos]->dreg));
mini/method-to-ir.c:	cfg->num_varinfo = pos;
mini/method-to-ir.c:	if (cfg->locals_start > cfg->num_varinfo)
mini/method-to-ir.c:		cfg->locals_start = cfg->num_varinfo;
mini/method-to-ir.c: * Initialize cfg->gsharedvt_vreg_to_idx with the mapping between vregs and indexes.
mini/method-to-ir.c:	cfg->gsharedvt_vreg_to_idx = (int *)mono_mempool_alloc0 (cfg->mempool, sizeof (int) * cfg->next_vreg);
mini/method-to-ir.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/method-to-ir.c:		MonoInst *ins = cfg->varinfo [i];
mini/method-to-ir.c:			if (i >= cfg->locals_start) {
mini/method-to-ir.c:				cfg->gsharedvt_vreg_to_idx [ins->dreg] = idx + 1;
mini/method-to-ir.c:				cfg->gsharedvt_vreg_to_idx [ins->dreg] = -1;
mini/method-to-ir.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/method-to-ir.c:		MonoInst *ins = cfg->varinfo [i];
mini/method-to-ir.c:	if (cfg->compute_gc_maps) {
mini/method-to-ir.c:		for (i = 0; i < cfg->num_varinfo; i++) {
mini/method-to-ir.c:			MonoInst *ins = cfg->varinfo [i];
mini/method-to-ir.c:	orig_next_vreg = cfg->next_vreg;
mini/method-to-ir.c:	vreg_to_lvreg = (guint32 *)mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * cfg->next_vreg);
mini/method-to-ir.c:	lvregs = (guint32 *)mono_mempool_alloc (cfg->mempool, sizeof (guint32) * lvregs_size);
mini/method-to-ir.c:	live_range_start = g_new0 (MonoInst*, cfg->next_vreg);
mini/method-to-ir.c:	live_range_end = g_new0 (MonoInst*, cfg->next_vreg);
mini/method-to-ir.c:	live_range_start_bb = g_new (MonoBasicBlock*, cfg->next_vreg);
mini/method-to-ir.c:	live_range_end_bb = g_new (MonoBasicBlock*, cfg->next_vreg);
mini/method-to-ir.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/method-to-ir.c:		if (cfg->verbose_level > 2)
mini/method-to-ir.c:		cfg->cbb = bb;
mini/method-to-ir.c:			if (G_UNLIKELY (cfg->verbose_level > 2))
mini/method-to-ir.c:				} else if (cfg->gsharedvt && cfg->gsharedvt_vreg_to_idx [var->dreg] < 0) {
mini/method-to-ir.c:				} else if (cfg->gsharedvt && cfg->gsharedvt_vreg_to_idx [var->dreg]) {
mini/method-to-ir.c:					int idx = cfg->gsharedvt_vreg_to_idx [var->dreg] - 1;
mini/method-to-ir.c:					MonoInst *info_var = cfg->gsharedvt_info_var;
mini/method-to-ir.c:					MonoInst *locals_var = cfg->gsharedvt_locals_var;
mini/method-to-ir.c:					cfg->gsharedvt_locals_var_ins = NULL;
mini/method-to-ir.c:			if (G_UNLIKELY (cfg->verbose_level > 2)) {
mini/method-to-ir.c:							if ((!cfg->backend->use_fpstack || ((store_opcode != OP_STORER8_MEMBASE_REG) && (store_opcode != OP_STORER4_MEMBASE_REG))) && !((var)->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)))
mini/method-to-ir.c:				if (cfg->compute_gc_maps && def_ins && (var->flags & MONO_INST_GC_TRACK)) {
mini/method-to-ir.c:						if (cfg->compute_gc_maps && var->dreg < orig_next_vreg && (var->flags & MONO_INST_GC_TRACK)) {
mini/method-to-ir.c:						if (G_UNLIKELY (cfg->verbose_level > 2))
mini/method-to-ir.c:							if ((!cfg->backend->use_fpstack || ((load_opcode != OP_LOADR8_MEMBASE) && (load_opcode != OP_LOADR4_MEMBASE))) && !((var)->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) && !no_lvreg) {
mini/method-to-ir.c:									guint32 *new_lvregs = mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * lvregs_size * 2);
mini/method-to-ir.c:					if (cfg->compute_gc_maps && var->dreg < orig_next_vreg && (var->flags & MONO_INST_GC_TRACK)) {
mini/method-to-ir.c:					guint32 *new_lvregs = mono_mempool_alloc0 (cfg->mempool, sizeof (guint32) * lvregs_size * 2);
mini/method-to-ir.c:			if (cfg->verbose_level > 2)
mini/method-to-ir.c:		if (cfg->compute_precise_live_ranges && bb->live_out_set && bb->code) {
mini/method-to-ir.c:			for (i = 0; i < cfg->num_varinfo; i ++) {
mini/method-to-ir.c:	if (cfg->backend->have_liverange_ops && cfg->compute_precise_live_ranges && cfg->comp_done & MONO_COMP_LIVENESS) {
mini/method-to-ir.c:		for (i = 0; i < cfg->num_varinfo; ++i) {
mini/method-to-ir.c:	if (cfg->gsharedvt_locals_var_ins) {
mini/method-to-ir.c:		cfg->gsharedvt_locals_var_ins->opcode = OP_PCONST;
mini/method-to-ir.c:		cfg->gsharedvt_locals_var_ins->inst_imm = 0;
mini/method-to-ir.c: * - do not start a new IL level bblock when cfg->cbb is changed by a function call
mini/mini-amd64.c:#define DEBUG(a) if (cfg->verbose_level > 1) a
mini/mini-amd64.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-amd64.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-amd64.c:	if (cfg->arch.omit_fp_computed)
mini/mini-amd64.c:	header = cfg->header;
mini/mini-amd64.c:	sig = mono_method_signature (cfg->method);
mini/mini-amd64.c:	if (!cfg->arch.cinfo)
mini/mini-amd64.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:	cfg->arch.omit_fp = TRUE;
mini/mini-amd64.c:	cfg->arch.omit_fp_computed = TRUE;
mini/mini-amd64.c:	if (cfg->disable_omit_fp)
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:	if (cfg->method->save_lmf)
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:	if (cfg->param_area)
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-amd64.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE))
mini/mini-amd64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:			cfg->arch.omit_fp = FALSE;
mini/mini-amd64.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-amd64.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-amd64.c:	if (cfg->arch.omit_fp)
mini/mini-amd64.c:	MonoInst *ins = cfg->varinfo [vmv->idx];
mini/mini-amd64.c:	if (cfg->method->save_lmf)
mini/mini-amd64.c: *   Populate cfg->args, cfg->ret and cfg->vret_addr with information about the arguments
mini/mini-amd64.c:	sig = mono_method_signature (cfg->method);
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:		cfg->ret->opcode = OP_REGVAR;
mini/mini-amd64.c:		cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-amd64.c:		cfg->ret->opcode = OP_REGOFFSET;
mini/mini-amd64.c:		cfg->ret->inst_basereg = -1;
mini/mini-amd64.c:		cfg->ret->inst_offset = -1;
mini/mini-amd64.c:		ins = cfg->args [i];
mini/mini-amd64.c:	sig = mono_method_signature (cfg->method);
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:	if (cfg->arch.omit_fp) {
mini/mini-amd64.c:		cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-amd64.c:		cfg->frame_reg = AMD64_RSP;
mini/mini-amd64.c:		cfg->frame_reg = AMD64_RBP;
mini/mini-amd64.c:	cfg->arch.saved_iregs = cfg->used_int_regs;
mini/mini-amd64.c:	if (cfg->method->save_lmf) {
mini/mini-amd64.c:		cfg->arch.saved_iregs |= iregs_to_save;
mini/mini-amd64.c:	if (cfg->arch.omit_fp)
mini/mini-amd64.c:		cfg->arch.reg_save_area_offset = offset;
mini/mini-amd64.c:		if (AMD64_IS_CALLEE_SAVED_REG (i) && (cfg->arch.saved_iregs & (1 << i))) {
mini/mini-amd64.c:	if (!cfg->arch.omit_fp)
mini/mini-amd64.c:		cfg->arch.reg_save_area_offset = -offset;
mini/mini-amd64.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-amd64.c:			cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-amd64.c:			cfg->ret->dreg = cinfo->ret.reg;
mini/mini-amd64.c:			cfg->vret_addr->opcode = OP_REGOFFSET;
mini/mini-amd64.c:			cfg->vret_addr->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:				cfg->vret_addr->inst_offset = offset;
mini/mini-amd64.c:				cfg->vret_addr->inst_offset = -offset;
mini/mini-amd64.c:			if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-amd64.c:				mono_print_ins (cfg->vret_addr);
mini/mini-amd64.c:			cfg->ret->opcode = OP_REGOFFSET;
mini/mini-amd64.c:			cfg->ret->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:				cfg->ret->inst_offset = offset;
mini/mini-amd64.c:				cfg->ret->inst_offset = - offset;
mini/mini-amd64.c:	offsets = mono_allocate_stack_slots (cfg, cfg->arch.omit_fp ? FALSE: TRUE, &locals_stack_size, &locals_stack_align);
mini/mini-amd64.c:		char *mname = mono_method_full_name (cfg->method, TRUE);
mini/mini-amd64.c:	if (cfg->arch.omit_fp) {
mini/mini-amd64.c:		cfg->locals_min_stack_offset = offset;
mini/mini-amd64.c:		cfg->locals_max_stack_offset = offset + locals_stack_size;
mini/mini-amd64.c:		cfg->locals_min_stack_offset = - (offset + locals_stack_size);
mini/mini-amd64.c:		cfg->locals_max_stack_offset = - offset;
mini/mini-amd64.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-amd64.c:			MonoInst *ins = cfg->varinfo [i];
mini/mini-amd64.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:			if (cfg->arch.omit_fp)
mini/mini-amd64.c:		g_assert (!cfg->arch.omit_fp);
mini/mini-amd64.c:		cfg->sig_cookie = cinfo->sig_cookie.offset + ARGS_OFFSET;
mini/mini-amd64.c:		ins = cfg->args [i];
mini/mini-amd64.c:				g_assert (!cfg->arch.omit_fp);
mini/mini-amd64.c:				ins->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:				g_assert (!cfg->arch.omit_fp);
mini/mini-amd64.c:					indir->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:					indir->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:				ins->inst_basereg = cfg->frame_reg;
mini/mini-amd64.c:				if (cfg->arch.omit_fp) {
mini/mini-amd64.c:					//cfg->locals_max_stack_offset = MAX (cfg->locals_max_stack_offset, offset);
mini/mini-amd64.c:					//cfg->locals_min_stack_offset = MIN (cfg->locals_min_stack_offset, offset);
mini/mini-amd64.c:	cfg->stack_offset = offset;
mini/mini-amd64.c:	sig = mono_method_signature (cfg->method);
mini/mini-amd64.c:	if (!cfg->arch.cinfo)
mini/mini-amd64.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:		cfg->ret_var_is_local = TRUE;
mini/mini-amd64.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-amd64.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-amd64.c:			mono_print_ins (cfg->vret_addr);
mini/mini-amd64.c:	if (cfg->gen_sdb_seq_points) {
mini/mini-amd64.c:		if (cfg->compile_aot) {
mini/mini-amd64.c:			cfg->arch.seq_point_info_var = ins;
mini/mini-amd64.c:		cfg->arch.ss_tramp_var = ins;
mini/mini-amd64.c:		cfg->arch.bp_tramp_var = ins;
mini/mini-amd64.c:	if (cfg->method->save_lmf)
mini/mini-amd64.c:		cfg->create_lmf_var = TRUE;
mini/mini-amd64.c:	if (cfg->method->save_lmf) {
mini/mini-amd64.c:		cfg->lmf_ir = TRUE;
mini/mini-amd64.c:			cfg->lmf_ir_mono_lmf = TRUE;
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-amd64.c:	tmp_sig = mono_metadata_signature_dup_full (cfg->method->klass->image, call->signature);
mini/mini-amd64.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-amd64.c:	linfo = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));
mini/mini-amd64.c:			cfg->exception_message = g_strdup ("pinvoke + vtype ret");
mini/mini-amd64.c:			cfg->disable_llvm = TRUE;
mini/mini-amd64.c:				cfg->exception_message = g_strdup ("pinvoke + vtypes");
mini/mini-amd64.c:				cfg->disable_llvm = TRUE;
mini/mini-amd64.c:			cfg->exception_message = g_strdup ("ainfo->storage");
mini/mini-amd64.c:			cfg->disable_llvm = TRUE;
mini/mini-amd64.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-amd64.c:		cfg->disable_llvm = TRUE;
mini/mini-amd64.c:			if (cfg->compute_gc_maps) {
mini/mini-amd64.c:				cfg->args [i]->flags |= MONO_INST_VOLATILE;
mini/mini-amd64.c:				arg->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-amd64.c:				MONO_ADD_INS (cfg->cbb, arg);
mini/mini-amd64.c:			if (!cfg->arch.vret_addr_loc) {
mini/mini-amd64.c:				cfg->arch.vret_addr_loc = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/mini-amd64.c:				((MonoInst*)cfg->arch.vret_addr_loc)->flags |= MONO_INST_VOLATILE;
mini/mini-amd64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, ((MonoInst*)cfg->arch.vret_addr_loc)->dreg, call->vret_var->dreg);
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-amd64.c:	if (cfg->method->save_lmf) {
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, arg);
mini/mini-amd64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-amd64.c:		cfg->has_indirection = TRUE;
mini/mini-amd64.c:		MONO_ADD_INS (cfg->cbb, load);
mini/mini-amd64.c:			MONO_ADD_INS (cfg->cbb, arg);
mini/mini-amd64.c:		if (cfg->compute_gc_maps) {
mini/mini-amd64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-amd64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_AMD64_SET_XMMREG_R4, cfg->ret->dreg, val->dreg);
mini/mini-amd64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-amd64.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-amd64.c:	        x86_branch (code, cond, cfg->native_code + ins->inst_true_bb->native_offset, sign); \
mini/mini-amd64.c:	        mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb); \
mini/mini-amd64.c:	        if ((cfg->opt & MONO_OPT_BRANCH) && \
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code,   \
mini/mini-amd64.c:			if (cfg->abs_patches)
mini/mini-amd64.c:				jinfo = (MonoJumpInfo *)g_hash_table_lookup (cfg->abs_patches, data);
mini/mini-amd64.c:		if (cfg->method->dynamic)
mini/mini-amd64.c:		if (cfg->compile_aot) {
mini/mini-amd64.c:			if (!no_patch && ((guint32)(code + 1 - cfg->native_code) % 4) != 0) {
mini/mini-amd64.c:				guint32 pad_size = 4 - ((guint32)(code + 1 - cfg->native_code) % 4);
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, patch_type, data);
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, patch_type, data);
mini/mini-amd64.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-amd64.c:		if (cfg->param_area)
mini/mini-amd64.c:			amd64_alu_reg_imm (code, X86_ADD, AMD64_RDI, cfg->param_area);
mini/mini-amd64.c:		cinfo = get_call_info (cfg->mempool, ((MonoCallInst*)ins)->signature);
mini/mini-amd64.c:			MonoInst *loc = (MonoInst *)cfg->arch.vret_addr_loc;
mini/mini-amd64.c:	amd64_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, rsp), AMD64_RSP, 8);
mini/mini-amd64.c:	amd64_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, rbp), AMD64_RBP, 8);
mini/mini-amd64.c:	if (cfg->arch.omit_fp && cfa_offset != -1)
mini/mini-amd64.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-amd64.c:	if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini-amd64.c:		int current_offset = cfg->code_len;
mini/mini-amd64.c:	if (cfg->opt & MONO_OPT_LOOP) {
mini/mini-amd64.c:		if (bb_is_loop_start (bb) && (pad = (cfg->code_len & (align - 1)))) {
mini/mini-amd64.c:			/*g_print ("adding %d pad at %x to loop in %s\n", pad, cfg->code_len, cfg->method->name);*/
mini/mini-amd64.c:			cfg->code_len += pad;
mini/mini-amd64.c:			bb->native_offset = cfg->code_len;
mini/mini-amd64.c:	if (cfg->verbose_level > 2)
mini/mini-amd64.c:	if ((cfg->prof_options & MONO_PROFILE_COVERAGE) && cfg->coverage_info) {
mini/mini-amd64.c:		MonoProfileCoverageInfo *cov = cfg->coverage_info;
mini/mini-amd64.c:		g_assert (!cfg->compile_aot);
mini/mini-amd64.c:	offset = code - cfg->native_code;
mini/mini-amd64.c:    if (mono_break_at_bb_method && mono_method_desc_full_match (mono_break_at_bb_method, cfg->method) && bb->block_num == mono_break_at_bb_bb_num)
mini/mini-amd64.c:		offset = code - cfg->native_code;
mini/mini-amd64.c:		if (G_UNLIKELY (offset > (cfg->code_size - max_len - EXTRA_CODE_SPACE))) {
mini/mini-amd64.c:			cfg->code_size *= 2;
mini/mini-amd64.c:			cfg->native_code = (unsigned char *)mono_realloc_native_code(cfg);
mini/mini-amd64.c:			code = cfg->native_code + offset;
mini/mini-amd64.c:			cfg->stat_code_reallocs++;
mini/mini-amd64.c:		if (cfg->debug_info)
mini/mini-amd64.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-amd64.c:				MonoInst *var = (MonoInst *)cfg->arch.ss_tramp_var;
mini/mini-amd64.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-amd64.c:			if (cfg->compile_aot) {
mini/mini-amd64.c:				guint32 offset = code - cfg->native_code;
mini/mini-amd64.c:				MonoInst *info_var = (MonoInst *)cfg->arch.seq_point_info_var;
mini/mini-amd64.c:				MonoInst *var = (MonoInst *)cfg->arch.bp_tramp_var;
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			g_assert (!cfg->method->save_lmf);
mini/mini-amd64.c:			save_area_offset = cfg->arch.reg_save_area_offset;
mini/mini-amd64.c:				if (AMD64_IS_CALLEE_SAVED_REG (i) && (cfg->used_int_regs & (1 << i))) {
mini/mini-amd64.c:					amd64_mov_reg_membase (code, i, cfg->frame_reg, save_area_offset, 8);
mini/mini-amd64.c:			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:				if (cfg->arch.stack_alloc_size)
mini/mini-amd64.c:					amd64_alu_reg_imm (code, X86_ADD, AMD64_RSP, cfg->arch.stack_alloc_size);
mini/mini-amd64.c:			offset = code - cfg->native_code;
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_METHOD_JUMP, call->method);
mini/mini-amd64.c:			if (cfg->compile_aot)
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			amd64_lea_membase (code, AMD64_R11, cfg->frame_reg, cfg->sig_cookie);
mini/mini-amd64.c:			else if ((cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) && (cfg->method->klass->image != mono_defaults.corlib)) {
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			} else if ((cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) && (cfg->method->klass->image != mono_defaults.corlib)) {
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			MonoInst *var = cfg->dyn_call_var;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			MonoInst *lmf_var = cfg->lmf_var;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			if (cfg->param_area)
mini/mini-amd64.c:				amd64_alu_reg_imm (code, X86_ADD, ins->dreg, cfg->param_area);
mini/mini-amd64.c:			if (cfg->param_area)
mini/mini-amd64.c:				amd64_alu_reg_imm (code, X86_ADD, ins->dreg, cfg->param_area);
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_target_bb);
mini/mini-amd64.c:				cfg->param_area) {
mini/mini-amd64.c:				amd64_alu_reg_imm (code, X86_SUB, AMD64_RSP, ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-amd64.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-amd64.c:					amd64_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
mini/mini-amd64.c:					if ((cfg->opt & MONO_OPT_BRANCH) &&
mini/mini-amd64.c:				if (cfg->r4fp)
mini/mini-amd64.c:				if (!cfg->r4fp)
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (!cfg->r4fp)
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_GC_CARD_TABLE_ADDR, card_table);
mini/mini-amd64.c:				if (cfg->r4fp)
mini/mini-amd64.c:				if (cfg->r4fp)
mini/mini-amd64.c:				if (cfg->r4fp)
mini/mini-amd64.c:				if (cfg->r4fp)
mini/mini-amd64.c:			if (!cfg->r4fp)
mini/mini-amd64.c:			if (cfg->r4fp) {
mini/mini-amd64.c:			if (cfg->verbose_level > 1)
mini/mini-amd64.c:				printf ("R%d START=0x%x\n", MONO_VARINFO (cfg, ins->inst_c0)->vreg, (int)(code - cfg->native_code));
mini/mini-amd64.c:			MONO_VARINFO (cfg, ins->inst_c0)->live_range_start = code - cfg->native_code;
mini/mini-amd64.c:			if (cfg->verbose_level > 1)
mini/mini-amd64.c:				printf ("R%d END=0x%x\n", MONO_VARINFO (cfg, ins->inst_c0)->vreg, (int)(code - cfg->native_code));
mini/mini-amd64.c:			MONO_VARINFO (cfg, ins->inst_c0)->live_range_end = code - cfg->native_code;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-amd64.c:			bb->spill_slot_defs = g_slist_prepend_mempool (cfg->mempool, bb->spill_slot_defs, ins);
mini/mini-amd64.c:		if ((code - cfg->native_code - offset) > max_len) {
mini/mini-amd64.c:				   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-amd64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-amd64.c:	if (cfg->method->save_lmf)
mini/mini-amd64.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-amd64.c:    if (mono_inject_async_exc_method && mono_method_desc_full_match (mono_inject_async_exc_method, cfg->method)) { \
mini/mini-amd64.c:         if (cfg->arch.async_point_count == mono_inject_async_exc_pos) \
mini/mini-amd64.c:         cfg->arch.async_point_count ++; \
mini/mini-amd64.c:	MonoMethod *method = cfg->method;
mini/mini-amd64.c:	MonoInst *lmf_var = cfg->lmf_var;
mini/mini-amd64.c:	cfg->code_size = MAX (cfg->header->code_size * 4, 1024);
mini/mini-amd64.c:	code = cfg->native_code = (unsigned char *)g_malloc (cfg->code_size);
mini/mini-amd64.c:	if (!cfg->arch.omit_fp) {
mini/mini-amd64.c:		mono_arch_unwindinfo_add_push_nonvol (&cfg->arch.unwindinfo, cfg->native_code, code, AMD64_RBP);
mini/mini-amd64.c:		mono_arch_unwindinfo_add_set_fpreg (&cfg->arch.unwindinfo, cfg->native_code, code, AMD64_RBP);
mini/mini-amd64.c:	if (cfg->param_area) {
mini/mini-amd64.c:		if (cfg->arch.omit_fp)
mini/mini-amd64.c:		cfg->stack_offset += ALIGN_TO (cfg->param_area, sizeof(mgreg_t));
mini/mini-amd64.c:	if (cfg->arch.omit_fp) {
mini/mini-amd64.c:		alloc_size = ALIGN_TO (cfg->stack_offset, 8);
mini/mini-amd64.c:		alloc_size = ALIGN_TO (cfg->stack_offset, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-amd64.c:		if (cfg->stack_offset != alloc_size) {
mini/mini-amd64.c:			mini_gc_set_slot_type_from_fp (cfg, -alloc_size + cfg->param_area, SLOT_NOREF);
mini/mini-amd64.c:		cfg->arch.sp_fp_offset = alloc_size;
mini/mini-amd64.c:	cfg->arch.stack_alloc_size = alloc_size;
mini/mini-amd64.c:		guint32 offset = code - cfg->native_code;
mini/mini-amd64.c:		if (G_UNLIKELY (required_code_size >= (cfg->code_size - offset))) {
mini/mini-amd64.c:			while (required_code_size >= (cfg->code_size - offset))
mini/mini-amd64.c:				cfg->code_size *= 2;
mini/mini-amd64.c:			cfg->native_code = (unsigned char *)mono_realloc_native_code (cfg);
mini/mini-amd64.c:			code = cfg->native_code + offset;
mini/mini-amd64.c:			cfg->stat_code_reallocs++;
mini/mini-amd64.c: 			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:			if (cfg->arch.omit_fp) 
mini/mini-amd64.c:				mono_arch_unwindinfo_add_alloc_stack (&cfg->arch.unwindinfo, cfg->native_code, code, 0x1000);
mini/mini-amd64.c: 			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:			if (cfg->arch.omit_fp) 
mini/mini-amd64.c:				mono_arch_unwindinfo_add_alloc_stack (&cfg->arch.unwindinfo, cfg->native_code, code, remaining_size);
mini/mini-amd64.c:		if (cfg->arch.omit_fp) {
mini/mini-amd64.c:	if (cfg->arch.omit_fp) {
mini/mini-amd64.c:		save_area_offset = cfg->arch.reg_save_area_offset;
mini/mini-amd64.c:		save_area_offset = cfg->arch.reg_save_area_offset;
mini/mini-amd64.c:		if (AMD64_IS_CALLEE_SAVED_REG (i) && (cfg->arch.saved_iregs & (1 << i))) {
mini/mini-amd64.c:			amd64_mov_membase_reg (code, cfg->frame_reg, save_area_offset, i, 8);
mini/mini-amd64.c:			if (cfg->arch.omit_fp) {
mini/mini-amd64.c:	if (cfg->rgctx_var) {
mini/mini-amd64.c:		g_assert (cfg->rgctx_var->opcode == OP_REGOFFSET &&
mini/mini-amd64.c:				(cfg->rgctx_var->inst_basereg == AMD64_RBP || cfg->rgctx_var->inst_basereg == AMD64_RSP));
mini/mini-amd64.c:		amd64_mov_membase_reg (code, cfg->rgctx_var->inst_basereg, cfg->rgctx_var->inst_offset, MONO_ARCH_RGCTX_REG, sizeof(gpointer));
mini/mini-amd64.c:		mono_add_var_location (cfg, cfg->rgctx_var, TRUE, MONO_ARCH_RGCTX_REG, 0, 0, code - cfg->native_code);
mini/mini-amd64.c:		mono_add_var_location (cfg, cfg->rgctx_var, FALSE, cfg->rgctx_var->inst_basereg, cfg->rgctx_var->inst_offset, code - cfg->native_code, 0);
mini/mini-amd64.c:	if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini-amd64.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-amd64.c:			if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-amd64.c:			if ((cfg->opt & MONO_OPT_LOOP) && bb_is_loop_start (bb))
mini/mini-amd64.c:			if (bb == cfg->bb_entry || bb == cfg->bb_exit)
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:		if (cfg->vret_addr && (cfg->vret_addr->opcode != OP_REGVAR))
mini/mini-amd64.c:			amd64_mov_membase_reg (code, cfg->vret_addr->inst_basereg, cfg->vret_addr->inst_offset, cinfo->ret.reg, 8);
mini/mini-amd64.c:		ins = cfg->args [i];
mini/mini-amd64.c:				if (ins == cfg->args [0]) {
mini/mini-amd64.c:					mono_add_var_location (cfg, ins, TRUE, ainfo->reg, 0, 0, code - cfg->native_code);
mini/mini-amd64.c:					mono_add_var_location (cfg, ins, FALSE, ins->inst_basereg, ins->inst_offset, code - cfg->native_code, 0);
mini/mini-amd64.c:			if (ins == cfg->args [0]) {
mini/mini-amd64.c:				mono_add_var_location (cfg, ins, TRUE, ainfo->reg, 0, 0, code - cfg->native_code);
mini/mini-amd64.c:				mono_add_var_location (cfg, ins, TRUE, ins->dreg, 0, code - cfg->native_code, 0);
mini/mini-amd64.c:	if (cfg->method->save_lmf)
mini/mini-amd64.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-amd64.c:		MonoBasicBlock *first_bb = cfg->bb_entry;
mini/mini-amd64.c:			ins = cfg->args [i];
mini/mini-amd64.c:	if (cfg->gen_sdb_seq_points) {
mini/mini-amd64.c:		MonoInst *info_var = (MonoInst *)cfg->arch.seq_point_info_var;
mini/mini-amd64.c:		if (cfg->compile_aot) {
mini/mini-amd64.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_SEQ_POINT_INFO, cfg->method);
mini/mini-amd64.c:		if (cfg->compile_aot) {
mini/mini-amd64.c:			ins = (MonoInst *)cfg->arch.ss_tramp_var;
mini/mini-amd64.c:			ins = (MonoInst *)cfg->arch.ss_tramp_var;
mini/mini-amd64.c:			ins = (MonoInst *)cfg->arch.bp_tramp_var;
mini/mini-amd64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-amd64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-amd64.c:	MonoMethod *method = cfg->method;
mini/mini-amd64.c:	gint32 lmf_offset = cfg->lmf_var ? ((MonoInst*)cfg->lmf_var)->inst_offset : -1;
mini/mini-amd64.c:	gint32 save_area_offset = cfg->arch.reg_save_area_offset;
mini/mini-amd64.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-amd64.c:		cfg->code_size *= 2;
mini/mini-amd64.c:		cfg->native_code = (unsigned char *)mono_realloc_native_code (cfg);
mini/mini-amd64.c:		cfg->stat_code_reallocs++;
mini/mini-amd64.c:	code = cfg->native_code + cfg->code_len;
mini/mini-amd64.c:	cfg->has_unwind_info_for_epilog = TRUE;
mini/mini-amd64.c:		if (!cfg->compile_aot && mono_arch_have_fast_tls () && mono_tls_get_tls_offset (TLS_KEY_JIT_TLS) != -1) {
mini/mini-amd64.c:		if (cfg->used_int_regs & (1 << AMD64_RBP)) {
mini/mini-amd64.c:			amd64_mov_reg_membase (code, AMD64_RBP, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, rbp), 8);
mini/mini-amd64.c:		if (AMD64_IS_CALLEE_SAVED_REG (i) && (cfg->arch.saved_iregs & (1 << i))) {
mini/mini-amd64.c:			int restore_reg=(cfg->used_int_regs & (1 << i));
mini/mini-amd64.c:				amd64_mov_reg_membase (code, i, cfg->frame_reg, save_area_offset, 8);
mini/mini-amd64.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-amd64.c:		MonoInst *inst = cfg->ret;
mini/mini-amd64.c:	if (cfg->arch.omit_fp) {
mini/mini-amd64.c:		if (cfg->arch.stack_alloc_size) {
mini/mini-amd64.c:			amd64_alu_reg_imm (code, X86_ADD, AMD64_RSP, cfg->arch.stack_alloc_size);
mini/mini-amd64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-amd64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-amd64.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-amd64.c:	while (cfg->code_len + code_size > (cfg->code_size - 16)) {
mini/mini-amd64.c:		cfg->code_size *= 2;
mini/mini-amd64.c:		cfg->native_code = (unsigned char *)mono_realloc_native_code (cfg);
mini/mini-amd64.c:		cfg->stat_code_reallocs++;
mini/mini-amd64.c:	code = cfg->native_code + cfg->code_len;
mini/mini-amd64.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-amd64.c:			amd64_patch (patch_info->ip.i + cfg->native_code, code);
mini/mini-amd64.c:				amd64_mov_reg_imm (code, AMD64_ARG_REG2, (exc_throw_end [i] - cfg->native_code) - throw_ip);
mini/mini-amd64.c:				amd64_mov_reg_imm (buf, AMD64_ARG_REG2, (code - cfg->native_code) - throw_ip);
mini/mini-amd64.c:		g_assert(code < cfg->native_code + cfg->code_size);
mini/mini-amd64.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-amd64.c:			pos = cfg->native_code + patch_info->ip.i;
mini/mini-amd64.c:			if (cfg->compile_aot)
mini/mini-amd64.c:			pos = cfg->native_code + patch_info->ip.i;
mini/mini-amd64.c:			if (patch_info == cfg->patch_info)
mini/mini-amd64.c:				cfg->patch_info = patch_info->next;
mini/mini-amd64.c:				for (tmp = cfg->patch_info; tmp->next != patch_info; tmp = tmp->next)
mini/mini-amd64.c:		g_assert (code < cfg->native_code + cfg->code_size);
mini/mini-amd64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-amd64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-amd64.c:		sig = mono_method_signature (cfg->method);
mini/mini-amd64.c:			inst = cfg->args [i];
mini/mini-amd64.c:	mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_METHODCONST, cfg->method);
mini/mini-amd64.c:	MonoMethod *method = cfg->method;
mini/mini-amd64.c:	mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_METHODCONST, method);
mini/mini-amd64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-amd64.c:		if (cfg->opt & MONO_OPT_CMOV) {
mini/mini-amd64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:	if (cfg->method->dynamic) {
mini/mini-arm.c:	cfg->thunk_area += THUNK_SIZE;
mini/mini-arm.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD,
mini/mini-arm.c:		if (*offset + *max_len > cfg->code_size) {
mini/mini-arm.c:			cfg->code_size += *max_len;
mini/mini-arm.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:			code = cfg->native_code + *offset;
mini/mini-arm.c:		*offset = code - cfg->native_code;
mini/mini-arm.c:	inst = (MonoInst *) cfg->arch.vfp_scratch_slots [reg == vfp_scratch1 ? 0 : 1];
mini/mini-arm.c:	inst = (MonoInst *) cfg->arch.vfp_scratch_slots [reg == vfp_scratch1 ? 0 : 1];
mini/mini-arm.c:		basereg = cfg->frame_reg;
mini/mini-arm.c:		code = emit_big_add (code, ARMREG_R2, cfg->frame_reg, lmf_offset);
mini/mini-arm.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-arm.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-arm.c:	if (cfg->flags & MONO_CFG_HAS_CALLS)
mini/mini-arm.c:		cfg->uses_rgctx_reg = TRUE;
mini/mini-arm.c:	if (cfg->arch.omit_fp)
mini/mini-arm.c:	if (!(cfg->compile_aot || cfg->uses_rgctx_reg || COMPILE_LLVM (cfg)))
mini/mini-arm.c:	if (cfg->arch.omit_fp_computed)
mini/mini-arm.c:	header = cfg->header;
mini/mini-arm.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm.c:	if (!cfg->arch.cinfo)
mini/mini-arm.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm.c:	cfg->arch.omit_fp = TRUE;
mini/mini-arm.c:	cfg->arch.omit_fp_computed = TRUE;
mini/mini-arm.c:	if (cfg->disable_omit_fp)
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:	if (cfg->method->save_lmf)
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:	if (cfg->param_area)
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-arm.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE))
mini/mini-arm.c:		cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:			cfg->arch.omit_fp = FALSE;
mini/mini-arm.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-arm.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-arm.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm.c:	if (!cfg->arch.cinfo)
mini/mini-arm.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm.c:	if (cfg->arch.omit_fp)
mini/mini-arm.c:		cfg->frame_reg = ARMREG_SP;
mini/mini-arm.c:		cfg->frame_reg = ARMREG_FP;
mini/mini-arm.c:	cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-arm.c:	if (mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method))
mini/mini-arm.c:		cfg->param_area = MAX (cfg->param_area, sizeof (gpointer)*8);
mini/mini-arm.c:	header = cfg->header;
mini/mini-arm.c:	if (cfg->flags & MONO_CFG_HAS_CALLS)
mini/mini-arm.c:		cfg->uses_rgctx_reg = TRUE;
mini/mini-arm.c:	if (cfg->frame_reg != ARMREG_SP)
mini/mini-arm.c:		cfg->used_int_regs |= 1 << cfg->frame_reg;
mini/mini-arm.c:	if (cfg->compile_aot || cfg->uses_rgctx_reg || COMPILE_LLVM (cfg))
mini/mini-arm.c:		cfg->used_int_regs |= (1 << MONO_ARCH_IMT_REG);
mini/mini-arm.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-arm.c:			cfg->ret->inst_c0 = ARMREG_R0;
mini/mini-arm.c:	offset += cfg->param_area;
mini/mini-arm.c:	if (cfg->flags & MONO_CFG_HAS_FPOUT)
mini/mini-arm.c:	if (mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method))
mini/mini-arm.c:		cfg->ret->opcode = OP_REGOFFSET;
mini/mini-arm.c:		cfg->ret->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:		cfg->ret->inst_offset = offset;
mini/mini-arm.c:		ins = cfg->vret_addr;
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-arm.c:			mono_print_ins (cfg->vret_addr);
mini/mini-arm.c:	if (cfg->arch.seq_point_info_var) {
mini/mini-arm.c:		ins = cfg->arch.seq_point_info_var;
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	if (cfg->arch.ss_trigger_page_var) {
mini/mini-arm.c:		ins = cfg->arch.ss_trigger_page_var;
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	if (cfg->arch.seq_point_ss_method_var) {
mini/mini-arm.c:		ins = cfg->arch.seq_point_ss_method_var;
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	if (cfg->arch.seq_point_bp_method_var) {
mini/mini-arm.c:		ins = cfg->arch.seq_point_bp_method_var;
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	if (cfg->has_atomic_exchange_i4 || cfg->has_atomic_cas_i4 || cfg->has_atomic_add_i4) {
mini/mini-arm.c:		cfg->arch.atomic_tmp_offset = offset;
mini/mini-arm.c:		cfg->arch.atomic_tmp_offset = -1;
mini/mini-arm.c:	cfg->locals_min_stack_offset = offset;
mini/mini-arm.c:	curinst = cfg->locals_start;
mini/mini-arm.c:	for (i = curinst; i < cfg->num_varinfo; ++i) {
mini/mini-arm.c:		ins = cfg->varinfo [i];
mini/mini-arm.c:		if (cfg->gsharedvt && mini_is_gsharedvt_variable_type (t))
mini/mini-arm.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	cfg->locals_max_stack_offset = offset;
mini/mini-arm.c:		ins = cfg->args [curinst];
mini/mini-arm.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:		cfg->sig_cookie = offset;
mini/mini-arm.c:		ins = cfg->args [curinst];
mini/mini-arm.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:			if (cfg->verbose_level >= 2)
mini/mini-arm.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-arm.c:	cfg->stack_offset = offset;
mini/mini-arm.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm.c:	if (!cfg->arch.cinfo)
mini/mini-arm.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm.c:			cfg->arch.vfp_scratch_slots [i] = (gpointer) inst;
mini/mini-arm.c:		cfg->ret_var_is_local = TRUE;
mini/mini-arm.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-arm.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-arm.c:			mono_print_ins (cfg->vret_addr);
mini/mini-arm.c:	if (cfg->gen_sdb_seq_points) {
mini/mini-arm.c:		if (cfg->compile_aot) {
mini/mini-arm.c:			cfg->arch.seq_point_info_var = ins;
mini/mini-arm.c:			if (!cfg->soft_breakpoints) {
mini/mini-arm.c:				cfg->arch.ss_trigger_page_var = ins;
mini/mini-arm.c:		if (cfg->soft_breakpoints) {
mini/mini-arm.c:			cfg->arch.seq_point_ss_method_var = ins;
mini/mini-arm.c:			cfg->arch.seq_point_bp_method_var = ins;
mini/mini-arm.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm.c:	linfo = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));
mini/mini-arm.c:		cfg->exception_message = g_strdup_printf ("unknown ret conv (%d)", cinfo->ret.storage);
mini/mini-arm.c:		cfg->disable_llvm = TRUE;
mini/mini-arm.c:			cfg->exception_message = g_strdup_printf ("ainfo->storage (%d)", ainfo->storage);
mini/mini-arm.c:			cfg->disable_llvm = TRUE;
mini/mini-arm.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm.c:		if (!cfg->arch.vret_addr_loc) {
mini/mini-arm.c:			cfg->arch.vret_addr_loc = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/mini-arm.c:			((MonoInst*)cfg->arch.vret_addr_loc)->flags |= MONO_INST_VOLATILE;
mini/mini-arm.c:		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, ((MonoInst*)cfg->arch.vret_addr_loc)->dreg, call->vret_var->dreg);
mini/mini-arm.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:						cfg->param_area = MAX (cfg->param_area, 8);
mini/mini-arm.c:						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER4_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
mini/mini-arm.c:						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
mini/mini-arm.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:						MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:						cfg->param_area = MAX (cfg->param_area, 8);
mini/mini-arm.c:						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
mini/mini-arm.c:						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
mini/mini-arm.c:						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8 + 4));
mini/mini-arm.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-arm.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				cfg->param_area = MAX (cfg->param_area, 8);
mini/mini-arm.c:				MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
mini/mini-arm.c:				MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
mini/mini-arm.c:				MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 4));
mini/mini-arm.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				fad = mono_mempool_alloc0 (cfg->mempool, sizeof (FloatArgData));
mini/mini-arm.c:				call->float_args = g_slist_append_mempool (cfg->mempool, call->float_args, fad);
mini/mini-arm.c:			cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-arm.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-arm.c:				fad = mono_mempool_alloc0 (cfg->mempool, sizeof (FloatArgData));
mini/mini-arm.c:				call->float_args = g_slist_append_mempool (cfg->mempool, call->float_args, fad);
mini/mini-arm.c:				MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				ins->dreg = cfg->ret->dreg;
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:				MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm.c:				ins->dreg = cfg->ret->dreg;
mini/mini-arm.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm.c:	code = mono_arm_emit_load_imm (code, ARMREG_R0, (guint32)cfg->method);
mini/mini-arm.c:	MonoMethod *method = cfg->method;
mini/mini-arm.c:	int save_offset = cfg->param_area;
mini/mini-arm.c:	offset = code - cfg->native_code;
mini/mini-arm.c:	if (offset > (cfg->code_size - 16 * 4)) {
mini/mini-arm.c:		cfg->code_size *= 2;
mini/mini-arm.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:		code = cfg->native_code + offset;
mini/mini-arm.c:		ARM_STR_IMM (code, ARMREG_R0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_STR_IMM (code, ARMREG_R1, cfg->frame_reg, save_offset + 4);
mini/mini-arm.c:		ARM_STR_IMM (code, ARMREG_R0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_FSTS (code, ARM_VFP_F0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_FSTD (code, ARM_VFP_D0, cfg->frame_reg, save_offset);
mini/mini-arm.c:	code = mono_arm_emit_load_imm (code, ARMREG_R0, (guint32)cfg->method);
mini/mini-arm.c:		ARM_LDR_IMM (code, ARMREG_R0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_LDR_IMM (code, ARMREG_R1, cfg->frame_reg, save_offset + 4);
mini/mini-arm.c:		ARM_LDR_IMM (code, ARMREG_R0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_FLDS (code, ARM_VFP_F0, cfg->frame_reg, save_offset);
mini/mini-arm.c:		ARM_FLDD (code, ARM_VFP_D0, cfg->frame_reg, save_offset);
mini/mini-arm.c:	ARM_B_COND (code, (condcode), (code - cfg->native_code + ins->inst_true_bb->native_offset) & 0xffffff); \
mini/mini-arm.c:	mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb); \
mini/mini-arm.c: * to cfg->bb_exit as far as the big branch handling is concerned
mini/mini-arm.c:		mono_add_patch_info (cfg, code - cfg->native_code,   \
mini/mini-arm.c:					//static int c = 0; g_print ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-arm.c:				//static int c = 0; g_print ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-arm.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-arm.c:		 * save the current position in cfg->arch to avoid
mini/mini-arm.c:		if (!cfg->arch.thunks) {
mini/mini-arm.c:			cfg->arch.thunks = cfg->thunks;
mini/mini-arm.c:			cfg->arch.thunks_size = cfg->thunk_area;
mini/mini-arm.c:		thunks = cfg->arch.thunks;
mini/mini-arm.c:		thunks_size = cfg->arch.thunks_size;
mini/mini-arm.c:			g_print ("thunk failed %p->%p, thunk space=%d method %s", code, target, thunks_size, mono_method_full_name (cfg->method, TRUE));
mini/mini-arm.c:		cfg->arch.thunks += THUNK_SIZE;
mini/mini-arm.c:		cfg->arch.thunks_size -= THUNK_SIZE;
mini/mini-arm.c:			g_print ("thunk failed %p->%p, thunk space=%d method %s", code, target, thunks_size, cfg ? mono_method_full_name (cfg->method, TRUE) : mono_method_full_name (jinfo_get_method (ji), TRUE));
mini/mini-arm.c:		MonoInst *loc = cfg->arch.vret_addr_loc;
mini/mini-arm.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-arm.c:	if (cfg->verbose_level > 2)
mini/mini-arm.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
mini/mini-arm.c:		//MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
mini/mini-arm.c:		//	cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
mini/mini-arm.c:    if (mono_break_at_bb_method && mono_method_desc_full_match (mono_break_at_bb_method, cfg->method) && bb->block_num == mono_break_at_bb_bb_num) {
mini/mini-arm.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-arm.c:		offset = code - cfg->native_code;
mini/mini-arm.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-arm.c:			cfg->code_size *= 2;
mini/mini-arm.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:			code = cfg->native_code + offset;
mini/mini-arm.c:			g_assert (cfg->arch.atomic_tmp_offset != -1);
mini/mini-arm.c:			ARM_STR_IMM (code, tmpreg, cfg->frame_reg, cfg->arch.atomic_tmp_offset);
mini/mini-arm.c:				ARM_LDR_IMM (code, tmpreg, cfg->frame_reg, cfg->arch.atomic_tmp_offset);
mini/mini-arm.c:				if (cfg->r4fp) {
mini/mini-arm.c:				if (cfg->r4fp) {
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-arm.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-arm.c:			MonoInst *info_var = cfg->arch.seq_point_info_var;
mini/mini-arm.c:			MonoInst *ss_trigger_page_var = cfg->arch.ss_trigger_page_var;
mini/mini-arm.c:			MonoInst *ss_method_var = cfg->arch.seq_point_ss_method_var;
mini/mini-arm.c:			MonoInst *bp_method_var = cfg->arch.seq_point_bp_method_var;
mini/mini-arm.c:			if (cfg->soft_breakpoints) {
mini/mini-arm.c:				g_assert (!cfg->compile_aot);
mini/mini-arm.c:			if (cfg->compile_aot) {
mini/mini-arm.c:			if (!cfg->soft_breakpoints && !cfg->compile_aot) {
mini/mini-arm.c:				if (cfg->soft_breakpoints) {
mini/mini-arm.c:					if (cfg->compile_aot) {
mini/mini-arm.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-arm.c:			if (cfg->compile_aot) {
mini/mini-arm.c:				guint32 offset = code - cfg->native_code;
mini/mini-arm.c:				if (cfg->soft_breakpoints)
mini/mini-arm.c:			} else if (cfg->soft_breakpoints) {
mini/mini-arm.c:			if (cfg->r4fp) {
mini/mini-arm.c:			if (cfg->r4fp) {
mini/mini-arm.c:				if (cfg->r4fp) {
mini/mini-arm.c:					if (cfg->used_int_regs & (1 << i))
mini/mini-arm.c:				code = emit_big_add (code, ARMREG_IP, cfg->frame_reg, cfg->stack_usage + prev_sp_offset);
mini/mini-arm.c:			g_assert (!cfg->method->save_lmf);
mini/mini-arm.c:			code = emit_big_add (code, ARMREG_SP, cfg->frame_reg, cfg->stack_usage);
mini/mini-arm.c:				if (cfg->used_int_regs)
mini/mini-arm.c:					ARM_POP (code, cfg->used_int_regs);
mini/mini-arm.c:				ARM_POP (code, cfg->used_int_regs | (1 << ARMREG_LR));
mini/mini-arm.c:			mono_add_patch_info (cfg, (guint8*) code - cfg->native_code, MONO_PATCH_INFO_METHOD_JUMP, call->method);
mini/mini-arm.c:			if (cfg->compile_aot) {
mini/mini-arm.c:				cfg->thunk_area += THUNK_SIZE;
mini/mini-arm.c:			g_assert (cfg->sig_cookie < 128);
mini/mini-arm.c:			ARM_LDR_IMM (code, ARMREG_IP, cfg->frame_reg, cfg->sig_cookie);
mini/mini-arm.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD,
mini/mini-arm.c:			if (cfg->param_area)
mini/mini-arm.c:				code = emit_sub_imm (code, ARMREG_SP, ARMREG_SP, ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-arm.c:			MonoInst *var = cfg->dyn_call_var;
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-arm.c:			int param_area = ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-arm.c:			int param_area = ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-arm.c:			int param_area = ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_target_bb);
mini/mini-arm.c:			cfg->thunk_area += THUNK_SIZE;
mini/mini-arm.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-arm.c:				//x86_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
mini/mini-arm.c:			if (offset + max_len > (cfg->code_size - 16)) {
mini/mini-arm.c:				cfg->code_size += max_len;
mini/mini-arm.c:				cfg->code_size *= 2;
mini/mini-arm.c:				cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:				code = cfg->native_code + offset;
mini/mini-arm.c:			if (cfg->compile_aot) {
mini/mini-arm.c:			if (cfg->compile_aot) {
mini/mini-arm.c:				if (!cfg->r4fp)
mini/mini-arm.c:				if (!cfg->r4fp)
mini/mini-arm.c:			if (cfg->r4fp) {
mini/mini-arm.c:			if (cfg->r4fp) {
mini/mini-arm.c:			if (cfg->r4fp) {
mini/mini-arm.c:			MonoType *sig_ret = mini_get_underlying_type (mono_method_signature (cfg->method)->ret);
mini/mini-arm.c:				if (cfg->r4fp) {
mini/mini-arm.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm.c:			bb->spill_slot_defs = g_slist_prepend_mempool (cfg->mempool, bb->spill_slot_defs, ins);
mini/mini-arm.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, "mono_threads_state_poll");
mini/mini-arm.c:		if ((cfg->opt & MONO_OPT_BRANCH) && ((code - cfg->native_code - offset) > max_len)) {
mini/mini-arm.c:				   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-arm.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm.c: *   	param area             size is cfg->param_area
mini/mini-arm.c:	MonoMethod *method = cfg->method;
mini/mini-arm.c:	cfg->code_size = 256 + sig->param_count * 64;
mini/mini-arm.c:	code = cfg->native_code = g_malloc (cfg->code_size);
mini/mini-arm.c:	alloc_size = cfg->stack_offset;
mini/mini-arm.c:			if (cfg->used_int_regs)
mini/mini-arm.c:				ARM_PUSH (code, cfg->used_int_regs);
mini/mini-arm.c:			ARM_PUSH (code, cfg->used_int_regs | (1 << ARMREG_LR));
mini/mini-arm.c:			if (cfg->used_int_regs & (1 << i))
mini/mini-arm.c:			if ((cfg->used_int_regs & (1 << i))) {
mini/mini-arm.c:	cfg->stack_usage = alloc_size;
mini/mini-arm.c:	if (cfg->frame_reg != ARMREG_SP) {
mini/mini-arm.c:		ARM_MOV_REG_REG (code, cfg->frame_reg, ARMREG_SP);
mini/mini-arm.c:		mono_emit_unwind_op_def_cfa_reg (cfg, code, cfg->frame_reg);
mini/mini-arm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-arm.c:		if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-arm.c:		if (cfg->compile_aot)
mini/mini-arm.c:			code = mono_arm_emit_load_imm (code, ARMREG_R0, (guint32)cfg->method);
mini/mini-arm.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, "mono_arm_unaligned_stack");
mini/mini-arm.c:	if (cfg->rgctx_var) {
mini/mini-arm.c:		MonoInst *ins = cfg->rgctx_var;
mini/mini-arm.c:		inst = cfg->vret_addr;
mini/mini-arm.c:		g_assert (arm_is_imm12 (cfg->sig_cookie));
mini/mini-arm.c:		ARM_ADD_REG_IMM8 (code, ARMREG_IP, cfg->frame_reg, prev_sp_offset + cookie->offset);
mini/mini-arm.c:		ARM_STR_IMM (code, ARMREG_IP, cfg->frame_reg, cfg->sig_cookie);
mini/mini-arm.c:		inst = cfg->args [pos];
mini/mini-arm.c:		if (cfg->verbose_level > 2)
mini/mini-arm.c:			if (cfg->verbose_level > 2)
mini/mini-arm.c:	if (cfg->arch.seq_point_info_var) {
mini/mini-arm.c:		MonoInst *ins = cfg->arch.seq_point_info_var;
mini/mini-arm.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_SEQ_POINT_INFO, cfg->method);
mini/mini-arm.c:	if (!cfg->soft_breakpoints) {
mini/mini-arm.c:		MonoInst *info_var = cfg->arch.seq_point_info_var;
mini/mini-arm.c:		MonoInst *ss_trigger_page_var = cfg->arch.ss_trigger_page_var;
mini/mini-arm.c:	if (cfg->arch.seq_point_ss_method_var) {
mini/mini-arm.c:		MonoInst *ss_method_ins = cfg->arch.seq_point_ss_method_var;
mini/mini-arm.c:		MonoInst *bp_method_ins = cfg->arch.seq_point_bp_method_var;
mini/mini-arm.c:		if (cfg->compile_aot) {
mini/mini-arm.c:			MonoInst *info_var = cfg->arch.seq_point_info_var;
mini/mini-arm.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-arm.c:	MonoMethod *method = cfg->method;
mini/mini-arm.c:	if (cfg->method->save_lmf)
mini/mini-arm.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-arm.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-arm.c:		cfg->code_size *= 2;
mini/mini-arm.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:		cfg->stat_code_reallocs++;
mini/mini-arm.c:	code = cfg->native_code + cfg->code_len;
mini/mini-arm.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm.c:		MonoInst *ins = cfg->ret;
mini/mini-arm.c:		MonoInst *ins = cfg->ret;
mini/mini-arm.c:		code = emit_restore_lmf (cfg, code, cfg->stack_usage - lmf_offset);
mini/mini-arm.c:		while (!(cfg->used_int_regs & (1 << reg)) && reg < ARMREG_FP) {
mini/mini-arm.c:		code = emit_big_add (code, ARMREG_SP, cfg->frame_reg, cfg->stack_usage - lmf_offset + sp_adj);
mini/mini-arm.c:			if (cfg->used_int_regs & (1 << i))
mini/mini-arm.c:		if ((i = mono_arm_is_rotated_imm8 (cfg->stack_usage, &rot_amount)) >= 0) {
mini/mini-arm.c:			ARM_ADD_REG_IMM (code, ARMREG_SP, cfg->frame_reg, i, rot_amount);
mini/mini-arm.c:			code = mono_arm_emit_load_imm (code, ARMREG_IP, cfg->stack_usage);
mini/mini-arm.c:			ARM_ADD_REG_REG (code, ARMREG_SP, cfg->frame_reg, ARMREG_IP);
mini/mini-arm.c:		if (cfg->frame_reg != ARMREG_SP) {
mini/mini-arm.c:			if (cfg->used_int_regs) {
mini/mini-arm.c:				ARM_POP (code, cfg->used_int_regs);
mini/mini-arm.c:					if (cfg->used_int_regs & (1 << i))
mini/mini-arm.c:			ARM_POP (code, cfg->used_int_regs | (1 << ARMREG_PC));
mini/mini-arm.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-arm.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-arm.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-arm.c:		cfg->code_size *= 2;
mini/mini-arm.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm.c:		cfg->stat_code_reallocs++;
mini/mini-arm.c:	code = cfg->native_code + cfg->code_len;
mini/mini-arm.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-arm.c:			unsigned char *ip = patch_info->ip.i + cfg->native_code;
mini/mini-arm.c:			patch_info->ip.i = code - cfg->native_code;
mini/mini-arm.c:			cfg->thunk_area += THUNK_SIZE;
mini/mini-arm.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-arm.c:	mono_add_patch_info (cfg, code - cfg->native_code, patch_type, data);
mini/mini-arm64.c:	mono_add_patch_info_rel (cfg, code - cfg->native_code, patch_type, data, MONO_R_ARM64_IMM);
mini/mini-arm64.c:	mono_add_patch_info_rel (cfg, code - cfg->native_code, patch_type, data, MONO_R_ARM64_BL);
mini/mini-arm64.c:	cfg->thunk_area += THUNK_SIZE;
mini/mini-arm64.c:		mono_add_patch_info (cfg, code - cfg->native_code, patch_type, data);
mini/mini-arm64.c:		 * save the current position in cfg->arch to avoid
mini/mini-arm64.c:		if (!cfg->arch.thunks) {
mini/mini-arm64.c:			cfg->arch.thunks = cfg->thunks;
mini/mini-arm64.c:			cfg->arch.thunks_size = cfg->thunk_area;
mini/mini-arm64.c:		thunks = cfg->arch.thunks;
mini/mini-arm64.c:		thunks_size = cfg->arch.thunks_size;
mini/mini-arm64.c:			g_print ("thunk failed %p->%p, thunk space=%d method %s", code, target, thunks_size, mono_method_full_name (cfg->method, TRUE));
mini/mini-arm64.c:		cfg->arch.thunks += THUNK_SIZE;
mini/mini-arm64.c:		cfg->arch.thunks_size -= THUNK_SIZE;
mini/mini-arm64.c:			g_print ("thunk failed %p->%p, thunk space=%d method %s", code, target, thunks_size, cfg ? mono_method_full_name (cfg->method, TRUE) : mono_method_full_name (jinfo_get_method (ji), TRUE));
mini/mini-arm64.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-arm64.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-arm64.c:	/* r28 is reserved for cfg->arch.args_reg */
mini/mini-arm64.c:	MonoInst *ins = cfg->varinfo [vmv->idx];
mini/mini-arm64.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm64.c:	if (!cfg->arch.cinfo)
mini/mini-arm64.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm64.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm64.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/mini-arm64.c:		cfg->vret_addr->flags |= MONO_INST_VOLATILE;
mini/mini-arm64.c:	if (cfg->gen_sdb_seq_points) {
mini/mini-arm64.c:		if (cfg->compile_aot) {
mini/mini-arm64.c:			cfg->arch.seq_point_info_var = ins;
mini/mini-arm64.c:		cfg->arch.ss_tramp_var = ins;
mini/mini-arm64.c:		cfg->arch.bp_tramp_var = ins;
mini/mini-arm64.c:	if (cfg->method->save_lmf) {
mini/mini-arm64.c:		cfg->create_lmf_var = TRUE;
mini/mini-arm64.c:		cfg->lmf_ir = TRUE;
mini/mini-arm64.c:		cfg->lmf_ir_mono_lmf = TRUE;
mini/mini-arm64.c:	 * Compute cfg->stack_offset and update cfg->used_int_regs.
mini/mini-arm64.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm64.c:	if (!cfg->arch.cinfo)
mini/mini-arm64.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm64.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm64.c:	cfg->frame_reg = ARMREG_FP;
mini/mini-arm64.c:	cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-arm64.c:		g_assert (!(cfg->used_int_regs & (1 << ARMREG_R28)));
mini/mini-arm64.c:		cfg->arch.args_reg = ARMREG_R28;
mini/mini-arm64.c:		cfg->used_int_regs |= 1 << ARMREG_R28;
mini/mini-arm64.c:	if (cfg->method->save_lmf) {
mini/mini-arm64.c:		cfg->arch.saved_gregs_offset = offset;
mini/mini-arm64.c:			if ((MONO_ARCH_CALLEE_SAVED_REGS & (1 << i)) && (cfg->used_int_regs & (1 << i)))
mini/mini-arm64.c:		cfg->ret->opcode = OP_REGVAR;
mini/mini-arm64.c:		cfg->ret->dreg = cinfo->ret.reg;
mini/mini-arm64.c:		cfg->ret->opcode = OP_REGOFFSET;
mini/mini-arm64.c:		cfg->ret->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:		cfg->ret->inst_offset = offset;
mini/mini-arm64.c:		cfg->vret_addr->opcode = OP_REGOFFSET;
mini/mini-arm64.c:		cfg->vret_addr->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:		cfg->vret_addr->inst_offset = offset;
mini/mini-arm64.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-arm64.c:			mono_print_ins (cfg->vret_addr);
mini/mini-arm64.c:		ins = cfg->args [i];
mini/mini-arm64.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:			g_assert (cfg->arch.args_reg);
mini/mini-arm64.c:			ins->inst_basereg = cfg->arch.args_reg;
mini/mini-arm64.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:			if (cfg->verbose_level >= 2)
mini/mini-arm64.c:				ins->inst_basereg = cfg->arch.args_reg;
mini/mini-arm64.c:			g_assert (cfg->arch.args_reg);
mini/mini-arm64.c:			vtaddr->inst_basereg = cfg->arch.args_reg;
mini/mini-arm64.c:				ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:			vtaddr->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:	ins = cfg->arch.seq_point_info_var;
mini/mini-arm64.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:	ins = cfg->arch.ss_tramp_var;
mini/mini-arm64.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:	ins = cfg->arch.bp_tramp_var;
mini/mini-arm64.c:		ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-arm64.c:			ins = cfg->varinfo [i];
mini/mini-arm64.c:			ins->inst_basereg = cfg->frame_reg;
mini/mini-arm64.c:	cfg->stack_offset = offset;
mini/mini-arm64.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm64.c:	linfo = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));
mini/mini-arm64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm64.c:		else if (cfg->r4fp)
mini/mini-arm64.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm64.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm64.c:		if (!cfg->arch.vret_addr_loc) {
mini/mini-arm64.c:			cfg->arch.vret_addr_loc = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_LOCAL);
mini/mini-arm64.c:			((MonoInst*)cfg->arch.vret_addr_loc)->flags |= MONO_INST_VOLATILE;
mini/mini-arm64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, ((MonoInst*)cfg->arch.vret_addr_loc)->dreg, call->vret_var->dreg);
mini/mini-arm64.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-arm64.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, arg);
mini/mini-arm64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-arm64.c:	sig = mono_method_signature (cfg->method);
mini/mini-arm64.c:	if (!cfg->arch.cinfo)
mini/mini-arm64.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-arm64.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm64.c:		else if (cfg->r4fp)
mini/mini-arm64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_RMOVE, cfg->ret->dreg, val->dreg);
mini/mini-arm64.c:			MONO_EMIT_NEW_UNALU (cfg, OP_ARM_SETFREG_R4, cfg->ret->dreg, val->dreg);
mini/mini-arm64.c:	if (cfg->compile_aot && !cfg->full_aot)
mini/mini-arm64.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-arm64.c:	mono_add_patch_info_rel (cfg, code - cfg->native_code, MONO_PATCH_INFO_EXC, exc_name, MONO_R_ARM64_BCC);
mini/mini-arm64.c:		if (cfg->r4fp)
mini/mini-arm64.c:		MonoInst *loc = cfg->arch.vret_addr_loc;
mini/mini-arm64.c:		MonoInst *loc = cfg->arch.vret_addr_loc;
mini/mini-arm64.c: *   Emit a branch island for the conditional branches from cfg->native_code + start_offset to code.
mini/mini-arm64.c:	for (ji = cfg->patch_info; ji; ji = ji->next) {
mini/mini-arm64.c:		offset = code - cfg->native_code;
mini/mini-arm64.c:		if (offset > (cfg->code_size - island_size - 16)) {
mini/mini-arm64.c:			cfg->code_size *= 2;
mini/mini-arm64.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm64.c:			code = cfg->native_code + offset;
mini/mini-arm64.c:		for (ji = cfg->patch_info; ji; ji = ji->next) {
mini/mini-arm64.c:				arm_patch_rel (cfg->native_code + ji->ip.i, code, ji->relocation);
mini/mini-arm64.c:				ji->ip.i = code - cfg->native_code;
mini/mini-arm64.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-arm64.c:	if (cfg->verbose_level > 2)
mini/mini-arm64.c:	start_offset = code - cfg->native_code;
mini/mini-arm64.c:		offset = code - cfg->native_code;
mini/mini-arm64.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-arm64.c:			cfg->code_size *= 2;
mini/mini-arm64.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm64.c:			code = cfg->native_code + offset;
mini/mini-arm64.c:		if (G_UNLIKELY (cfg->arch.cond_branch_islands && offset - start_offset > 4 * 0x1ffff)) {
mini/mini-arm64.c:			offset = code - cfg->native_code;
mini/mini-arm64.c:			if (cfg->param_area)
mini/mini-arm64.c:				code = emit_subx_sp_imm (code, cfg->param_area);
mini/mini-arm64.c:			if (cfg->param_area)
mini/mini-arm64.c:				code = emit_subx_sp_imm (code, cfg->param_area);
mini/mini-arm64.c:			MonoInst *info_var = cfg->arch.seq_point_info_var;
mini/mini-arm64.c:			if (cfg->compile_aot) {
mini/mini-arm64.c:				MonoInst *var = cfg->arch.ss_tramp_var;
mini/mini-arm64.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-arm64.c:			if (cfg->compile_aot) {
mini/mini-arm64.c:				guint32 offset = code - cfg->native_code;
mini/mini-arm64.c:				MonoInst *var = cfg->arch.bp_tramp_var;
mini/mini-arm64.c:			offset = code - cfg->native_code;
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			if (cfg->r4fp) {
mini/mini-arm64.c:			g_assert (!cfg->method->save_lmf);
mini/mini-arm64.c:			code = emit_load_regset (code, MONO_ARCH_CALLEE_SAVED_REGS & cfg->used_int_regs, ARMREG_FP, cfg->arch.saved_gregs_offset);
mini/mini-arm64.c:			code = mono_arm_emit_destroy_frame (code, cfg->stack_offset, ((1 << ARMREG_IP0) | (1 << ARMREG_IP1)));
mini/mini-arm64.c:			if (cfg->compile_aot) {
mini/mini-arm64.c:				mono_add_patch_info_rel (cfg, code - cfg->native_code, MONO_PATCH_INFO_METHOD_JUMP, call->method, MONO_R_ARM64_B);
mini/mini-arm64.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-arm64.c:			g_assert (cfg->arch.cinfo);
mini/mini-arm64.c:			code = emit_addx_imm (code, ARMREG_IP0, cfg->arch.args_reg, ((CallInfo*)cfg->arch.cinfo)->sig_cookie.offset);
mini/mini-arm64.c:			MonoInst *var = cfg->dyn_call_var;
mini/mini-arm64.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-arm64.c:			cfg->thunk_area += THUNK_SIZE;
mini/mini-arm64.c:			if (cfg->param_area)
mini/mini-arm64.c:				code = emit_subx_sp_imm (code, cfg->param_area);
mini/mini-arm64.c:			if (cfg->param_area)
mini/mini-arm64.c:				code = emit_addx_sp_imm (code, cfg->param_area);
mini/mini-arm64.c:		if ((cfg->opt & MONO_OPT_BRANCH) && ((code - cfg->native_code - offset) > max_len)) {
mini/mini-arm64.c:				   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-arm64.c:	if (cfg->arch.cond_branch_islands)
mini/mini-arm64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm64.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm64.c:		ins = cfg->args [i];
mini/mini-arm64.c:						code = emit_ldrsbx (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:						code = emit_ldrb (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:						code = emit_ldrshx (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:						code = emit_ldrh (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:						code = emit_ldrswx (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:						code = emit_ldrw (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:					code = emit_ldrx (code, ins->dreg, cfg->arch.args_reg, ainfo->offset);
mini/mini-arm64.c:	MonoMethod *method = cfg->method;
mini/mini-arm64.c:	cfg->code_size = 256 + sig->param_count * 64;
mini/mini-arm64.c:	code = cfg->native_code = g_malloc (cfg->code_size);
mini/mini-arm64.c:	cfg->stack_offset = ALIGN_TO (cfg->stack_offset, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-arm64.c:	if (arm_is_ldpx_imm (-cfg->stack_offset)) {
mini/mini-arm64.c:		arm_stpx_pre (code, ARMREG_FP, ARMREG_LR, ARMREG_SP, -cfg->stack_offset);
mini/mini-arm64.c:		/* sp -= cfg->stack_offset */
mini/mini-arm64.c:		code = emit_subx_sp_imm (code, cfg->stack_offset);
mini/mini-arm64.c:	cfa_offset += cfg->stack_offset;
mini/mini-arm64.c:	if (cfg->param_area) {
mini/mini-arm64.c:		code = emit_subx_sp_imm (code, cfg->param_area);
mini/mini-arm64.c:	if (cfg->method->save_lmf) {
mini/mini-arm64.c:		code = emit_setup_lmf (cfg, code, cfg->lmf_var->inst_offset, cfa_offset);
mini/mini-arm64.c:		code = emit_store_regset_cfa (cfg, code, MONO_ARCH_CALLEE_SAVED_REGS & cfg->used_int_regs, ARMREG_FP, cfg->arch.saved_gregs_offset, cfa_offset, 0);
mini/mini-arm64.c:	if (cfg->arch.args_reg) {
mini/mini-arm64.c:		code = emit_addx_imm (code, cfg->arch.args_reg, ARMREG_FP, cfg->stack_offset);
mini/mini-arm64.c:	if (cfg->vret_addr) {
mini/mini-arm64.c:		MonoInst *ins = cfg->vret_addr;
mini/mini-arm64.c:	if (cfg->rgctx_var) {
mini/mini-arm64.c:		MonoInst *ins = cfg->rgctx_var;
mini/mini-arm64.c:	if (cfg->arch.seq_point_info_var) {
mini/mini-arm64.c:		MonoInst *ins = cfg->arch.seq_point_info_var;
mini/mini-arm64.c:		code = emit_aotconst (cfg, code, ARMREG_IP0, MONO_PATCH_INFO_SEQ_POINT_INFO, cfg->method);
mini/mini-arm64.c:		ins = cfg->arch.ss_tramp_var;
mini/mini-arm64.c:		if (cfg->arch.ss_tramp_var) {
mini/mini-arm64.c:			ins = cfg->arch.ss_tramp_var;
mini/mini-arm64.c:		if (cfg->arch.bp_tramp_var) {
mini/mini-arm64.c:			ins = cfg->arch.bp_tramp_var;
mini/mini-arm64.c:	if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini-arm64.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-arm64.c:		cfg->arch.cond_branch_islands = TRUE;
mini/mini-arm64.c:	while (cfg->code_len + size > (cfg->code_size - 16)) {
mini/mini-arm64.c:		cfg->code_size *= 2;
mini/mini-arm64.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-arm64.c:		cfg->stat_code_reallocs++;
mini/mini-arm64.c:	return cfg->native_code + cfg->code_len;
mini/mini-arm64.c:	if (cfg->method->save_lmf) {
mini/mini-arm64.c:		code = mono_arm_emit_load_regarray (code, MONO_ARCH_CALLEE_SAVED_REGS & cfg->used_int_regs, ARMREG_FP, cfg->lmf_var->inst_offset + MONO_STRUCT_OFFSET (MonoLMF, gregs) - (MONO_ARCH_FIRST_LMF_REG * 8));
mini/mini-arm64.c:		code = emit_load_regset (code, MONO_ARCH_CALLEE_SAVED_REGS & cfg->used_int_regs, ARMREG_FP, cfg->arch.saved_gregs_offset);
mini/mini-arm64.c:	cinfo = cfg->arch.cinfo;
mini/mini-arm64.c:		MonoInst *ins = cfg->ret;
mini/mini-arm64.c:		MonoInst *ins = cfg->ret;
mini/mini-arm64.c:	code = mono_arm_emit_destroy_frame (code, cfg->stack_offset, ((1 << ARMREG_IP0) | (1 << ARMREG_IP1)));
mini/mini-arm64.c:	g_assert (code - (cfg->native_code + cfg->code_len) < max_epilog_size);
mini/mini-arm64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm64.c:	for (ji = cfg->patch_info; ji; ji = ji->next) {
mini/mini-arm64.c:	for (ji = cfg->patch_info; ji; ji = ji->next) {
mini/mini-arm64.c:		ip = cfg->native_code + ji->ip.i;
mini/mini-arm64.c:		ji->ip.i = code - cfg->native_code;
mini/mini-arm64.c:		cfg->thunk_area += THUNK_SIZE;
mini/mini-arm64.c:	cfg->code_len = code - cfg->native_code;
mini/mini-arm64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-codegen.c:#define DEBUG(a) MINI_DEBUG(cfg->verbose_level, 3, a;)
mini/mini-codegen.c:		call->out_freg_args = g_slist_append_mempool (cfg->mempool, call->out_freg_args, (gpointer)(gssize)(regpair));
mini/mini-codegen.c:		call->out_ireg_args = g_slist_append_mempool (cfg->mempool, call->out_ireg_args, (gpointer)(gssize)(regpair));
mini/mini-codegen.c:	call->outarg_vts = g_slist_append_mempool (cfg->mempool, call->outarg_vts, outarg_vt);
mini/mini-codegen.c:	MonoSpillInfo *orig_info = cfg->spill_info [bank];
mini/mini-codegen.c:	int orig_len = cfg->spill_info_len [bank];
mini/mini-codegen.c:	new_info = (MonoSpillInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoSpillInfo) * new_len);
mini/mini-codegen.c:	cfg->spill_info [bank] = new_info;
mini/mini-codegen.c:	cfg->spill_info_len [bank] = new_len;
mini/mini-codegen.c:	if (G_UNLIKELY (spillvar >= (cfg->spill_info_len [bank]))) {
mini/mini-codegen.c:		while (spillvar >= cfg->spill_info_len [bank])
mini/mini-codegen.c:	info = &cfg->spill_info [bank][spillvar];
mini/mini-codegen.c:		cfg->stack_offset += sizeof (mgreg_t) - 1;
mini/mini-codegen.c:		cfg->stack_offset &= ~(sizeof (mgreg_t) - 1);
mini/mini-codegen.c:		if (cfg->flags & MONO_CFG_HAS_SPILLUP) {
mini/mini-codegen.c:			cfg->stack_offset += size - 1;
mini/mini-codegen.c:			cfg->stack_offset &= ~(size - 1);
mini/mini-codegen.c:			info->offset = cfg->stack_offset;
mini/mini-codegen.c:			cfg->stack_offset += size;
mini/mini-codegen.c:			cfg->stack_offset += size - 1;
mini/mini-codegen.c:			cfg->stack_offset &= ~(size - 1);
mini/mini-codegen.c:			cfg->stack_offset += size;
mini/mini-codegen.c:			info->offset = - cfg->stack_offset;
mini/mini-codegen.c:	MonoRegState *rs = cfg->rs;
mini/mini-codegen.c:	bank = translate_bank (cfg->rs, bank, sel);
mini/mini-codegen.c:	spill = ++cfg->spill_count;
mini/mini-codegen.c:	load->inst_basereg = cfg->frame_reg;
mini/mini-codegen.c:	MonoRegState *rs = cfg->rs;
mini/mini-codegen.c:				bank = translate_bank (cfg->rs, bank, sel);
mini/mini-codegen.c:		spill = ++cfg->spill_count;
mini/mini-codegen.c:		spill = ++cfg->spill_count;
mini/mini-codegen.c:	load->inst_basereg = cfg->frame_reg;
mini/mini-codegen.c:		if (!(cfg->rs->free_mask [bank] & (regmask (hreg)))) {
mini/mini-codegen.c:			bank = translate_bank (cfg->rs, bank, hreg);
mini/mini-codegen.c:			DEBUG (printf ("\tforced spill of R%d\n", cfg->rs->symbolic [bank] [hreg]));
mini/mini-codegen.c:			spill_vreg (cfg, bb, last, ins, cfg->rs->symbolic [bank] [hreg], bank);
mini/mini-codegen.c:		if (!(cfg->rs->ifree_mask & (regmask (hreg)))) {
mini/mini-codegen.c:			DEBUG (printf ("\tforced spill of R%d\n", cfg->rs->isymbolic [hreg]));
mini/mini-codegen.c:			spill_vreg (cfg, bb, last, ins, cfg->rs->isymbolic [hreg], bank);
mini/mini-codegen.c:	store->inst_destbasereg = cfg->frame_reg;
mini/mini-codegen.c:	if (((bank == MONO_REG_INT_REF) || (bank == MONO_REG_INT_MP)) && cfg->compute_gc_maps) {
mini/mini-codegen.c:		val = mono_regstate_alloc_int (cfg->rs, info->preferred_mask & dest_mask);
mini/mini-codegen.c:	val = mono_regstate_alloc_int (cfg->rs, dest_mask);
mini/mini-codegen.c:	val = mono_regstate_alloc_general (cfg->rs, dest_mask, bank);
mini/mini-codegen.c:	MonoRegState *rs = cfg->rs;
mini/mini-codegen.c:	if (cfg->reginfo && cfg->reginfo_len < max)
mini/mini-codegen.c:		cfg->reginfo = NULL;
mini/mini-codegen.c:	reginfo = (RegTrack *)cfg->reginfo;
mini/mini-codegen.c:		cfg->reginfo_len = MAX (1024, max * 2);
mini/mini-codegen.c:		reginfo = (RegTrack *)mono_mempool_alloc (cfg->mempool, sizeof (RegTrack) * cfg->reginfo_len);
mini/mini-codegen.c:		cfg->reginfo = reginfo;
mini/mini-codegen.c:		g_assert (cfg->reginfo_len >= rs->next_vreg);
mini/mini-codegen.c:	if (cfg->verbose_level > 1) {
mini/mini-codegen.c:		memset (cfg->reginfo, 0, cfg->reginfo_len * sizeof (RegTrack));
mini/mini-codegen.c:	/*if (cfg->opt & MONO_OPT_COPYPROP)
mini/mini-codegen.c:				int translated_bank = translate_bank (cfg->rs, bank, dest_dreg);
mini/mini-codegen.c:			if (G_UNLIKELY (cfg->verbose_level >= 2)) {
mini/mini-codegen.c:		if (sp && bb != cfg->bb_exit && !(bb->out_count == 1 && bb->out_bb [0] == cfg->bb_exit)) {
mini/mini-gc.c:	if (cfg->compile_aot) {
mini/mini-gc.c:				printf ("LAST: %s\n", mono_method_full_name (cfg->method, TRUE));
mini/mini-gc.c:	cfg->compute_gc_maps = TRUE;
mini/mini-gc.c:	cfg->gc_info = mono_mempool_alloc0 (cfg->mempool, sizeof (MonoCompileGC));
mini/mini-gc.c:	MonoCompileGC *gcfg = (MonoCompileGC*)cfg->gc_info;
mini/mini-gc.c:	if (!cfg->compute_gc_maps)
mini/mini-gc.c:	gcfg->stack_slots_from_fp = g_slist_prepend_mempool (cfg->mempool, gcfg->stack_slots_from_fp, GINT_TO_POINTER (((slot_offset) << 16) | type));
mini/mini-gc.c:	MonoCompileGC *gcfg = (MonoCompileGC*)cfg->gc_info;
mini/mini-gc.c:	if (!cfg->compute_gc_maps)
mini/mini-gc.c:	gcfg->stack_slots_from_cfa = g_slist_prepend_mempool (cfg->mempool, gcfg->stack_slots_from_cfa, GUINT_TO_POINTER (((slot) << 16) | type));
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	return (offset - gcfg->min_offset) / SIZEOF_SLOT;
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	return (slot * SIZEOF_SLOT) + gcfg->min_offset;
mini/mini-gc.c:	g_assert (slot >= 0 && slot < gcfg->nslots);
mini/mini-gc.c:		clear_bit (gcfg->stack_ref_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		set_bit (gcfg->stack_pin_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		set_bit (gcfg->stack_ref_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->stack_pin_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->stack_ref_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->stack_pin_bitmap, gcfg->stack_bitmap_width, slot, callsite_index);
mini/mini-gc.c:	for (cindex = 0; cindex < gcfg->ncallsites; ++cindex)
mini/mini-gc.c:	ref_bitmap = gcfg->stack_ref_bitmap;
mini/mini-gc.c:	pin_bitmap = gcfg->stack_pin_bitmap;
mini/mini-gc.c:	width = gcfg->stack_bitmap_width;
mini/mini-gc.c:	for (cindex = 0; cindex < gcfg->ncallsites; ++cindex) {
mini/mini-gc.c:		int callsite_offset = gcfg->callsites [cindex]->pc_offset;
mini/mini-gc.c:	g_assert (slot >= 0 && slot < gcfg->nregs);
mini/mini-gc.c:		clear_bit (gcfg->reg_ref_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		set_bit (gcfg->reg_pin_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		set_bit (gcfg->reg_ref_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->reg_pin_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->reg_ref_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:		clear_bit (gcfg->reg_pin_bitmap, gcfg->reg_bitmap_width, slot, callsite_index);
mini/mini-gc.c:	for (cindex = 0; cindex < gcfg->ncallsites; ++cindex)
mini/mini-gc.c:	for (cindex = 0; cindex < gcfg->ncallsites; ++cindex) {
mini/mini-gc.c:		int callsite_offset = gcfg->callsites [cindex]->pc_offset;
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-gc.c:			int offset = cfg->spill_info [bank][spill_slot].offset;
mini/mini-gc.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-gc.c:			int offset = cfg->spill_info [bank][spill_slot].offset;
mini/mini-gc.c:			if (cfg->verbose_level > 1)
mini/mini-gc.c:	for (i = 0; i < cfg->spill_info_len [MONO_REG_DOUBLE]; ++i) {
mini/mini-gc.c:		int offset = cfg->spill_info [MONO_REG_DOUBLE][i].offset;
mini/mini-gc.c:		if (cfg->verbose_level > 1)
mini/mini-gc.c:	for (i = 0; i < cfg->spill_info_len [MONO_REG_INT]; ++i) {
mini/mini-gc.c:		int offset = cfg->spill_info [MONO_REG_INT][i].offset;
mini/mini-gc.c:		if (cfg->verbose_level > 1)
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	for (l = gcfg->stack_slots_from_cfa; l; l = l->next) {
mini/mini-gc.c:		slot = (cfg->cfa_offset / SIZEOF_SLOT) - cfa_slot - (gcfg->min_offset / SIZEOF_SLOT);
mini/mini-gc.c:		if (cfg->verbose_level > 1) {
mini/mini-gc.c:	for (l = gcfg->stack_slots_from_fp; l; l = l->next) {
mini/mini-gc.c:		if (cfg->verbose_level > 1) {
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	MonoMethodSignature *sig = mono_method_signature (cfg->method);
mini/mini-gc.c:	int locals_min_offset = gcfg->locals_min_offset;
mini/mini-gc.c:	int locals_max_offset = gcfg->locals_max_offset;
mini/mini-gc.c:	locals_min_slot = (locals_min_offset - gcfg->min_offset) / SIZEOF_SLOT;
mini/mini-gc.c:	locals_max_slot = (locals_max_offset - gcfg->min_offset) / SIZEOF_SLOT;
mini/mini-gc.c:	pc_offsets = g_new0 (int, cfg->next_vreg);
mini/mini-gc.c:	bb = cfg->bb_entry->next_bb;
mini/mini-gc.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-gc.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-gc.c:		gboolean is_arg = i < cfg->locals_start;
mini/mini-gc.c:		if (ins == cfg->ret) {
mini/mini-gc.c:		if (sig->hasthis && ins == cfg->args [0] && !cfg->method->klass->valuetype) {
mini/mini-gc.c:			t = &cfg->method->klass->byval_arg;
mini/mini-gc.c:				for (cindex = 0; cindex < gcfg->ncallsites; ++cindex)
mini/mini-gc.c:					if (gcfg->callsites [cindex]->liveness [i / 8] & (1 << (i % 8)))
mini/mini-gc.c:			if (cfg->verbose_level > 1) {
mini/mini-gc.c:			if (cfg->verbose_level > 1) {
mini/mini-gc.c:			if (cfg->verbose_level > 1)
mini/mini-gc.c:				for (cindex = 0; cindex < gcfg->ncallsites; ++cindex) {
mini/mini-gc.c:					if (gcfg->callsites [cindex]->pc_offset > pc_offsets [vmv->vreg]) {
mini/mini-gc.c:				if (cfg->verbose_level > 1) {
mini/mini-gc.c:				if (cfg->verbose_level > 1)
mini/mini-gc.c:		if (!is_arg && (ins->inst_offset < gcfg->min_offset || ins->inst_offset >= gcfg->max_offset))
mini/mini-gc.c:				for (cindex = 0; cindex < gcfg->ncallsites; ++cindex)
mini/mini-gc.c:					if (gcfg->callsites [cindex]->liveness [i / 8] & (1 << (i % 8)))
mini/mini-gc.c:			if (cfg->verbose_level > 1)
mini/mini-gc.c:			if (cfg->verbose_level > 1)
mini/mini-gc.c:				if (cfg->verbose_level > 1)
mini/mini-gc.c:				set_slot_in_range (gcfg, pos, pc_offsets [vmv->vreg], cfg->code_size, SLOT_REF);
mini/mini-gc.c:			if (cfg->verbose_level > 1)
mini/mini-gc.c:			for (cindex = 0; cindex < gcfg->ncallsites; ++cindex)
mini/mini-gc.c:				if (gcfg->callsites [cindex]->liveness [i / 8] & (1 << (i % 8)))
mini/mini-gc.c:		if (cfg->verbose_level > 1) {
mini/mini-gc.c:	g_assert (cfg->frame_reg == AMD64_RBP);
mini/mini-gc.c:	return (- cfg->arch.sp_fp_offset + sp_offset);
mini/mini-gc.c:	g_assert (cfg->frame_reg == X86_EBP);
mini/mini-gc.c:	return (- cfg->arch.sp_fp_offset + sp_offset);
mini/mini-gc.c:	return (- cfg->arch.sp_fp_offset - sp_offset);	
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-gc.c:	is_param = mono_mempool_alloc0 (cfg->mempool, gcfg->nslots * sizeof (gboolean));
mini/mini-gc.c:	for (cindex = 0; cindex < gcfg->ncallsites; ++cindex) {
mini/mini-gc.c:		GCCallSite *callsite = gcfg->callsites [cindex];
mini/mini-gc.c:				g_assert (slot + i >= 0 && slot + i < gcfg->nslots);
mini/mini-gc.c:	for (i = 0; i < gcfg->nslots; ++i) {
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	ncallsites = gcfg->ncallsites;
mini/mini-gc.c:	nslots = gcfg->nslots;
mini/mini-gc.c:	nregs = gcfg->nregs;
mini/mini-gc.c:	callsites = gcfg->callsites;
mini/mini-gc.c:	for (i = 0; i < cfg->header->num_clauses; ++i) {
mini/mini-gc.c:		MonoExceptionClause *clause = &cfg->header->clauses [i];
mini/mini-gc.c:		if (cfg->verbose_level > 1)
mini/mini-gc.c:			for (i = 0; i < cfg->header->num_clauses; ++i) {
mini/mini-gc.c:				clause = &cfg->header->clauses [i];
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	MonoMethodSignature *sig = mono_method_signature (cfg->method);
mini/mini-gc.c:	locals_min_offset = ALIGN_TO (cfg->locals_min_stack_offset, SIZEOF_SLOT);
mini/mini-gc.c:	locals_max_offset = cfg->locals_max_stack_offset;
mini/mini-gc.c:		MonoInst *ins = cfg->args [i];
mini/mini-gc.c:	g_assert (cfg->frame_reg == cfg->cfa_reg);
mini/mini-gc.c:	g_assert (cfg->cfa_offset > 0);
mini/mini-gc.c:	cfa_max_offset = cfg->cfa_offset;
mini/mini-gc.c:	for (l = gcfg->stack_slots_from_fp; l; l = l->next) {
mini/mini-gc.c:	if (!(cfg->flags & MONO_CFG_HAS_SPILLUP)) {
mini/mini-gc.c:		int stack_offset = ALIGN_TO (cfg->stack_offset, SIZEOF_SLOT);
mini/mini-gc.c:	min_offset = MIN (min_offset, -cfg->arch.sp_fp_offset);
mini/mini-gc.c:	min_offset = MIN (min_offset, -cfg->arch.sp_fp_offset);
mini/mini-gc.c:	min_offset = MIN (min_offset, - (cfg->arch.sp_fp_offset + cfg->arch.param_area_size));
mini/mini-gc.c:	gcfg->min_offset = min_offset;
mini/mini-gc.c:	gcfg->max_offset = max_offset;
mini/mini-gc.c:	gcfg->locals_min_offset = locals_min_offset;
mini/mini-gc.c:	gcfg->locals_max_offset = locals_max_offset;
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-gc.c:	callsites = mono_mempool_alloc0 (cfg->mempool, ncallsites * sizeof (GCCallSite*));
mini/mini-gc.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-gc.c:	if (cfg->verbose_level > 1)
mini/mini-gc.c:		printf ("GC Map for %s: 0x%x-0x%x\n", mono_method_full_name (cfg->method, TRUE), gcfg->min_offset, gcfg->max_offset);
mini/mini-gc.c:	nslots = (gcfg->max_offset - gcfg->min_offset) / SIZEOF_SLOT;
mini/mini-gc.c:	gcfg->nslots = nslots;
mini/mini-gc.c:	gcfg->nregs = nregs;
mini/mini-gc.c:	gcfg->callsites = callsites;
mini/mini-gc.c:	gcfg->ncallsites = ncallsites;
mini/mini-gc.c:	gcfg->stack_bitmap_width = ALIGN_TO (ncallsites, 8) / 8;
mini/mini-gc.c:	gcfg->reg_bitmap_width = ALIGN_TO (ncallsites, 8) / 8;
mini/mini-gc.c:	gcfg->stack_ref_bitmap = mono_mempool_alloc0 (cfg->mempool, gcfg->stack_bitmap_width * nslots);
mini/mini-gc.c:	gcfg->stack_pin_bitmap = mono_mempool_alloc0 (cfg->mempool, gcfg->stack_bitmap_width * nslots);
mini/mini-gc.c:	gcfg->reg_ref_bitmap = mono_mempool_alloc0 (cfg->mempool, gcfg->reg_bitmap_width * nregs);
mini/mini-gc.c:	gcfg->reg_pin_bitmap = mono_mempool_alloc0 (cfg->mempool, gcfg->reg_bitmap_width * nregs);
mini/mini-gc.c:	memset (gcfg->stack_pin_bitmap, 0xff, gcfg->stack_bitmap_width * nregs);
mini/mini-gc.c:		if ((cfg->used_int_regs & (1 << i)))
mini/mini-gc.c:	MonoCompileGC *gcfg = cfg->gc_info;
mini/mini-gc.c:	ncallsites = gcfg->ncallsites;
mini/mini-gc.c:	nslots = gcfg->nslots;
mini/mini-gc.c:	nregs = gcfg->nregs;
mini/mini-gc.c:	callsites = gcfg->callsites;
mini/mini-gc.c:		if (has_bit_set (gcfg->stack_pin_bitmap, gcfg->stack_bitmap_width, i))
mini/mini-gc.c:		if (has_bit_set (gcfg->stack_ref_bitmap, gcfg->stack_bitmap_width, i))
mini/mini-gc.c:		if (!(cfg->used_int_regs & (1 << i)))
mini/mini-gc.c:		if (has_bit_set (gcfg->reg_pin_bitmap, gcfg->reg_bitmap_width, i))
mini/mini-gc.c:		if (has_bit_set (gcfg->reg_ref_bitmap, gcfg->reg_bitmap_width, i))
mini/mini-gc.c:	if (cfg->verbose_level > 1)
mini/mini-gc.c:	map = mono_mempool_alloc0 (cfg->mempool, sizeof (GCMap));
mini/mini-gc.c:	map->frame_reg = cfg->frame_reg;
mini/mini-gc.c:	map->start_offset = gcfg->min_offset;
mini/mini-gc.c:	map->end_offset = gcfg->min_offset + (nslots * SIZEOF_SLOT);
mini/mini-gc.c:	map->used_int_regs = cfg->used_int_regs;
mini/mini-gc.c:	bitmaps = mono_mempool_alloc0 (cfg->mempool, bitmaps_size);
mini/mini-gc.c:				if (get_bit (gcfg->stack_ref_bitmap, gcfg->stack_bitmap_width, i, j))
mini/mini-gc.c:				if (get_bit (gcfg->stack_pin_bitmap, gcfg->stack_bitmap_width, i, j))
mini/mini-gc.c:					if (get_bit (gcfg->reg_ref_bitmap, gcfg->reg_bitmap_width, i, j))
mini/mini-gc.c:					if (get_bit (gcfg->reg_pin_bitmap, gcfg->reg_bitmap_width, i, j))
mini/mini-gc.c:	if (cfg->code_len < 256)
mini/mini-gc.c:	else if (cfg->code_len < 65536)
mini/mini-gc.c:		emap = mono_domain_alloc0 (cfg->domain, alloc_size);
mini/mini-gc.c:		cfg->jit_info->gc_info = emap;
mini/mini-gc.c:		cfg->gc_map = (guint8*)emap;
mini/mini-gc.c:		cfg->gc_map_size = alloc_size;
mini/mini-gc.c:	if (!cfg->compute_gc_maps)
mini/mini-gc.c:	if (!(cfg->comp_done & MONO_COMP_LIVENESS))
mini/mini-gc.c:		cfg->disable_ref_noref_stack_slot_share = TRUE;
mini/mini-gc.c:		cfg->gen_write_barriers = TRUE;
mini/mini-ia64.c:#define DEBUG(a) if (cfg->verbose_level > 1) a
mini/mini-ia64.c:	header = cfg->header;
mini/mini-ia64.c:	sig = mono_method_signature (cfg->method);
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:		MonoInst *ins = cfg->args [i];
mini/mini-ia64.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-ia64.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-ia64.c:	if (cfg->arch.reg_local0 > 0)
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, mono_method_signature (cfg->method), FALSE);
mini/mini-ia64.c:	header = cfg->header;
mini/mini-ia64.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-ia64.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)) {
mini/mini-ia64.c:	cfg->arch.reg_in0 = 32;
mini/mini-ia64.c:	cfg->arch.reg_local0 = cfg->arch.reg_in0 + cinfo->reg_usage + reserved_regs;
mini/mini-ia64.c:	cfg->arch.reg_out0 = cfg->arch.reg_local0 + 16;
mini/mini-ia64.c:	cfg->arch.reg_saved_ar_pfs = cfg->arch.reg_local0 - 1;
mini/mini-ia64.c:	cfg->arch.reg_saved_b0 = cfg->arch.reg_local0 - 2;
mini/mini-ia64.c:	cfg->arch.reg_fp = cfg->arch.reg_local0 - 3;
mini/mini-ia64.c:		cfg->arch.reg_saved_sp = cfg->arch.reg_local0 - 4;
mini/mini-ia64.c:		cfg->arch.reg_saved_sp = cfg->arch.reg_fp;
mini/mini-ia64.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-ia64.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)) {
mini/mini-ia64.c:		cfg->arch.reg_saved_return_val = cfg->arch.reg_local0 - reserved_regs;
mini/mini-ia64.c:	cfg->arch.n_out_regs = MAX (cfg->arch.n_out_regs, 2);
mini/mini-ia64.c:	for (i = cfg->arch.reg_local0; i < cfg->arch.reg_out0; ++i) {
mini/mini-ia64.c:	header = cfg->header;
mini/mini-ia64.c:	sig = mono_method_signature (cfg->method);
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:	cfg->arch.omit_fp = TRUE;
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:	if (cfg->param_area)
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:		cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:			cfg->arch.omit_fp = FALSE;
mini/mini-ia64.c:	if (cfg->arch.omit_fp) {
mini/mini-ia64.c:		cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-ia64.c:		cfg->frame_reg = IA64_SP;
mini/mini-ia64.c:		cfg->frame_reg = cfg->arch.reg_fp;
mini/mini-ia64.c:	if (cfg->method->save_lmf) {
mini/mini-ia64.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-ia64.c:			cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-ia64.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-ia64.c:			cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-ia64.c:			cfg->vret_addr->opcode = OP_REGVAR;
mini/mini-ia64.c:			cfg->vret_addr->dreg = cfg->arch.reg_in0 + cinfo->ret.reg;
mini/mini-ia64.c:			if (cfg->arch.omit_fp)
mini/mini-ia64.c:			cfg->ret->opcode = OP_REGOFFSET;
mini/mini-ia64.c:			cfg->ret->inst_basereg = cfg->frame_reg;
mini/mini-ia64.c:			cfg->ret->inst_offset = - offset;
mini/mini-ia64.c:		cfg->ret->dreg = cfg->ret->inst_c0;
mini/mini-ia64.c:	offsets = mono_allocate_stack_slots (cfg, cfg->arch.omit_fp ? FALSE : TRUE, &locals_stack_size, &locals_stack_align);
mini/mini-ia64.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-ia64.c:			MonoInst *inst = cfg->varinfo [i];
mini/mini-ia64.c:			inst->inst_basereg = cfg->frame_reg;
mini/mini-ia64.c:			if (cfg->arch.omit_fp)
mini/mini-ia64.c:		if (cfg->arch.omit_fp)
mini/mini-ia64.c:		cfg->sig_cookie = cinfo->sig_cookie.offset + ARGS_OFFSET;
mini/mini-ia64.c:		inst = cfg->args [i];
mini/mini-ia64.c:				inst->dreg = cfg->arch.reg_in0 + ainfo->reg;
mini/mini-ia64.c:				if (cfg->arch.omit_fp)
mini/mini-ia64.c:				inst->inst_basereg = cfg->frame_reg;
mini/mini-ia64.c:				inst->inst_basereg = cfg->frame_reg;
mini/mini-ia64.c:				if (cfg->arch.omit_fp) {
mini/mini-ia64.c:	if (cfg->arch.omit_fp && offset == 16)
mini/mini-ia64.c:	cfg->stack_offset = offset;
mini/mini-ia64.c:	sig = mono_method_signature (cfg->method);
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:		cfg->ret_var_is_local = TRUE;
mini/mini-ia64.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-ia64.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-ia64.c:			mono_print_ins (cfg->vret_addr);
mini/mini-ia64.c:	MONO_ADD_INS (cfg->cbb, arg);
mini/mini-ia64.c:	cfg->disable_aot = TRUE;
mini/mini-ia64.c:	MONO_ADD_INS (cfg->cbb, sig_arg);
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, sig->pinvoke);
mini/mini-ia64.c:		cfg->arch.ret_var_addr_local = local;
mini/mini-ia64.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-ia64.c:		add_outarg_reg (cfg, call, ArgInIReg, cfg->arch.reg_out0 + cinfo->ret.reg, call->vret_var);
mini/mini-ia64.c:				arg->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-ia64.c:				MONO_ADD_INS (cfg->cbb, arg);
mini/mini-ia64.c:				add_outarg_reg (cfg, call, ainfo->storage, cfg->arch.reg_out0 + ainfo->reg, in);
mini/mini-ia64.c:	cfg->arch.n_out_regs = MAX (cfg->arch.n_out_regs, cinfo->reg_usage);
mini/mini-ia64.c:				mono_call_inst_add_outarg_reg (cfg, call, load->dreg, cfg->arch.reg_out0 + ainfo->reg + i, FALSE);
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, load);
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, store);
mini/mini-ia64.c:	CallInfo *cinfo = get_call_info (cfg, cfg->mempool, mono_method_signature (method), FALSE);
mini/mini-ia64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-ia64.c:		MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-ia64.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-ia64.c:	MonoMethod *method = cfg->method;
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:		ins = cfg->args [i];
mini/mini-ia64.c:					ia64_ld8 (code, cfg->arch.reg_in0 + ainfo->reg, GP_SCRATCH_REG);
mini/mini-ia64.c:						ia64_ld8 (code, cfg->arch.reg_in0 + ainfo->reg, GP_SCRATCH_REG);
mini/mini-ia64.c:				if (ins->dreg != cfg->arch.reg_in0 + ainfo->reg)
mini/mini-ia64.c:					ia64_mov (code, cfg->arch.reg_in0 + ainfo->reg, ins->dreg);
mini/mini-ia64.c:				ia64_adds_imm (code, GP_SCRATCH_REG, 16 + ainfo->offset, cfg->frame_reg);
mini/mini-ia64.c:		cinfo = get_call_info (cfg, cfg->mempool, ((MonoCallInst*)ins)->signature, FALSE);
mini/mini-ia64.c:			MonoInst *local = (MonoInst*)cfg->arch.ret_var_addr_local;
mini/mini-ia64.c:	mono_add_patch_info (cfg, code.buf + code.nins - cfg->native_code, patch_type, data); \
mini/mini-ia64.c:	guint8 *code_start = cfg->native_code + cfg->code_len;
mini/mini-ia64.c:	if (cfg->opt & MONO_OPT_LOOP) {
mini/mini-ia64.c:	if (cfg->verbose_level > 2)
mini/mini-ia64.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
mini/mini-ia64.c:	offset = code_start - cfg->native_code;
mini/mini-ia64.c:	if (strstr (cfg->method->name, "conv_ovf_i1") && (bb->block_num == 2))
mini/mini-ia64.c:		offset = code.buf - cfg->native_code;
mini/mini-ia64.c:		while (offset + max_len + 16 > cfg->code_size) {
mini/mini-ia64.c:			offset = code.buf - cfg->native_code;
mini/mini-ia64.c:			cfg->code_size *= 2;
mini/mini-ia64.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ia64.c:			code_start = cfg->native_code + offset;
mini/mini-ia64.c:			cfg->stat_code_reallocs++;
mini/mini-ia64.c:				ia64_patch (pos, cfg->native_code + ins->inst_target_bb->native_offset);
mini/mini-ia64.c:			ins->inst_c0 = code.buf - cfg->native_code;
mini/mini-ia64.c:			ia64_adds_imm (code, GP_SCRATCH_REG, cfg->sig_cookie, cfg->frame_reg);
mini/mini-ia64.c:			cinfo = get_call_info (cfg, cfg->mempool, call->signature, FALSE);
mini/mini-ia64.c:			out_reg = cfg->arch.reg_out0;
mini/mini-ia64.c:			cinfo = get_call_info (cfg, cfg->mempool, call->signature, FALSE);
mini/mini-ia64.c:			out_reg = cfg->arch.reg_out0;
mini/mini-ia64.c:			if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-ia64.c:			g_assert (!cfg->method->save_lmf);
mini/mini-ia64.c:			if (cfg->arch.stack_alloc_size) {
mini/mini-ia64.c:				if (cfg->arch.omit_fp) {
mini/mini-ia64.c:					if (ia64_is_imm14 (cfg->arch.stack_alloc_size))
mini/mini-ia64.c:						ia64_adds_imm (code, IA64_SP, (cfg->arch.stack_alloc_size), IA64_SP);
mini/mini-ia64.c:						ia64_movl (code, GP_SCRATCH_REG, cfg->arch.stack_alloc_size);
mini/mini-ia64.c:					ia64_mov (code, IA64_SP, cfg->arch.reg_saved_sp);
mini/mini-ia64.c:			ia64_mov_to_ar_i (code, IA64_PFS, cfg->arch.reg_saved_ar_pfs);
mini/mini-ia64.c:			ia64_mov_ret_to_br (code, IA64_B0, cfg->arch.reg_saved_b0);
mini/mini-ia64.c:			abi_offset = - ALIGN_TO (cfg->param_area + 16, MONO_ARCH_LOCALLOC_ALIGNMENT);
mini/mini-ia64.c:			abi_offset = - ALIGN_TO (cfg->param_area + 16, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-ia64.c:			ia64_alloc (code, cfg->arch.reg_saved_ar_pfs, cfg->arch.reg_local0 - cfg->arch.reg_in0, cfg->arch.reg_out0 - cfg->arch.reg_local0, cfg->arch.n_out_regs, 0);
mini/mini-ia64.c:			ia64_mov_from_br (code, cfg->arch.reg_saved_b0, IA64_B0);
mini/mini-ia64.c:			ia64_mov (code, cfg->arch.reg_saved_sp, IA64_SP);
mini/mini-ia64.c:			ia64_mov (code, cfg->frame_reg, IA64_R15);
mini/mini-ia64.c:				ia64_adds_imm (code, GP_SCRATCH_REG2, spvar->inst_offset, cfg->frame_reg);
mini/mini-ia64.c:				ia64_add (code, GP_SCRATCH_REG2, cfg->frame_reg, GP_SCRATCH_REG2);
mini/mini-ia64.c:				ia64_adds_imm (code, GP_SCRATCH_REG, spvar->inst_offset, cfg->frame_reg);
mini/mini-ia64.c:				ia64_add (code, GP_SCRATCH_REG, cfg->frame_reg, GP_SCRATCH_REG);
mini/mini-ia64.c:			ia64_mov_to_ar_i (code, IA64_PFS, cfg->arch.reg_saved_ar_pfs);
mini/mini-ia64.c:			ia64_mov_to_br (code, IA64_B0, cfg->arch.reg_saved_b0);
mini/mini-ia64.c:			ia64_mov (code, cfg->arch.reg_out0, ins->sreg1);
mini/mini-ia64.c:			ia64_mov (code, cfg->arch.reg_out0, ins->sreg1);
mini/mini-ia64.c:		if ((code.buf - cfg->native_code - offset) > max_len) {
mini/mini-ia64.c:				   mono_inst_name (ins->opcode), max_len, code.buf - cfg->native_code - offset);
mini/mini-ia64.c:	cfg->code_len = code.buf - cfg->native_code;
mini/mini-ia64.c:	MonoMethod *method = cfg->method;
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:	cfg->code_size =  MAX (cfg->header->code_size * 4, 512);
mini/mini-ia64.c:		cfg->code_size += 1024;
mini/mini-ia64.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-ia64.c:		cfg->code_size += 1024;
mini/mini-ia64.c:	cfg->native_code = g_malloc (cfg->code_size);
mini/mini-ia64.c:	ia64_codegen_init (code, cfg->native_code);
mini/mini-ia64.c:	alloc_size = ALIGN_TO (cfg->stack_offset, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-ia64.c:	if (cfg->param_area)
mini/mini-ia64.c:		alloc_size += cfg->param_area;
mini/mini-ia64.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-ia64.c:	cfg->arch.stack_alloc_size = alloc_size;
mini/mini-ia64.c:	ia64_unw_save_reg (code, UNW_IA64_AR_PFS, UNW_IA64_GR + cfg->arch.reg_saved_ar_pfs);
mini/mini-ia64.c:	ia64_alloc (code, cfg->arch.reg_saved_ar_pfs, cfg->arch.reg_local0 - cfg->arch.reg_in0, cfg->arch.reg_out0 - cfg->arch.reg_local0, cfg->arch.n_out_regs, 0);
mini/mini-ia64.c:	ia64_unw_save_reg (code, UNW_IA64_RP, UNW_IA64_GR + cfg->arch.reg_saved_b0);
mini/mini-ia64.c:	ia64_mov_from_br (code, cfg->arch.reg_saved_b0, IA64_B0);
mini/mini-ia64.c:	if ((alloc_size || cinfo->stack_usage) && !cfg->arch.omit_fp) {
mini/mini-ia64.c:		ia64_unw_save_reg (code, UNW_IA64_SP, UNW_IA64_GR + cfg->arch.reg_saved_sp);
mini/mini-ia64.c:		ia64_mov (code, cfg->arch.reg_saved_sp, IA64_SP);
mini/mini-ia64.c:		if (cfg->frame_reg != cfg->arch.reg_saved_sp)
mini/mini-ia64.c:			ia64_mov (code, cfg->frame_reg, IA64_SP);
mini/mini-ia64.c:			if (cfg->arch.omit_fp)
mini/mini-ia64.c:			if (cfg->arch.omit_fp)
mini/mini-ia64.c:	cfg->arch.r_pro = mono_ia64_create_unwind_region (&code);
mini/mini-ia64.c:		if ((cinfo->ret.storage == ArgInIReg) && (cfg->ret->opcode != OP_REGVAR)) {
mini/mini-ia64.c:		inst = cfg->args [i];
mini/mini-ia64.c:			int reg = cfg->arch.reg_in0 + ainfo->reg;
mini/mini-ia64.c:					ia64_st8_hint (code, GP_SCRATCH_REG, cfg->arch.reg_in0 + ainfo->reg, 0);
mini/mini-ia64.c:						ia64_st8_hint (code, GP_SCRATCH_REG, cfg->arch.reg_in0 + ainfo->reg, 0);
mini/mini-ia64.c:						ia64_st8_inc_imm_hint (code, GP_SCRATCH_REG, cfg->arch.reg_in0 + ainfo->reg + i, sizeof (gpointer), 0);
mini/mini-ia64.c:				if (inst->dreg != cfg->arch.reg_in0 + ainfo->reg)
mini/mini-ia64.c:					ia64_mov (code, inst->dreg, cfg->arch.reg_in0 + ainfo->reg);
mini/mini-ia64.c:				ia64_adds_imm (code, GP_SCRATCH_REG, 16 + ainfo->offset, cfg->frame_reg);
mini/mini-ia64.c:	cfg->code_len = code.buf - cfg->native_code;
mini/mini-ia64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-ia64.c:	cfg->arch.prolog_end_offset = cfg->code_len;
mini/mini-ia64.c:	MonoMethod *method = cfg->method;
mini/mini-ia64.c:	cfg->arch.epilog_begin_offset = cfg->code_len;
mini/mini-ia64.c:	while (cfg->code_len + max_epilog_size > cfg->code_size) {
mini/mini-ia64.c:		cfg->code_size *= 2;
mini/mini-ia64.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ia64.c:		cfg->stat_code_reallocs++;
mini/mini-ia64.c:	buf = cfg->native_code + cfg->code_len;
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, mono_method_signature (method), FALSE);
mini/mini-ia64.c:		g_assert (cfg->ret->opcode == OP_REGOFFSET);
mini/mini-ia64.c:		ia64_adds_imm (code, GP_SCRATCH_REG, cfg->ret->inst_offset, cfg->ret->inst_basereg);
mini/mini-ia64.c:	code.region_start = cfg->native_code;
mini/mini-ia64.c:	if (cfg->arch.stack_alloc_size) {
mini/mini-ia64.c:		if (cfg->arch.omit_fp) {
mini/mini-ia64.c:			if (ia64_is_imm14 (cfg->arch.stack_alloc_size)) {
mini/mini-ia64.c:				ia64_adds_imm (code, IA64_SP, (cfg->arch.stack_alloc_size), IA64_SP);
mini/mini-ia64.c:				ia64_movl (code, GP_SCRATCH_REG, cfg->arch.stack_alloc_size);
mini/mini-ia64.c:			ia64_mov (code, IA64_SP, cfg->arch.reg_saved_sp);
mini/mini-ia64.c:	ia64_mov_to_ar_i (code, IA64_PFS, cfg->arch.reg_saved_ar_pfs);
mini/mini-ia64.c:	ia64_mov_ret_to_br (code, IA64_B0, cfg->arch.reg_saved_b0);
mini/mini-ia64.c:	cfg->arch.r_epilog = mono_ia64_create_unwind_region (&code);
mini/mini-ia64.c:	cfg->arch.r_pro->next = cfg->arch.r_epilog;
mini/mini-ia64.c:	cfg->code_len = code.buf - cfg->native_code;
mini/mini-ia64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-ia64.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-ia64.c:	while (cfg->code_len + code_size > (cfg->code_size - 16)) {
mini/mini-ia64.c:		cfg->code_size *= 2;
mini/mini-ia64.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ia64.c:		cfg->stat_code_reallocs++;
mini/mini-ia64.c:	ia64_codegen_init (code, cfg->native_code + cfg->code_len);
mini/mini-ia64.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-ia64.c:			throw_ip = cfg->native_code + patch_info->ip.i;
mini/mini-ia64.c:			ia64_patch (cfg->native_code + patch_info->ip.i, code.buf);
mini/mini-ia64.c:					ia64_adds_imm (code, cfg->arch.reg_out0 + 1, offset, IA64_R0);
mini/mini-ia64.c:					ia64_movl (code, cfg->arch.reg_out0 + 1, offset);
mini/mini-ia64.c:				ia64_movl (code, cfg->arch.reg_out0 + 1, 0);
mini/mini-ia64.c:					ia64_adds_imm (code, cfg->arch.reg_out0 + 0, exc_token_index, IA64_R0);
mini/mini-ia64.c:					ia64_movl (code, cfg->arch.reg_out0 + 0, exc_token_index);
mini/mini-ia64.c:				patch_info->ip.i = code.buf + code.nins - cfg->native_code;
mini/mini-ia64.c:	//cfg->arch.r_epilog = r_exceptions;
mini/mini-ia64.c:	cfg->code_len = code.buf - cfg->native_code;
mini/mini-ia64.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-ia64.c:		sig = mono_method_signature (cfg->method);
mini/mini-ia64.c:		cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:			ia64_mov (code, cfg->arch.reg_out0 + 1, IA64_SP);
mini/mini-ia64.c:			add_patch_info (cfg, code, MONO_PATCH_INFO_METHODCONST, cfg->method);
mini/mini-ia64.c:			ia64_movl (code, cfg->arch.reg_out0 + 0, 0);
mini/mini-ia64.c:				ins = cfg->args [i];
mini/mini-ia64.c:					ia64_add (code, GP_SCRATCH_REG, cfg->arch.reg_out0 + 1, GP_SCRATCH_REG);
mini/mini-ia64.c:					ia64_add (code, GP_SCRATCH_REG, cfg->arch.reg_out0 + 1, GP_SCRATCH_REG);
mini/mini-ia64.c:			ia64_mov (code, cfg->arch.reg_out0 + 1, IA64_R0);
mini/mini-ia64.c:		ia64_mov (code, cfg->arch.reg_out0 + 1, IA64_R0);
mini/mini-ia64.c:	add_patch_info (cfg, code, MONO_PATCH_INFO_METHODCONST, cfg->method);
mini/mini-ia64.c:	ia64_movl (code, cfg->arch.reg_out0 + 0, 0);
mini/mini-ia64.c:	MonoMethod *method = cfg->method;
mini/mini-ia64.c:	MonoMethodSignature *sig = mono_method_signature (cfg->method);
mini/mini-ia64.c:	cinfo = get_call_info (cfg, cfg->mempool, sig, FALSE);
mini/mini-ia64.c:		ia64_mov (code, cfg->arch.reg_saved_return_val, cinfo->ret.reg);
mini/mini-ia64.c:		ia64_mov (code, cfg->arch.reg_out0 + 1, cinfo->ret.reg);
mini/mini-ia64.c:		ia64_mov (code, cfg->arch.reg_out0 + 1, cfg->arch.reg_in0 + cinfo->ret.reg);
mini/mini-ia64.c:	ia64_movl (code, cfg->arch.reg_out0 + 0, 0);
mini/mini-ia64.c:		ia64_mov (code, cinfo->ret.reg, cfg->arch.reg_saved_return_val);
mini/mini-ia64.c:	di->start_ip = (unw_word_t) cfg->native_code;
mini/mini-ia64.c:	di->end_ip = (unw_word_t) cfg->native_code + cfg->code_len;
mini/mini-ia64.c:	di->u.pi.name_ptr = (unw_word_t)mono_method_full_name (cfg->method, TRUE);
mini/mini-ia64.c:	di->u.pi.regions = cfg->arch.r_pro;
mini/mini-ia64.c:		printf ("Unwind info for method %s:\n", mono_method_full_name (cfg->method, TRUE));
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ia64.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ia64.h:#define MONO_ARCH_IS_GLOBAL_IREG(reg) (is_hard_ireg (reg) && ((reg) >= cfg->arch.reg_local0) && ((reg) < cfg->arch.reg_out0))
mini/mini-llvm.c:#define ctx_ok(ctx) (!(ctx)->cfg->disable_llvm)
mini/mini-llvm.c:	fprintf (stderr, "Failing %s\n", ctx->cfg->llvm_method_name);
mini/mini-llvm.c:	ctx->cfg->exception_message = g_strdup (message);
mini/mini-llvm.c:	ctx->cfg->disable_llvm = TRUE;
mini/mini-llvm.c:		ctx->cfg->exception_message = g_strdup_printf ("type %s", mono_type_full_name (t));
mini/mini-llvm.c:		ctx->cfg->disable_llvm = TRUE;
mini/mini-llvm.c:	if (ctx->cfg->llvm_only)
mini/mini-llvm.c:	else if (!cfg->r4fp && type == LLVMFloatType ())
mini/mini-llvm.c:	res = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, &ji, FALSE, &error);
mini/mini-llvm.c:	if (ctx->cfg->rgctx_var && ctx->cfg->rgctx_var->dreg == vreg)
mini/mini-llvm.c:	ctx->builders = g_slist_prepend_mempool (ctx->cfg->mempool, ctx->builders, builder);
mini/mini-llvm.c:	ji->next = cfg->patch_info;
mini/mini-llvm.c:	cfg->patch_info = ji;
mini/mini-llvm.c:	got_offset = mono_aot_get_got_offset (cfg->patch_info);
mini/mini-llvm.c:			if (!cfg->gshared && !(method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) && ctx->cfg->llvm_only && method->klass->image->assembly == ctx->module->assembly) { 
mini/mini-llvm.c:		if (ctx->cfg->compile_aot)
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:	MonoMethodHeader *header = cfg->header;
mini/mini-llvm.c:	if (bb == cfg->bb_init)
mini/mini-llvm.c:	for (int i = 0; i < cfg->header->num_clauses; i++) {
mini/mini-llvm.c:		MonoExceptionClause *curr = &cfg->header->clauses [i];
mini/mini-llvm.c:			MonoMethodHeader *header = cfg->header;
mini/mini-llvm.c:			tblock = cfg->cil_offset_to_bb [ec->handler_offset];
mini/mini-llvm.c:	if (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only) {
mini/mini-llvm.c:	if (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only && use_intrinsics) {
mini/mini-llvm.c:	if (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only) {
mini/mini-llvm.c:	if (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only && use_intrinsics) {
mini/mini-llvm.c:	if (ctx->cfg->llvm_only) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:	LLVMPositionBuilder (ctx->alloca_builder, get_bb (ctx, ctx->cfg->bb_entry), ctx->last_alloca);
mini/mini-llvm.c:	LLVMValueRef info_var = ctx->values [cfg->gsharedvt_info_var->dreg];
mini/mini-llvm.c:	LLVMValueRef locals_var = ctx->values [cfg->gsharedvt_locals_var->dreg];
mini/mini-llvm.c:	int idx = cfg->gsharedvt_vreg_to_idx [vreg] - 1;
mini/mini-llvm.c:	gboolean need_div_check = ctx->cfg->backend->need_div_check;
mini/mini-llvm.c:	ctx->module->max_inited_idx = MAX (ctx->module->max_inited_idx, cfg->method_index);
mini/mini-llvm.c:	indexes [1] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, FALSE);
mini/mini-llvm.c:	LLVMValueRef method_amodule = get_or_generate_amodule_ref (ctx->module, ctx->cfg->method_index, ctx->cfg->llvm_method_name);
mini/mini-llvm.c:	if (ctx->rgctx_arg && cfg->method->is_inflated && mono_method_get_context (cfg->method)->method_inst) {
mini/mini-llvm.c:	} else if (cfg->gshared) {
mini/mini-llvm.c:	ctx->bblocks [cfg->bb_entry->block_num].end_bblock = inited_bb;
mini/mini-llvm.c:	if (ctx->cfg->vret_addr) {
mini/mini-llvm.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/mini-llvm.c:		MonoInst *var = cfg->varinfo [i];
mini/mini-llvm.c:	mono_method_get_param_names (cfg->method, (const char **) names);
mini/mini-llvm.c:		int reg = cfg->args [i + sig->hasthis]->dreg;
mini/mini-llvm.c:	if (cfg->vret_addr)
mini/mini-llvm.c:		emit_volatile_store (ctx, cfg->vret_addr->dreg);
mini/mini-llvm.c:		emit_volatile_store (ctx, cfg->args [0]->dreg);
mini/mini-llvm.c:			emit_volatile_store (ctx, cfg->args [i + sig->hasthis]->dreg);
mini/mini-llvm.c:	if (sig->hasthis && !cfg->rgctx_var && cfg->gshared) {
mini/mini-llvm.c:		mono_llvm_build_store (builder, ctx->values [cfg->args [0]->dreg], this_alloc, TRUE, LLVM_BARRIER_NONE);
mini/mini-llvm.c:	if (cfg->rgctx_var) {
mini/mini-llvm.c:		g_assert (ctx->addresses [cfg->rgctx_var->dreg]);
mini/mini-llvm.c:		rgctx_alloc = ctx->addresses [cfg->rgctx_var->dreg];
mini/mini-llvm.c:	if (cfg->compile_aot && ctx->llvm_only) {
mini/mini-llvm.c:		ctx->bblocks [cfg->bb_entry->block_num].end_bblock = ctx->inited_bb;
mini/mini-llvm.c:	ctx->nested_in = (GSList**)mono_mempool_alloc0 (cfg->mempool, sizeof (GSList*) * cfg->header->num_clauses);
mini/mini-llvm.c:	for (i = 0; i < cfg->header->num_clauses; ++i) {
mini/mini-llvm.c:		for (j = 0; j < cfg->header->num_clauses; ++j) {
mini/mini-llvm.c:			MonoExceptionClause *clause1 = &cfg->header->clauses [i];
mini/mini-llvm.c:			MonoExceptionClause *clause2 = &cfg->header->clauses [j];
mini/mini-llvm.c:				ctx->nested_in [i] = g_slist_prepend_mempool (cfg->mempool, ctx->nested_in [i], GINT_TO_POINTER (j));
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:			if (cfg->compile_aot) {
mini/mini-llvm.c:		if (!cfg->llvm_only && call->method && strstr (call->method->klass->name, "AsyncVoidMethodBuilder")) {
mini/mini-llvm.c:			  target = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, &ji, FALSE);
mini/mini-llvm.c:			if (cfg->compile_aot) {
mini/mini-llvm.c:			if (cfg->compile_aot) {
mini/mini-llvm.c:				if (cfg->abs_patches) {
mini/mini-llvm.c:					MonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);
mini/mini-llvm.c:				if (cfg->abs_patches) {
mini/mini-llvm.c:					MonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);
mini/mini-llvm.c:						target = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, abs_ji, FALSE, &error);
mini/mini-llvm.c:				if (cfg->abs_patches) {
mini/mini-llvm.c:					MonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);
mini/mini-llvm.c:						target = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, abs_ji, FALSE, &error);
mini/mini-llvm.c:	if (!sig->pinvoke && !cfg->llvm_only)
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:	args [0] = convert (ctx, get_aotconst (ctx, MONO_PATCH_INFO_AOT_JIT_INFO, GINT_TO_POINTER (ctx->cfg->method_index)), IntPtrType ());
mini/mini-llvm.c:	if (ctx->cfg->rgctx_var) {
mini/mini-llvm.c:		LLVMValueRef rgctx_alloc = ctx->addresses [ctx->cfg->rgctx_var->dreg];
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:		if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:	MonoExceptionClause *group_start = cfg->header->clauses + group_index;
mini/mini-llvm.c:	MonoBasicBlock *handler_bb = cfg->cil_offset_to_bb [CLAUSE_START (group_start)];
mini/mini-llvm.c:			int clause_index = clause - cfg->header->clauses;
mini/mini-llvm.c:		int clause_index = group_start - cfg->header->clauses;
mini/mini-llvm.c:	MonoExceptionClause *clause = &ctx->cfg->header->clauses [clause_index];
mini/mini-llvm.c:	if (cfg->compile_aot) {
mini/mini-llvm.c:	if (cfg->compile_aot) {
mini/mini-llvm.c:		ti = (gint32*)mono_mempool_alloc (cfg->mempool, sizeof (gint32));
mini/mini-llvm.c:			if (!cfg->llvm_only)
mini/mini-llvm.c:			if (cfg->r4fp)
mini/mini-llvm.c:					g_assert (cfg->vret_addr);
mini/mini-llvm.c:					g_assert (values [cfg->vret_addr->dreg]);
mini/mini-llvm.c:					LLVMBuildStore (builder, convert (ctx, lhs, ret_type), convert (ctx, values [cfg->vret_addr->dreg], LLVMPointerType (ret_type, 0)));
mini/mini-llvm.c:					if (cfg->vret_addr)
mini/mini-llvm.c:			if (cfg->r4fp)
mini/mini-llvm.c:			if (cfg->r4fp)
mini/mini-llvm.c:			else if (!cfg->r4fp && ins->opcode == OP_LOADR4_MEMBASE)
mini/mini-llvm.c:			ji->next = cfg->patch_info;
mini/mini-llvm.c:			cfg->patch_info = ji;
mini/mini-llvm.c:			got_offset = mono_aot_get_got_offset (cfg->patch_info);
mini/mini-llvm.c:			if (!cfg->llvm_only)
mini/mini-llvm.c:			g_assert (bb->block_num < cfg->max_block_num);
mini/mini-llvm.c:			if (!cfg->llvm_only) {
mini/mini-llvm.c:			if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:			 * so we always have an entry in cfg->varinfo for them.
mini/mini-llvm.c:				if (cfg->gen_write_barriers && klass->has_references && ins->inst_destbasereg != cfg->frame_reg &&
mini/mini-llvm.c:			info->call_handler_return_bbs = g_slist_append_mempool (cfg->mempool, info->call_handler_return_bbs, noex_bb);
mini/mini-llvm.c:			info->endfinally_switch_ins_list = g_slist_append_mempool (cfg->mempool, info->endfinally_switch_ins_list, switch_ins);
mini/mini-llvm.c:				if (ctx->cfg->compile_aot) {
mini/mini-llvm.c:	if (!has_terminator && bb->next_bb && (bb == cfg->bb_entry || bb->in_count > 0)) {
mini/mini-llvm.c:	if (bb == cfg->bb_exit && sig->ret->type == MONO_TYPE_VOID) {
mini/mini-llvm.c:		emit_dbg_loc (ctx, builder, cfg->header->code + cfg->header->code_size - 1);
mini/mini-llvm.c:	if (bb == cfg->bb_entry)
mini/mini-llvm.c:		ctx->last_alloca = LLVMGetLastInstruction (get_bb (ctx, cfg->bb_entry));
mini/mini-llvm.c: *   Do some quick checks to decide whenever cfg->method can be compiled by LLVM, to avoid
mini/mini-llvm.c:	if (cfg->llvm_only)
mini/mini-llvm.c:	if (cfg->method->save_lmf) {
mini/mini-llvm.c:		cfg->exception_message = g_strdup ("lmf");
mini/mini-llvm.c:		cfg->disable_llvm = TRUE;
mini/mini-llvm.c:	if (cfg->disable_llvm)
mini/mini-llvm.c:	for (i = 0; i < cfg->header->num_clauses; ++i) {
mini/mini-llvm.c:		for (j = 0; j < cfg->header->num_clauses; ++j) {
mini/mini-llvm.c:			MonoExceptionClause *clause1 = &cfg->header->clauses [i];
mini/mini-llvm.c:			MonoExceptionClause *clause2 = &cfg->header->clauses [j];
mini/mini-llvm.c:				cfg->exception_message = g_strdup ("nested clauses");
mini/mini-llvm.c:				cfg->disable_llvm = TRUE;
mini/mini-llvm.c:	if (cfg->disable_llvm)
mini/mini-llvm.c:	if (cfg->method->dynamic) {
mini/mini-llvm.c:		cfg->exception_message = g_strdup ("dynamic.");
mini/mini-llvm.c:		cfg->disable_llvm = TRUE;
mini/mini-llvm.c:	if (cfg->disable_llvm)
mini/mini-llvm.c:		linfo = (LLVMCallInfo*)mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));
mini/mini-llvm.c:	return get_llvm_call_info_external (cfg, sig, cfg->gsharedvt, cfg->llvm_only);
mini/mini-llvm.c:	ctx->mempool = cfg->mempool;
mini/mini-llvm.c:	ctx->values = g_new0 (LLVMValueRef, cfg->next_vreg);
mini/mini-llvm.c:	ctx->addresses = g_new0 (LLVMValueRef, cfg->next_vreg);
mini/mini-llvm.c:	ctx->vreg_types = g_new0 (LLVMTypeRef, cfg->next_vreg);
mini/mini-llvm.c:	ctx->is_vphi = g_new0 (gboolean, cfg->next_vreg);
mini/mini-llvm.c:	ctx->vreg_cli_types = g_new0 (MonoType*, cfg->next_vreg);
mini/mini-llvm.c:	ctx->is_dead = g_new0 (gboolean, cfg->next_vreg);
mini/mini-llvm.c:	ctx->unreachable = g_new0 (gboolean, cfg->max_block_num);
mini/mini-llvm.c: 	if (cfg->compile_aot) {
mini/mini-llvm.c:		is_linkonce = ctx->module->llvm_only && ctx->module->static_link && mono_aot_is_linkonce_method (cfg->method);
mini/mini-llvm.c:			method_name = mono_aot_get_mangled_method_name (cfg->method);
mini/mini-llvm.c:				get_or_generate_amodule_ref (ctx->module, ctx->cfg->method_index, method_name);
mini/mini-llvm.c:				printf ("%s %s\n", mono_method_full_name (cfg->method, 1), method_name);
mini/mini-llvm.c:				printf ("%s\n", mono_method_full_name (cfg->method, 1));
mini/mini-llvm.c:		cfg->llvm_method_name = g_strdup (method_name);
mini/mini-llvm.c:		init_jit_module (cfg->domain);
mini/mini-llvm.c:		ctx->module = (MonoLLVMModule*)domain_jit_info (cfg->domain)->llvm_module;
mini/mini-llvm.c:		method_name = mono_method_full_name (cfg->method, TRUE);
mini/mini-llvm.c:	if (cfg->compile_aot)
mini/mini-llvm.c:			/*fprintf (stderr, "Scooping %s\n", ctx->cfg->llvm_method_name);*/
mini/mini-llvm.c:			/*fprintf (stderr, "Scooped %s\n", ctx->cfg->llvm_method_name);*/
mini/mini-llvm.c:	if (cfg->gsharedvt && !cfg->llvm_only) {
mini/mini-llvm.c:				printf ("LAST: %s\n", mono_method_full_name (cfg->method, TRUE));
mini/mini-llvm.c:	sig = mono_method_signature (cfg->method);
mini/mini-llvm.c:	if (cfg->rgctx_var)
mini/mini-llvm.c:		g_assert (ctx->cfg->llvm_method_name);
mini/mini-llvm.c:		method = (LLVMValueRef) g_hash_table_lookup (ctx->module->name_to_lmethod, ctx->cfg->llvm_method_name);
mini/mini-llvm.c:			method = LLVMAddFunction (lmodule, ctx->cfg->llvm_method_name, method_type);
mini/mini-llvm.c:		g_hash_table_insert (ctx->module->name_to_lmethod, ctx->cfg->llvm_method_name, method);
mini/mini-llvm.c:				gboolean gsharedvt = is_gsharedvt_method (ctx->cfg->method);
mini/mini-llvm.c:				g_assert (ctx->cfg->rgctx_var == mono_method_needs_static_rgctx_invoke (ctx->cfg->method, TRUE));
mini/mini-llvm.c:				if (mono_method_needs_static_rgctx_invoke (ctx->cfg->method, TRUE)) {
mini/mini-llvm.c:				if (strcmp(ctx->cfg->llvm_method_name, "aot_inflated_aot_generic__System_System.Array__qsort_gens_<T, U>void_cl7_T_5b_5d_cl7_U_5b_5d_i4i4_gens_<System.DateTime, object>") == 0) {
mini/mini-llvm.c:	if (!cfg->llvm_only)
mini/mini-llvm.c:	if (cfg->compile_aot) {
mini/mini-llvm.c:	if (cfg->method->save_lmf && !cfg->llvm_only) {
mini/mini-llvm.c:	if (sig->pinvoke && cfg->method->wrapper_type != MONO_WRAPPER_RUNTIME_INVOKE && !cfg->llvm_only) {
mini/mini-llvm.c:	header = cfg->header;
mini/mini-llvm.c:	if (header->num_clauses || (cfg->method->iflags & METHOD_IMPL_ATTRIBUTE_NOINLINING) || cfg->no_inline)
mini/mini-llvm.c:	if (cfg->vret_addr) {
mini/mini-llvm.c:		values [cfg->vret_addr->dreg] = LLVMGetParam (method, linfo->vret_arg_pindex);
mini/mini-llvm.c:		LLVMSetValueName (values [cfg->vret_addr->dreg], "vret");
mini/mini-llvm.c:		values [cfg->args [0]->dreg] = ctx->this_arg;
mini/mini-llvm.c:		LLVMSetValueName (values [cfg->args [0]->dreg], "this");
mini/mini-llvm.c:	mono_method_get_param_names (cfg->method, (const char **) names);
mini/mini-llvm.c:		values [cfg->args [i + sig->hasthis]->dreg] = LLVMGetParam (method, pindex);
mini/mini-llvm.c:		LLVMSetValueName (values [cfg->args [i + sig->hasthis]->dreg], name);
mini/mini-llvm.c:			cfg->args [i + sig->hasthis]->opcode = OP_VTARG_ADDR;
mini/mini-llvm.c:	if (ctx->module->emit_dwarf && cfg->compile_aot && mono_debug_enabled ()) {
mini/mini-llvm.c:		ctx->minfo = mono_debug_lookup_method (cfg->method);
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:			MonoInst *inst = (MonoInst*)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst));
mini/mini-llvm.c:	for (i = 0; i < cfg->next_vreg; ++i) {
mini/mini-llvm.c:		if (ins && ins != cfg->rgctx_var)
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:	for (bb_index = 0; bb_index < cfg->num_bblocks; ++bb_index) {
mini/mini-llvm.c:		bb = cfg->bblocks [bb_index];
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:	get_or_generate_amodule_ref (ctx->module, ctx->cfg->method_index, ctx->cfg->llvm_method_name);
mini/mini-llvm.c:	LLVMBasicBlockRef entry_bb = get_bb (ctx, cfg->bb_entry);
mini/mini-llvm.c:		while (group_index < cfg->header->num_clauses) {
mini/mini-llvm.c:			while (cursor < cfg->header->num_clauses &&
mini/mini-llvm.c:				   CLAUSE_START (&cfg->header->clauses [cursor]) == CLAUSE_START (&cfg->header->clauses [group_index]) &&
mini/mini-llvm.c:				   CLAUSE_END (&cfg->header->clauses [cursor]) == CLAUSE_END (&cfg->header->clauses [group_index])) {
mini/mini-llvm.c:			intptr_t key = CLAUSE_END (&cfg->header->clauses [group_index]);
mini/mini-llvm.c:		if (!(bb == cfg->bb_entry || bb->in_count > 0))
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-llvm.c:	if (cfg->compile_aot && ctx->llvm_only) {
mini/mini-llvm.c:		ctx->module->max_method_idx = MAX (ctx->module->max_method_idx, cfg->method_index);
mini/mini-llvm.c:		if ((ctx->has_got_access || mono_class_get_cctor (cfg->method->klass)) && !(cfg->method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED)) {
mini/mini-llvm.c:	if (cfg->llvm_only) {
mini/mini-llvm.c:	if (cfg->verbose_level > 1)
mini/mini-llvm.c:	if (cfg->compile_aot && !cfg->llvm_only)
mini/mini-llvm.c:	if (!cfg->llvm_only) {
mini/mini-llvm.c:		if (cfg->compile_aot)
mini/mini-llvm.c:			method_index = mono_aot_get_method_index (cfg->orig_method);
mini/mini-llvm.c:	if (cfg->compile_aot) {
mini/mini-llvm.c:		if (cfg->verbose_level)
mini/mini-llvm.c:			printf ("%s emitted as %s\n", mono_method_full_name (cfg->method, TRUE), ctx->method_name);
mini/mini-llvm.c:		cfg->native_code = mono_llvm_compile_method (ctx->module->mono_ee, ctx->lmethod, nvars, callee_vars, callee_addrs, &eh_frame);
mini/mini-llvm.c:		if (cfg->verbose_level > 1)
mini/mini-llvm.c:		cfg->native_code = (unsigned char*)LLVMGetPointerToGlobal (ctx->module->ee, ctx->lmethod);
mini/mini-llvm.c:		g_assert (cfg->code_len);
mini/mini-llvm.c:		g_hash_table_insert (ctx->module->method_to_lmethod, cfg->method, ctx->lmethod);
mini/mini-llvm.c:		g_hash_table_insert (ctx->module->idx_to_lmethod, GINT_TO_POINTER (cfg->method_index), ctx->lmethod);
mini/mini-llvm.c:	if (ctx->llvm_only && cfg->orig_method->klass->valuetype && !(cfg->orig_method->flags & METHOD_ATTRIBUTE_STATIC))
mini/mini-llvm.c:		emit_unbox_tramp (ctx, ctx->method_name, ctx->method_type, ctx->lmethod, cfg->method_index);
mini/mini-llvm.c:	sig = mono_method_signature (cfg->method);
mini/mini-llvm.c:	if (cfg->gsharedvt && cfg->llvm_only) {
mini/mini-llvm.c:			cfg->vret_addr = mono_compile_create_var (cfg, &mono_get_intptr_class ()->byval_arg, OP_ARG);
mini/mini-llvm.c:			if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-llvm.c:				mono_print_ins (cfg->vret_addr);
mini/mini-llvm.c:	if (cfg->disable_llvm)
mini/mini-llvm.c:		cfg->exception_message = g_strdup ("varargs");
mini/mini-llvm.c:		cfg->disable_llvm = TRUE;
mini/mini-llvm.c:			ins->inst_p0 = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMArgInfo));
mini/mini-llvm.c:			cfg->exception_message = g_strdup ("ainfo->storage");
mini/mini-llvm.c:			cfg->disable_llvm = TRUE;
mini/mini-llvm.c:		if (!cfg->disable_llvm) {
mini/mini-llvm.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-llvm.c:		return (unsigned char*)mono_domain_code_reserve (cfg->domain, size);
mini/mini-llvm.c:	cfg->code_len = (guint8*)end - (guint8*)start;
mini/mini-llvm.c:	cfg->encoded_unwind_ops = mono_unwind_decode_fde ((guint8*)data, &cfg->encoded_unwind_ops_len, NULL, &ei, &ei_len, &type_info, &this_reg, &this_offset);
mini/mini-llvm.c:	if (cfg->verbose_level > 1)
mini/mini-llvm.c:		mono_print_unwind_info (cfg->encoded_unwind_ops, cfg->encoded_unwind_ops_len);
mini/mini-llvm.c:		MonoExceptionClause *clause1 = &cfg->header->clauses [cindex1];
mini/mini-llvm.c:		for (j = 0; j < cfg->header->num_clauses; ++j) {
mini/mini-llvm.c:			MonoExceptionClause *clause2 = &cfg->header->clauses [cindex2];
mini/mini-llvm.c:	cfg->llvm_ex_info = (MonoJitExceptionInfo*)mono_mempool_alloc0 (cfg->mempool, (ei_len + nested_len) * sizeof (MonoJitExceptionInfo));
mini/mini-llvm.c:	cfg->llvm_ex_info_len = ei_len + nested_len;
mini/mini-llvm.c:	memcpy (cfg->llvm_ex_info, ei, ei_len * sizeof (MonoJitExceptionInfo));
mini/mini-llvm.c:		MonoExceptionClause *clause = &cfg->header->clauses [clause_index];
mini/mini-llvm.c:		cfg->llvm_ex_info [i].flags = clause->flags;
mini/mini-llvm.c:		cfg->llvm_ex_info [i].data.catch_class = clause->data.catch_class;
mini/mini-llvm.c:		cfg->llvm_ex_info [i].clause_index = clause_index;
mini/mini-llvm.c:		MonoExceptionClause *clause1 = &cfg->header->clauses [cindex1];
mini/mini-llvm.c:		for (j = 0; j < cfg->header->num_clauses; ++j) {
mini/mini-llvm.c:			MonoExceptionClause *clause2 = &cfg->header->clauses [cindex2];
mini/mini-llvm.c:				nested_ei = &cfg->llvm_ex_info [i];
mini/mini-llvm.c:				nesting_ei = &cfg->llvm_ex_info [nindex];
mini/mini-llvm.c:	cfg->llvm_this_reg = this_reg;
mini/mini-llvm.c:	cfg->llvm_this_offset = this_offset;
mini/mini-llvm.c:	cfg->code_len = table [0];
mini/mini-llvm.c:	mono_unwind_decode_llvm_mono_fde (fde, fde_len, cie, cfg->native_code, &info);
mini/mini-llvm.c:	cfg->encoded_unwind_ops = info.unw_info;
mini/mini-llvm.c:	cfg->encoded_unwind_ops_len = info.unw_info_len;
mini/mini-llvm.c:	if (cfg->verbose_level > 1)
mini/mini-llvm.c:		mono_print_unwind_info (cfg->encoded_unwind_ops, cfg->encoded_unwind_ops_len);
mini/mini-llvm.c:		cfg->llvm_this_reg = info.this_reg;
mini/mini-llvm.c:		cfg->llvm_this_offset = info.this_offset;
mini/mini-llvm.c:	cfg->llvm_ex_info = (MonoJitExceptionInfo*)mono_mempool_alloc0 (cfg->mempool, (ei_len + nested_len) * sizeof (MonoJitExceptionInfo));
mini/mini-llvm.c:	cfg->llvm_ex_info_len = ei_len + nested_len;
mini/mini-llvm.c:	memcpy (cfg->llvm_ex_info, ei, ei_len * sizeof (MonoJitExceptionInfo));
mini/mini-llvm.c:		MonoExceptionClause *clause = &cfg->header->clauses [clause_index];
mini/mini-llvm.c:		cfg->llvm_ex_info [i].flags = clause->flags;
mini/mini-llvm.c:		cfg->llvm_ex_info [i].data.catch_class = clause->data.catch_class;
mini/mini-llvm.c:		cfg->llvm_ex_info [i].clause_index = clause_index;
mini/mini-llvm.c:	return mono_llvm_di_create_function (module->di_builder, module->cu, method, cfg->method->name, name, dir, filename, n_seq_points ? sym_seq_points [0].line : 1);
mini/mini-llvm.c:	md_args [3] = md_string (cfg->method->name);
mini/mini-llvm.c:	if (ctx->minfo && cil_code && cil_code >= cfg->header->code && cil_code < cfg->header->code + cfg->header->code_size) {
mini/mini-llvm.c:		loc = mono_debug_symfile_lookup_location (ctx->minfo, cil_code - cfg->header->code);
mini/mini-llvm.c: *   - setting the return value, making cfg->ret non-volatile
mini/mini-mips.c:#define DEBUG(a) if (cfg->verbose_level > 1) a
mini/mini-mips.c:		cfg->bb_exit->max_offset += 16;				\
mini/mini-mips.c:		mono_bblock_add_inst (cfg->cbb, inst); \
mini/mini-mips.c:	if (cfg->arch.long_branch) {
mini/mini-mips.c:		mono_add_patch_info (cfg, code - cfg->native_code,
mini/mini-mips.c:		mono_add_patch_info (cfg, code - cfg->native_code,
mini/mini-mips.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-mips.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-mips.c:	if (cfg->arch.omit_fp_computed)
mini/mini-mips.c:	header = cfg->header;
mini/mini-mips.c:	sig = mono_method_signature (cfg->method);
mini/mini-mips.c:	if (!cfg->arch.cinfo)
mini/mini-mips.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-mips.c:	cinfo = cfg->arch.cinfo;
mini/mini-mips.c:	cfg->arch.omit_fp = TRUE;
mini/mini-mips.c:	cfg->arch.omit_fp_computed = TRUE;
mini/mini-mips.c:	if (cfg->disable_omit_fp)
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:	if (cfg->method->save_lmf)
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-mips.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE))
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:		cfg->arch.omit_fp = FALSE;
mini/mini-mips.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-mips.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-mips.c:	//printf ("D: %s %d\n", cfg->method->name, cfg->arch.omit_fp);
mini/mini-mips.c:	sig = mono_method_signature (cfg->method);
mini/mini-mips.c:	if (!cfg->arch.cinfo)
mini/mini-mips.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-mips.c:	cinfo = cfg->arch.cinfo;
mini/mini-mips.c:	// cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-mips.c:	if (mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method))
mini/mini-mips.c:		cfg->param_area = MAX (cfg->param_area, sizeof (gpointer)*8);
mini/mini-mips.c:	if (cfg->flags & MONO_CFG_HAS_VARARGS)
mini/mini-mips.c:		cfg->param_area = MAX (cfg->param_area, sizeof (gpointer)*8);
mini/mini-mips.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE)
mini/mini-mips.c:		cfg->param_area = MAX (cfg->param_area, sizeof (gpointer)*8);
mini/mini-mips.c:	cfg->param_area = MAX (cfg->param_area, MIPS_STACK_PARAM_OFFSET);
mini/mini-mips.c:	header = cfg->header;
mini/mini-mips.c:	if (cfg->arch.omit_fp)
mini/mini-mips.c:	cfg->frame_reg = frame_reg;
mini/mini-mips.c:		cfg->used_int_regs |= 1 << frame_reg;
mini/mini-mips.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-mips.c:			cfg->ret->inst_c0 = cfg->ret->dreg = mips_f0;
mini/mini-mips.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-mips.c:			cfg->ret->inst_c0 = mips_v0;
mini/mini-mips.c:	offset += cfg->param_area;
mini/mini-mips.c:	if (mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method))
mini/mini-mips.c:	curinst = cfg->locals_start;
mini/mini-mips.c:	for (i = curinst; i < cfg->num_varinfo; ++i) {
mini/mini-mips.c:		inst = cfg->varinfo [i];
mini/mini-mips.c:	if (cfg->method->save_lmf) {
mini/mini-mips.c:		cfg->arch.lmf_offset = offset;
mini/mini-mips.c:		cfg->sig_cookie = offset;
mini/mini-mips.c:	cfg->arch.iregs_offset = offset;
mini/mini-mips.c:	iregs_to_save = (cfg->used_int_regs & MONO_ARCH_CALLEE_SAVED_REGS);
mini/mini-mips.c:	fregs_to_restore = (cfg->used_float_regs & MONO_ARCH_CALLEE_SAVED_FREGS);
mini/mini-mips.c:	cfg->stack_offset = offset;
mini/mini-mips.c:	cfg->arch.local_alloc_offset = cfg->stack_offset;
mini/mini-mips.c:		cfg->vret_addr->opcode = OP_REGOFFSET;
mini/mini-mips.c:		cfg->vret_addr->inst_c0 = mips_a0;
mini/mini-mips.c:		cfg->vret_addr->inst_offset = offset;
mini/mini-mips.c:		cfg->vret_addr->inst_basereg = frame_reg;
mini/mini-mips.c:		inst = cfg->args [i];
mini/mini-mips.c:			if (cfg->verbose_level > 1)
mini/mini-mips.c:			if (cfg->verbose_level > 1)
mini/mini-mips.c:	cfg->stack_offset = offset;
mini/mini-mips.c:	cfg->arch.local_alloc_offset = cfg->stack_offset;
mini/mini-mips.c:	sig = mono_method_signature (cfg->method);
mini/mini-mips.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-mips.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-mips.c:			mono_print_ins (cfg->vret_addr);
mini/mini-mips.c:	cfg->disable_aot = TRUE;
mini/mini-mips.c:	MONO_ADD_INS (cfg->cbb, sig_arg);
mini/mini-mips.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-mips.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-mips.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-mips.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-mips.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-mips.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-mips.c:	cfg->param_area = MAX (cfg->param_area, cinfo->stack_usage);
mini/mini-mips.c:	cfg->param_area = MAX (cfg->param_area, 4 * SIZEOF_REGISTER);
mini/mini-mips.c:	cfg->param_area = (cfg->param_area + MIPS_STACK_ALIGNMENT - 1) & ~(MIPS_STACK_ALIGNMENT - 1);
mini/mini-mips.c:	cfg->flags |= MONO_CFG_HAS_CALLS;
mini/mini-mips.c:		if (cfg->verbose_level > 0) {
mini/mini-mips.c:			char* nm = mono_method_full_name (cfg->method, TRUE);
mini/mini-mips.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-mips.c:			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-mips.c:			MONO_EMIT_NEW_UNALU (cfg, OP_MIPS_CVTSD, cfg->ret->dreg, val->dreg);
mini/mini-mips.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-mips.c:	if (cfg->verbose_level > 2)
mini/mini-mips.c:		if (cfg->verbose_level > 2)
mini/mini-mips.c:					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-mips.c:				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-mips.c:	if (cfg->verbose_level > 2) {
mini/mini-mips.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-mips.c:	if (cfg->verbose_level > 2) {
mini/mini-mips.c:	MonoMethod *method = cfg->method;
mini/mini-mips.c:	if (!cfg->arch.cinfo)
mini/mini-mips.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-mips.c:	cinfo = cfg->arch.cinfo;
mini/mini-mips.c:		inst = cfg->vret_addr;
mini/mini-mips.c:		inst = cfg->args [i];
mini/mini-mips.c:	int size = cfg->param_area;
mini/mini-mips.c:	int size = cfg->param_area;
mini/mini-mips.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-mips.c:	if (cfg->verbose_level > 2)
mini/mini-mips.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
mini/mini-mips.c:		MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
mini/mini-mips.c:			cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
mini/mini-mips.c:		offset = code - cfg->native_code;
mini/mini-mips.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-mips.c:			cfg->code_size *= 2;
mini/mini-mips.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-mips.c:			code = cfg->native_code + offset;
mini/mini-mips.c:		if (cfg->verbose_level > 2) {
mini/mini-mips.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-mips.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-mips.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-mips.c:			mono_add_patch_info (cfg, (guint8*) code - cfg->native_code,
mini/mini-mips.c:			g_assert (mips_is_imm16 (cfg->sig_cookie));
mini/mini-mips.c:			mips_lw (code, mips_at, cfg->frame_reg, cfg->sig_cookie);
mini/mini-mips.c:			int area_offset = cfg->param_area;
mini/mini-mips.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-mips.c:			if (cfg->arch.long_branch) {
mini/mini-mips.c:			if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-mips.c:				cfg->code_size += max_len;
mini/mini-mips.c:				cfg->code_size *= 2;
mini/mini-mips.c:				cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-mips.c:				code = cfg->native_code + offset;
mini/mini-mips.c:			if (1 || !(cfg->flags & MONO_CFG_HAS_CALLS))
mini/mini-mips.c:			if (1 || !(cfg->flags & MONO_CFG_HAS_CALLS)) {
mini/mini-mips.c:			cfg->bb_exit->max_offset += 24;
mini/mini-mips.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb);
mini/mini-mips.c:		if ((cfg->opt & MONO_OPT_BRANCH) && ((code - cfg->native_code - offset) > max_len)) {
mini/mini-mips.c:				   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-mips.c:	cfg->code_len = code - cfg->native_code;
mini/mini-mips.c:	int offset = cfg->arch.tracing_offset;
mini/mini-mips.c:	mips_load_const (code, mips_a0, cfg->method);
mini/mini-mips.c:	if (cfg->stack_offset == cfg->arch.local_alloc_offset)
mini/mini-mips.c:	/* adjust cfg->stack_offset for account for down-spilling */
mini/mini-mips.c:	cfg->stack_offset += SIZEOF_REGISTER;
mini/mini-mips.c:	/* re-align cfg->stack_offset if needed (due to var spilling) */
mini/mini-mips.c:	cfg->stack_offset = (cfg->stack_offset + MIPS_STACK_ALIGNMENT - 1) & ~(MIPS_STACK_ALIGNMENT - 1);
mini/mini-mips.c:	delta = cfg->stack_offset - cfg->arch.local_alloc_offset;
mini/mini-mips.c:	if (cfg->verbose_level > 2) {
mini/mini-mips.c:		g_print ("\tspillvars allocated 0x%x -> 0x%x\n", cfg->arch.local_alloc_offset, cfg->stack_offset);
mini/mini-mips.c:	threshold = cfg->arch.local_alloc_offset;
mini/mini-mips.c:	ra_offset = cfg->stack_offset - sizeof(gpointer);
mini/mini-mips.c:	if (cfg->verbose_level > 2) {
mini/mini-mips.c:	sig = mono_method_signature (cfg->method);
mini/mini-mips.c:		cfg->vret_addr->inst_offset += delta;
mini/mini-mips.c:		MonoInst *inst = cfg->args [i];
mini/mini-mips.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-mips.c:		if (cfg->verbose_level > 2) {
mini/mini-mips.c:			if (cfg->verbose_level > 2) {
mini/mini-mips.c:			if (((ins->opcode == OP_ADD_IMM) || (ins->opcode == OP_IADD_IMM)) && (ins->sreg1 == cfg->frame_reg))
mini/mini-mips.c:					if (cfg->verbose_level > 2) {
mini/mini-mips.c:					if (cfg->verbose_level > 2) {
mini/mini-mips.c:					if (cfg->verbose_level > 2) {
mini/mini-mips.c: *   ------------------- sp + cfg->stack_usage + cfg->param_area
mini/mini-mips.c: *   ------------------- sp + cfg->stack_usage + MIPS_STACK_PARAM_OFFSET
mini/mini-mips.c: *   ------------------- sp + cfg->stack_usage
mini/mini-mips.c: *   ------------------- sp + cfg->stack_usage-4
mini/mini-mips.c: *   ------------------- sp + cfg->arch.lmf_offset
mini/mini-mips.c: *   ------------------- sp + cfg->arch.iregs_offset
mini/mini-mips.c: *   ------------------- sp + cfg->param_area
mini/mini-mips.c:	MonoMethod *method = cfg->method;
mini/mini-mips.c:	guint32 lmf_offset = cfg->arch.lmf_offset;
mini/mini-mips.c:		cfg->flags |= MONO_CFG_HAS_CALLS;
mini/mini-mips.c:	cfg->code_size = 768 + sig->param_count * 20;
mini/mini-mips.c:	code = cfg->native_code = g_malloc (cfg->code_size);
mini/mini-mips.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-mips.c:		if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-mips.c:		cfg->arch.long_branch = TRUE;
mini/mini-mips.c:	alloc_size = cfg->stack_offset;
mini/mini-mips.c:	cfg->stack_usage = alloc_size;
mini/mini-mips.c:	iregs_to_save = (cfg->used_int_regs & MONO_ARCH_CALLEE_SAVED_REGS);
mini/mini-mips.c:	fregs_to_save = (cfg->used_float_regs & MONO_ARCH_CALLEE_SAVED_FREGS);
mini/mini-mips.c:	if ((cfg->flags & MONO_CFG_HAS_CALLS) || ALWAYS_SAVE_RA) {
mini/mini-mips.c:	pos = cfg->arch.iregs_offset - alloc2_size;
mini/mini-mips.c:				g_assert (pos < (int)(cfg->stack_usage - sizeof(gpointer)));
mini/mini-mips.c:				g_assert (pos < cfg->stack_usage - MIPS_STACK_ALIGNMENT);
mini/mini-mips.c:	if (cfg->frame_reg != mips_sp) {
mini/mini-mips.c:		MIPS_MOVE (code, cfg->frame_reg, mips_sp);
mini/mini-mips.c:		mono_emit_unwind_op_def_cfa (cfg, code, cfg->frame_reg, cfa_offset);
mini/mini-mips.c:			int offset = lmf_offset + G_STRUCT_OFFSET(MonoLMF, iregs[cfg->frame_reg]);
mini/mini-mips.c:			MIPS_SW (code, cfg->frame_reg, mips_sp, offset);
mini/mini-mips.c:	if (cfg->rgctx_var) {
mini/mini-mips.c:		MonoInst *ins = cfg->rgctx_var;
mini/mini-mips.c:	if (!cfg->arch.cinfo)
mini/mini-mips.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-mips.c:	cinfo = cfg->arch.cinfo;
mini/mini-mips.c:		inst = cfg->vret_addr;
mini/mini-mips.c:		mips_addi (code, mips_at, cfg->frame_reg, offset);
mini/mini-mips.c:		mips_sw (code, mips_at, cfg->frame_reg, cfg->sig_cookie - alloc2_size);
mini/mini-mips.c:		inst = cfg->args [pos];
mini/mini-mips.c:		if (cfg->verbose_level > 2)
mini/mini-mips.c:				int offset = cfg->stack_usage + ainfo->offset;
mini/mini-mips.c:			if (cfg->verbose_level > 2)
mini/mini-mips.c:				if (cfg->verbose_level > 2)
mini/mini-mips.c:				g_assert (inst->inst_basereg == cfg->frame_reg);
mini/mini-mips.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_IP, NULL);
mini/mini-mips.c:		if (cfg->frame_reg != mips_sp)
mini/mini-mips.c:			MIPS_MOVE (code, cfg->frame_reg, mips_sp);
mini/mini-mips.c:		cfg->arch.tracing_offset = cfg->stack_offset;
mini/mini-mips.c:	cfg->code_len = code - cfg->native_code;
mini/mini-mips.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-mips.c:	MonoMethod *method = cfg->method;
mini/mini-mips.c:	offset = code - cfg->native_code;
mini/mini-mips.c:	if (offset > (cfg->code_size - 16 * 4)) {
mini/mini-mips.c:		cfg->code_size *= 2;
mini/mini-mips.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-mips.c:		code = cfg->native_code + offset;
mini/mini-mips.c:	mips_load_const (code, mips_a0, cfg->method);
mini/mini-mips.c:	MonoMethod *method = cfg->method;
mini/mini-mips.c:	if (cfg->method->save_lmf)
mini/mini-mips.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-mips.c:		pos = code - cfg->native_code;
mini/mini-mips.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-mips.c:		cfg->code_size *= 2;
mini/mini-mips.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-mips.c:		cfg->stat_code_reallocs++;
mini/mini-mips.c:		code = cfg->native_code + pos;
mini/mini-mips.c:		code = cfg->native_code + cfg->code_len;
mini/mini-mips.c:	if (cfg->frame_reg != mips_sp) {
mini/mini-mips.c:		MIPS_MOVE (code, mips_sp, cfg->frame_reg);
mini/mini-mips.c:	if (cfg->stack_usage > ((1 << 15) - 1024)) {
mini/mini-mips.c:		alloc2_size = cfg->stack_usage - 1024;
mini/mini-mips.c:	pos = cfg->arch.iregs_offset - alloc2_size;
mini/mini-mips.c:	iregs_to_restore = (cfg->used_int_regs & MONO_ARCH_CALLEE_SAVED_REGS);
mini/mini-mips.c:	fregs_to_restore = (cfg->used_float_regs & MONO_ARCH_CALLEE_SAVED_FREGS);
mini/mini-mips.c:				g_assert (pos < cfg->stack_usage - MIPS_STACK_ALIGNMENT);
mini/mini-mips.c:		int lmf_offset = cfg->arch.lmf_offset;
mini/mini-mips.c:	mips_lw (code, mips_fp, mips_sp, cfg->stack_usage + MIPS_FP_ADDR_OFFSET);
mini/mini-mips.c:	if ((cfg->flags & MONO_CFG_HAS_CALLS) || ALWAYS_SAVE_RA) {
mini/mini-mips.c:		g_assert (mips_is_imm16(cfg->stack_usage - alloc2_size + MIPS_RET_ADDR_OFFSET));
mini/mini-mips.c:		mips_lw (code, mips_ra, mips_sp, cfg->stack_usage - alloc2_size + MIPS_RET_ADDR_OFFSET);
mini/mini-mips.c:	g_assert (mips_is_imm16(cfg->stack_usage - alloc2_size));
mini/mini-mips.c:	mips_addiu (code, mips_sp, mips_sp, cfg->stack_usage - alloc2_size);
mini/mini-mips.c:	cfg->code_len = code - cfg->native_code;
mini/mini-mips.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-mips.c:	cfg->code_len = code - cfg->native_code;
mini/mini-mips.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-mips.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-mips.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-mips.c:		cfg->code_size *= 2;
mini/mini-mips.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-mips.c:		cfg->stat_code_reallocs++;
mini/mini-mips.c:	code = cfg->native_code + cfg->code_len;
mini/mini-mips.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-mips.c:			//unsigned char *ip = patch_info->ip.i + cfg->native_code;
mini/mini-mips.c:			patch_info->data.offset = exc_throw_pos[i] - cfg->native_code;
mini/mini-mips.c:	cfg->code_len = code - cfg->native_code;
mini/mini-mips.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-mips.c:		mono_bblock_add_inst (cfg->cbb, this_ins);
mini/mini-mips.c:		mono_bblock_add_inst (cfg->cbb, vtarg);
mini/mini-native-types.c:	else if (type->type == MONO_TYPE_R4 && !type->byref && cfg->r4fp)
mini/mini-native-types.c:		ins->type = cfg->r4_stack_type;
mini/mini-native-types.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:	if (cfg->r4fp && info->conv_4_to_8 == OP_FCONV_TO_R8)
mini/mini-native-types.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:	if (info->op_index == 2 && cfg->r4fp && SIZEOF_VOID_P == 4) {
mini/mini-native-types.c:			cfg->has_indirection = TRUE;
mini/mini-native-types.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-native-types.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:		mono_bblock_add_inst (cfg->cbb, inst); \
mini/mini-ppc.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-ppc.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-ppc.c:	if (cfg->frame_reg != ppc_sp)
mini/mini-ppc.c:		if (!(cfg->compile_aot && i == 29))
mini/mini-ppc.c:	MonoMethodSignature *sig = mono_method_signature (cfg->method);
mini/mini-ppc.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-ppc.c:	cfg->disable_aot = TRUE;
mini/mini-ppc.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-ppc.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-ppc.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-ppc.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:			cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-ppc.c:				ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-ppc.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-ppc.c:					MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:				cfg->flags |= MONO_CFG_HAS_FPOUT;
mini/mini-ppc.c:		MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-ppc.c:	cfg->param_area = MAX (PPC_MINIMAL_PARAM_AREA_SIZE, MAX (cfg->param_area, cinfo->stack_usage));
mini/mini-ppc.c:	cfg->flags |= MONO_CFG_HAS_CALLS;
mini/mini-ppc.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-ppc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-ppc.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-ppc.c:	ppc_load_ptr (code, ppc_r3, cfg->method);
mini/mini-ppc.c:	MonoMethod *method = cfg->method;
mini/mini-ppc.c:	int save_offset = PPC_STACK_PARAM_OFFSET + cfg->param_area;
mini/mini-ppc.c:	offset = code - cfg->native_code;
mini/mini-ppc.c:	if (offset > (cfg->code_size - 16 * 4)) {
mini/mini-ppc.c:		cfg->code_size *= 2;
mini/mini-ppc.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ppc.c:		code = cfg->native_code + offset;
mini/mini-ppc.c:		ppc_stw (code, ppc_r3, save_offset, cfg->frame_reg);
mini/mini-ppc.c:		ppc_stw (code, ppc_r4, save_offset + 4, cfg->frame_reg);
mini/mini-ppc.c:		ppc_stptr (code, ppc_r3, save_offset, cfg->frame_reg);
mini/mini-ppc.c:		ppc_stfd (code, ppc_f1, save_offset, cfg->frame_reg);
mini/mini-ppc.c:			ppc_lwz (code, ppc_r4, save_offset, cfg->frame_reg);
mini/mini-ppc.c:			ppc_lwz (code, ppc_r5, save_offset + 4, cfg->frame_reg);
mini/mini-ppc.c:	ppc_load_ptr (code, ppc_r3, cfg->method);
mini/mini-ppc.c:		ppc_lwz (code, ppc_r3, save_offset, cfg->frame_reg);
mini/mini-ppc.c:		ppc_lwz (code, ppc_r4, save_offset + 4, cfg->frame_reg);
mini/mini-ppc.c:		ppc_ldptr (code, ppc_r3, save_offset, cfg->frame_reg);
mini/mini-ppc.c:		ppc_lfd (code, ppc_f1, save_offset, cfg->frame_reg);
mini/mini-ppc.c:	ppc_bc (code, (b0), (b1), (code - cfg->native_code + ins->inst_true_bb->native_offset) & 0xffff); \
mini/mini-ppc.c:		MonoOvfJump *ovfj = mono_mempool_alloc (cfg->mempool, sizeof (MonoOvfJump));	\
mini/mini-ppc.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB_OVF, ovfj); \
mini/mini-ppc.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb); \
mini/mini-ppc.c: * to cfg->bb_exit as far as the big branch handling is concerned
mini/mini-ppc.c:		int br_disp = cfg->bb_exit->max_offset - offset;	\
mini/mini-ppc.c:			MonoOvfJump *ovfj = mono_mempool_alloc (cfg->mempool, sizeof (MonoOvfJump));	\
mini/mini-ppc.c:			ovfj->ip_offset = code - cfg->native_code;	\
mini/mini-ppc.c:		        mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_EXC_OVF, ovfj); \
mini/mini-ppc.c:			cfg->bb_exit->max_offset += 24;	\
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code,   \
mini/mini-ppc.c:					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-ppc.c:				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-ppc.c:			MONO_EMIT_NEW_BIALU_IMM (cfg, OP_IADD_IMM, basereg, cfg->frame_reg, offset);
mini/mini-ppc.c:				MONO_EMIT_NEW_BIALU_IMM (cfg, OP_IADD_IMM, basereg, cfg->frame_reg, offset);
mini/mini-ppc.c:			MONO_EMIT_NEW_BIALU_IMM (cfg, OP_IADD_IMM, basereg, cfg->frame_reg, offset);
mini/mini-ppc.c://#define map_to_reg_reg_op(op) (cfg->new_ir? mono_op_imm_to_op (op): map_to_reg_reg_op (op))
mini/mini-ppc.c:			if (cfg->compile_aot) {
mini/mini-ppc.c:	bb->max_vreg = cfg->next_vreg;	
mini/mini-ppc.c:	long offset = cfg->arch.fp_conv_var_offset;
mini/mini-ppc.c:		ppc_stfd (code, ppc_f0, offset, cfg->frame_reg);
mini/mini-ppc.c:			ppc_ldr (code, dreg, offset + sub_offset, cfg->frame_reg);
mini/mini-ppc.c:			ppc_lwz (code, dreg, offset + sub_offset, cfg->frame_reg);
mini/mini-ppc.c:		ppc_add (code, dreg, dreg, cfg->frame_reg);
mini/mini-ppc.c:	long size = cfg->param_area;
mini/mini-ppc.c:	long size = cfg->param_area;
mini/mini-ppc.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-ppc.c:	if (cfg->verbose_level > 2)
mini/mini-ppc.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
mini/mini-ppc.c:		//MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
mini/mini-ppc.c:		//	cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
mini/mini-ppc.c:		offset = code - cfg->native_code;
mini/mini-ppc.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-ppc.c:			cfg->code_size *= 2;
mini/mini-ppc.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ppc.c:			code = cfg->native_code + offset;
mini/mini-ppc.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-ppc.c:			if (cfg->compile_aot)
mini/mini-ppc.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-ppc.c:			if ((FORCE_INDIR_CALL || cfg->method->dynamic) && !cfg->compile_aot) {
mini/mini-ppc.c:			code = mono_arch_emit_load_got_addr (cfg->native_code, code, cfg, NULL);
mini/mini-ppc.c:			g_assert (!cfg->method->save_lmf);
mini/mini-ppc.c:			if (1 || cfg->flags & MONO_CFG_HAS_CALLS) {
mini/mini-ppc.c:				long ret_offset = cfg->stack_usage + PPC_RET_ADDR_OFFSET;
mini/mini-ppc.c:					ppc_ldptr (code, ppc_r0, ret_offset, cfg->frame_reg);
mini/mini-ppc.c:					ppc_ldptr_indexed (code, ppc_r0, cfg->frame_reg, ppc_r12);
mini/mini-ppc.c:			if (ppc_is_imm16 (cfg->stack_usage)) {
mini/mini-ppc.c:				ppc_addi (code, ppc_r12, cfg->frame_reg, cfg->stack_usage);
mini/mini-ppc.c:				/* cfg->stack_usage is an int, so we can use
mini/mini-ppc.c:				ppc_addis (code, ppc_r12, cfg->frame_reg, ppc_ha(cfg->stack_usage));
mini/mini-ppc.c:				ppc_addi (code, ppc_r12, ppc_r12, cfg->stack_usage);
mini/mini-ppc.c:			if (!cfg->method->save_lmf) {
mini/mini-ppc.c:					if (cfg->used_int_regs & (1 << i)) {
mini/mini-ppc.c:				g_assert (cfg->frame_reg == ppc_sp);
mini/mini-ppc.c:				if (ppc_is_imm16 (cfg->stack_usage)) {
mini/mini-ppc.c:					ppc_addi (code, ppc_r12, cfg->frame_reg, cfg->stack_usage);
mini/mini-ppc.c:					/* cfg->stack_usage is an int, so we can use
mini/mini-ppc.c:					ppc_addis (code, ppc_r12, cfg->frame_reg, ppc_ha(cfg->stack_usage));
mini/mini-ppc.c:					ppc_addi (code, ppc_r12, ppc_r12, cfg->stack_usage);
mini/mini-ppc.c:			mono_add_patch_info (cfg, (guint8*) code - cfg->native_code, MONO_PATCH_INFO_METHOD_JUMP, call->method);
mini/mini-ppc.c:			if (cfg->compile_aot) {
mini/mini-ppc.c:			long cookie_offset = cfg->sig_cookie + cfg->stack_usage;
mini/mini-ppc.c:				ppc_addi (code, ppc_r0, cfg->frame_reg, cookie_offset);
mini/mini-ppc.c:				ppc_add (code, ppc_r0, cfg->frame_reg, ppc_r0);
mini/mini-ppc.c:			if ((FORCE_INDIR_CALL || cfg->method->dynamic) && !cfg->compile_aot) {
mini/mini-ppc.c:			if (cfg->compile_aot && ins->sreg1 == ppc_r12) {
mini/mini-ppc.c:			int alloca_waste = PPC_STACK_PARAM_OFFSET + cfg->param_area + 31;
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-ppc.c:			if ((FORCE_INDIR_CALL || cfg->method->dynamic) && !cfg->compile_aot) {
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-ppc.c:			if ((FORCE_INDIR_CALL || cfg->method->dynamic) && !cfg->compile_aot) {
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_target_bb);
mini/mini-ppc.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-ppc.c:				//x86_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
mini/mini-ppc.c:			g_assert (cfg->compile_aot);
mini/mini-ppc.c:		if ((cfg->opt & MONO_OPT_BRANCH) && ((code - cfg->native_code - offset) > max_len)) {
mini/mini-ppc.c:				   mono_inst_name (ins->opcode), max_len, (glong)(code - cfg->native_code - offset));
mini/mini-ppc.c:	cfg->code_len = code - cfg->native_code;
mini/mini-ppc.c: *   	param area             size is cfg->param_area
mini/mini-ppc.c:	MonoMethod *method = cfg->method;
mini/mini-ppc.c:	cfg->code_size = 512 + sig->param_count * 32;
mini/mini-ppc.c:	code = cfg->native_code = g_malloc (cfg->code_size);
mini/mini-ppc.c:	if (1 || cfg->flags & MONO_CFG_HAS_CALLS) {
mini/mini-ppc.c:	alloc_size = cfg->stack_offset;
mini/mini-ppc.c:			if (cfg->used_int_regs & (1 << i)) {
mini/mini-ppc.c:	cfg->stack_usage = alloc_size;
mini/mini-ppc.c:			code = save_registers (cfg, code, alloc_size - pos, ppc_sp, method->save_lmf, cfg->used_int_regs, cfa_offset);
mini/mini-ppc.c:			code = save_registers (cfg, code, 0, ppc_r12, method->save_lmf, cfg->used_int_regs, cfa_offset);
mini/mini-ppc.c:	if (cfg->frame_reg != ppc_sp) {
mini/mini-ppc.c:		ppc_mr (code, cfg->frame_reg, ppc_sp);
mini/mini-ppc.c:		mono_emit_unwind_op_def_cfa_reg (cfg, code, cfg->frame_reg);
mini/mini-ppc.c:	if (cfg->rgctx_var) {
mini/mini-ppc.c:		g_assert (cfg->rgctx_var->opcode == OP_REGOFFSET &&
mini/mini-ppc.c:				(cfg->rgctx_var->inst_basereg == ppc_r1 || cfg->rgctx_var->inst_basereg == ppc_r31));
mini/mini-ppc.c:		ppc_stptr (code, MONO_ARCH_RGCTX_REG, cfg->rgctx_var->inst_offset, cfg->rgctx_var->inst_basereg);
mini/mini-ppc.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-ppc.c:		if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-ppc.c:		inst = cfg->vret_addr;
mini/mini-ppc.c:		inst = cfg->args [pos];
mini/mini-ppc.c:		if (cfg->verbose_level > 2)
mini/mini-ppc.c:			if (cfg->verbose_level > 2)
mini/mini-ppc.c:				if (cfg->tailcall_valuetype_addrs) {
mini/mini-ppc.c:					MonoInst *addr = cfg->tailcall_valuetype_addrs [tailcall_struct_index];
mini/mini-ppc.c:		if (cfg->compile_aot) {
mini/mini-ppc.c:			code = mono_arch_emit_load_got_addr (cfg->native_code, code, cfg, NULL);
mini/mini-ppc.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-ppc.c:		if ((FORCE_INDIR_CALL || cfg->method->dynamic) && !cfg->compile_aot) {
mini/mini-ppc.c:		if (cfg->compile_aot)
mini/mini-ppc.c:		if (cfg->compile_aot) {
mini/mini-ppc.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_IP, NULL);
mini/mini-ppc.c:	cfg->code_len = code - cfg->native_code;
mini/mini-ppc.c:	g_assert (cfg->code_len <= cfg->code_size);
mini/mini-ppc.c:	MonoMethod *method = cfg->method;
mini/mini-ppc.c:	if (cfg->method->save_lmf)
mini/mini-ppc.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-ppc.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-ppc.c:		cfg->code_size *= 2;
mini/mini-ppc.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ppc.c:		cfg->stat_code_reallocs++;
mini/mini-ppc.c:	code = cfg->native_code + cfg->code_len;
mini/mini-ppc.c:		ppc_mr (code, ppc_r8, cfg->frame_reg);
mini/mini-ppc.c:		ppc_addi (code, ppc_r12, cfg->frame_reg, cfg->stack_usage - lmf_offset);
mini/mini-ppc.c:		g_assert (ppc_is_imm16 (cfg->stack_usage + PPC_RET_ADDR_OFFSET));
mini/mini-ppc.c:		if (1 || cfg->flags & MONO_CFG_HAS_CALLS) {
mini/mini-ppc.c:			ppc_ldr (code, ppc_r0, cfg->stack_usage + PPC_RET_ADDR_OFFSET, ppc_r8);
mini/mini-ppc.c:		ppc_addic (code, ppc_sp, ppc_r8, cfg->stack_usage);
mini/mini-ppc.c:		if (1 || cfg->flags & MONO_CFG_HAS_CALLS) {
mini/mini-ppc.c:			long return_offset = cfg->stack_usage + PPC_RET_ADDR_OFFSET;
mini/mini-ppc.c:				ppc_ldr (code, ppc_r0, return_offset, cfg->frame_reg);
mini/mini-ppc.c:				ppc_ldr_indexed (code, ppc_r0, cfg->frame_reg, ppc_r12);
mini/mini-ppc.c:		if (ppc_is_imm16 (cfg->stack_usage)) {
mini/mini-ppc.c:			int offset = cfg->stack_usage;
mini/mini-ppc.c:				if (cfg->used_int_regs & (1 << i))
mini/mini-ppc.c:			if (cfg->frame_reg != ppc_sp)
mini/mini-ppc.c:				ppc_mr (code, ppc_r12, cfg->frame_reg);
mini/mini-ppc.c:				if (cfg->used_int_regs & (1 << i)) {
mini/mini-ppc.c:					ppc_ldr (code, i, offset, cfg->frame_reg);
mini/mini-ppc.c:			if (cfg->frame_reg != ppc_sp)
mini/mini-ppc.c:				ppc_addi (code, ppc_sp, ppc_r12, cfg->stack_usage);
mini/mini-ppc.c:				ppc_addi (code, ppc_sp, ppc_sp, cfg->stack_usage);
mini/mini-ppc.c:			ppc_load32 (code, ppc_r12, cfg->stack_usage);
mini/mini-ppc.c:			if (cfg->used_int_regs) {
mini/mini-ppc.c:				ppc_add (code, ppc_r12, cfg->frame_reg, ppc_r12);
mini/mini-ppc.c:					if (cfg->used_int_regs & (1 << i)) {
mini/mini-ppc.c:				ppc_add (code, ppc_sp, cfg->frame_reg, ppc_r12);
mini/mini-ppc.c:	cfg->code_len = code - cfg->native_code;
mini/mini-ppc.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-ppc.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-ppc.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-ppc.c:		cfg->code_size *= 2;
mini/mini-ppc.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-ppc.c:		cfg->stat_code_reallocs++;
mini/mini-ppc.c:	code = cfg->native_code + cfg->code_len;
mini/mini-ppc.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-ppc.c:			unsigned char *ip = patch_info->ip.i + cfg->native_code;
mini/mini-ppc.c:			ip = ovfj->data.bb->native_offset + cfg->native_code;
mini/mini-ppc.c:			unsigned char *ip = patch_info->ip.i + cfg->native_code;
mini/mini-ppc.c:			newji = mono_mempool_alloc (cfg->mempool, sizeof (MonoJumpInfo));
mini/mini-ppc.c:			newji->ip.i = bcl - cfg->native_code;
mini/mini-ppc.c:			unsigned char *ip = patch_info->ip.i + cfg->native_code;
mini/mini-ppc.c:			/*mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_EXC_NAME, patch_info->data.target);*/
mini/mini-ppc.c:			patch_info->ip.i = code - cfg->native_code;
mini/mini-ppc.c:			if (FORCE_INDIR_CALL || cfg->method->dynamic) {
mini/mini-ppc.c:	cfg->code_len = code - cfg->native_code;
mini/mini-ppc.c:	g_assert (cfg->code_len <= cfg->code_size);
mini/mini-s390x.c:	displace = ((cfg->native_code + 					\
mini/mini-s390x.c:	mono_add_patch_info (cfg, code - cfg->native_code, 			\
mini/mini-s390x.c:	displace = ((cfg->native_code + 					\
mini/mini-s390x.c:	mono_add_patch_info (cfg, code - cfg->native_code, 			\
mini/mini-s390x.c:		mono_add_patch_info (cfg, code - cfg->native_code,   	\
mini/mini-s390x.c:        MONO_ADD_INS (cfg->cbb, inst);		 				\
mini/mini-s390x.c:#define DEBUG(a) if (cfg->verbose_level > 1) a
mini/mini-s390x.c:	int stackSize = cfg->stack_usage;
mini/mini-s390x.c:	if (cfg->frame_reg != STK_BASE)
mini/mini-s390x.c:		s390_lgr (code, STK_BASE, cfg->frame_reg);
mini/mini-s390x.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-s390x.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-s390x.c:	header = cfg->header;
mini/mini-s390x.c:	if ((cfg->flags & MONO_CFG_HAS_ALLOCA) || header->num_clauses)
mini/mini-s390x.c:		cfg->frame_reg = s390_r11;
mini/mini-s390x.c:		if (cfg->frame_reg != i)
mini/mini-s390x.c:	header  = cfg->header;
mini/mini-s390x.c:	cfg->flags |= MONO_CFG_HAS_SPILLUP;
mini/mini-s390x.c:	if ((cfg->flags & MONO_CFG_HAS_ALLOCA) || header->num_clauses)
mini/mini-s390x.c:	cfg->frame_reg = frame_reg;
mini/mini-s390x.c:	cfg->arch.bkchain_reg = -1;
mini/mini-s390x.c:		cfg->used_int_regs |= (1 << frame_reg);		
mini/mini-s390x.c:	if (cfg->uses_rgctx_reg)
mini/mini-s390x.c:		cfg->used_int_regs |= (1 << MONO_ARCH_IMT_REG);
mini/mini-s390x.c:	sig     = mono_method_signature (cfg->method);
mini/mini-s390x.c:	cinfo   = get_call_info (cfg, cfg->mempool, sig);
mini/mini-s390x.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-s390x.c:			cfg->ret->dreg   = s390_r2;
mini/mini-s390x.c:	if (cfg->param_area == 0)
mini/mini-s390x.c:		offset = cfg->param_area;
mini/mini-s390x.c:	cfg->sig_cookie = 0;
mini/mini-s390x.c:		inst 		   = cfg->vret_addr;
mini/mini-s390x.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-s390x.c:			mono_print_ins (cfg->vret_addr);
mini/mini-s390x.c:		inst = cfg->args [0];
mini/mini-s390x.c:		cfg->sig_cookie += S390_MINIMAL_STACK_SIZE;
mini/mini-s390x.c:		inst = cfg->args [curinst];
mini/mini-s390x.c:				cfg->arch.bkchain_reg = s390_r12;
mini/mini-s390x.c:				cfg->used_int_regs |= 1 << cfg->arch.bkchain_reg;
mini/mini-s390x.c:				inst->inst_basereg = cfg->arch.bkchain_reg;
mini/mini-s390x.c:					 * now, since cfg->stack_offset is not yet known, so dedicate a 
mini/mini-s390x.c:					cfg->arch.bkchain_reg = s390_r12;
mini/mini-s390x.c:					cfg->used_int_regs |= 1 << cfg->arch.bkchain_reg;
mini/mini-s390x.c:					inst->inst_basereg = cfg->arch.bkchain_reg;
mini/mini-s390x.c:					if (cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) 
mini/mini-s390x.c:				cfg->sig_cookie += size;
mini/mini-s390x.c:printf("%s %4d cookine %x\n",__FUNCTION__,__LINE__,cfg->sig_cookie);
mini/mini-s390x.c:	cfg->locals_min_stack_offset = offset;
mini/mini-s390x.c:	curinst = cfg->locals_start;
mini/mini-s390x.c:	for (iVar = curinst; iVar < cfg->num_varinfo; ++iVar) {
mini/mini-s390x.c:		inst = cfg->varinfo [iVar];
mini/mini-s390x.c:	cfg->locals_max_stack_offset = offset;
mini/mini-s390x.c:	if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) 
mini/mini-s390x.c:	    || (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE))
mini/mini-s390x.c:	if (cfg->method->save_lmf)
mini/mini-s390x.c:	cfg->stack_offset = S390_ALIGN(offset, S390_STACK_ALIGNMENT);
mini/mini-s390x.c:		inst = cfg->args [iParm];
mini/mini-s390x.c:			inst->inst_offset += cfg->stack_offset;
mini/mini-s390x.c:	sig = mono_method_signature (cfg->method);
mini/mini-s390x.c:	cinfo = get_call_info (cfg, cfg->mempool, sig);
mini/mini-s390x.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-s390x.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-s390x.c:			mono_print_ins (cfg->vret_addr);
mini/mini-s390x.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:	cfg->disable_aot = TRUE;
mini/mini-s390x.c:	MONO_ADD_INS (cfg->cbb, sig_arg);
mini/mini-s390x.c:	cinfo = get_call_info (cfg, cfg->mempool, sig);
mini/mini-s390x.c:	cfg->param_area   = MAX(((signed) cfg->param_area), lParamArea);
mini/mini-s390x.c:	cfg->flags       |= MONO_CFG_HAS_CALLS;
mini/mini-s390x.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:	header = cfg->header;
mini/mini-s390x.c:	if ((cfg->flags & MONO_CFG_HAS_ALLOCA) || header->num_clauses)
mini/mini-s390x.c:			ins->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-s390x.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:				if (cfg->compute_gc_maps) {
mini/mini-s390x.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-s390x.c:		header = mono_method_get_header_checked (cfg->method, &error);
mini/mini-s390x.c:		if ((cfg->flags & MONO_CFG_HAS_ALLOCA) || header->num_clauses)
mini/mini-s390x.c:		if (cfg->compute_gc_maps) {
mini/mini-s390x.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-s390x.c:	parmOffset = cfg->stack_usage - S390_TRACE_STACK_SIZE;
mini/mini-s390x.c:	if (cfg->method->save_lmf)
mini/mini-s390x.c:	S390_SET  (code, s390_r2, cfg->method);
mini/mini-s390x.c:	s390_aghi (code, s390_r4, cfg->stack_usage);
mini/mini-s390x.c:	MonoMethod *method = cfg->method;
mini/mini-s390x.c:	offset = code - cfg->native_code;
mini/mini-s390x.c:	if (offset > (cfg->code_size - 128)) {
mini/mini-s390x.c:		cfg->code_size *= 2;
mini/mini-s390x.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-s390x.c:		code = cfg->native_code + offset;
mini/mini-s390x.c:	saveOffset = cfg->stack_usage - S390_TRACE_STACK_SIZE;
mini/mini-s390x.c:		s390_stg (code, s390_r2, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:		s390_std (code, s390_f0, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:		s390_std (code, s390_f0, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:		s390_stg (code, s390_r2, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:			s390_lg (code, s390_r3, 0, cfg->frame_reg, 
mini/mini-s390x.c:				 S390_MINIMAL_STACK_SIZE+cfg->param_area);
mini/mini-s390x.c:	S390_SET  (code, s390_r2, cfg->method);
mini/mini-s390x.c:		s390_lg  (code, s390_r2, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:		s390_ld  (code, s390_f0, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:		s390_lg  (code, s390_r2, 0, cfg->frame_reg, saveOffset);
mini/mini-s390x.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-s390x.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-s390x.c:	if (cfg->verbose_level > 2)
mini/mini-s390x.c:	if ((cfg->prof_options & MONO_PROFILE_COVERAGE) && cfg->coverage_info) {
mini/mini-s390x.c:		MonoProfileCoverageInfo *cov = cfg->coverage_info;
mini/mini-s390x.c:		offset = code - cfg->native_code;
mini/mini-s390x.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-s390x.c:			cfg->code_size *= 2;
mini/mini-s390x.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-s390x.c:			code = cfg->native_code + offset;
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_ABS, 
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code, 
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code, 
mini/mini-s390x.c:			if (cfg->method->save_lmf)
mini/mini-s390x.c:				restoreLMF(code, cfg->frame_reg, cfg->stack_usage);
mini/mini-s390x.c:			if (cfg->flags & MONO_CFG_HAS_TAIL) {
mini/mini-s390x.c:			s390_lg  (code, s390_r14, 0, cfg->frame_reg, S390_RET_ADDR_OFFSET);
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code,
mini/mini-s390x.c:			int offset = cfg->sig_cookie + cfg->stack_usage;
mini/mini-s390x.c:			s390_agr  (code, s390_r0, cfg->frame_reg);
mini/mini-s390x.c:				mono_add_patch_info (cfg, code-cfg->native_code,
mini/mini-s390x.c:				mono_add_patch_info (cfg, code-cfg->native_code,
mini/mini-s390x.c:				mono_add_patch_info (cfg, code-cfg->native_code,
mini/mini-s390x.c:				mono_add_patch_info (cfg, code-cfg->native_code,
mini/mini-s390x.c:			if (cfg->param_area == 0)
mini/mini-s390x.c:				alloca_skip = cfg->param_area;
mini/mini-s390x.c:			if (cfg->method->save_lmf) {
mini/mini-s390x.c:				int lmfOffset = cfg->stack_usage - sizeof(MonoLMF);
mini/mini-s390x.c:				s390_lgr (code, s390_r13, cfg->frame_reg);
mini/mini-s390x.c:			mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-s390x.c:			mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-s390x.c:			mono_add_patch_info (cfg, code-cfg->native_code, 
mini/mini-s390x.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-s390x.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-s390x.c:			if (cfg->compile_aot)
mini/mini-s390x.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-s390x.c:			mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD,
mini/mini-s390x.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code, 
mini/mini-s390x.c:			mono_add_patch_info (cfg, code - cfg->native_code, 
mini/mini-s390x.c:			if (s390_is_imm16 (cfg->stack_offset)) {
mini/mini-s390x.c:				s390_aghi (code, ins->dreg, cfg->stack_offset);
mini/mini-s390x.c:			} else if (s390_is_imm32 (cfg->stack_offset)) {
mini/mini-s390x.c:				s390_agfi (code, ins->dreg, cfg->stack_offset);
mini/mini-s390x.c:				S390_SET  (code, s390_r13, cfg->stack_offset);
mini/mini-s390x.c:			mono_add_patch_info (cfg, code- cfg->native_code, MONO_PATCH_INFO_ABS,
mini/mini-s390x.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-s390x.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-s390x.c:			bb->spill_slot_defs = g_slist_prepend_mempool (cfg->mempool, bb->spill_slot_defs, ins);
mini/mini-s390x.c:				if (cfg->r4fp)
mini/mini-s390x.c:				if (cfg->r4fp)
mini/mini-s390x.c:				if (cfg->r4fp)
mini/mini-s390x.c:				if (cfg->r4fp)
mini/mini-s390x.c:			if (cfg->r4fp) {
mini/mini-s390x.c:		if ((cfg->opt & MONO_OPT_BRANCH) && ((code - cfg->native_code - offset) > max_len)) {
mini/mini-s390x.c:				   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-s390x.c:	cfg->code_len = code - cfg->native_code;
mini/mini-s390x.c:	MonoMethod *method = cfg->method;
mini/mini-s390x.c:		inst         = cfg->vret_addr;
mini/mini-s390x.c:		inst = cfg->args [pos];
mini/mini-s390x.c:	MonoMethod *method = cfg->method;
mini/mini-s390x.c:	cfg->code_size   = 512;
mini/mini-s390x.c:		cfg->code_size += 256;
mini/mini-s390x.c:	} else if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-s390x.c:		cfg->code_size += 256;
mini/mini-s390x.c:		cfg->code_size += 200;
mini/mini-s390x.c:	cfg->native_code = code = g_malloc (cfg->code_size);
mini/mini-s390x.c:	if (cfg->arch.bkchain_reg != -1)
mini/mini-s390x.c:		s390_lgr (code, cfg->arch.bkchain_reg, STK_BASE);
mini/mini-s390x.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA) {
mini/mini-s390x.c:		cfg->used_int_regs |= 1 << 11;
mini/mini-s390x.c:	alloc_size = cfg->stack_offset;
mini/mini-s390x.c:	cfg->stack_usage = cfa_offset = alloc_size;
mini/mini-s390x.c:	if (cfg->frame_reg != STK_BASE)
mini/mini-s390x.c:	mono_emit_unwind_op_def_cfa_reg (cfg, code, cfg->frame_reg);
mini/mini-s390x.c:	if (cfg->rgctx_var) {
mini/mini-s390x.c:		g_assert (cfg->rgctx_var->opcode == OP_REGOFFSET);
mini/mini-s390x.c:			   cfg->rgctx_var->inst_basereg, 
mini/mini-s390x.c:			   cfg->rgctx_var->inst_offset);
mini/mini-s390x.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-s390x.c:		if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-s390x.c:	cinfo = get_call_info (cfg, cfg->mempool, sig);
mini/mini-s390x.c:		inst               = cfg->vret_addr;
mini/mini-s390x.c:		inst = cfg->args [pos];
mini/mini-s390x.c:			if (cfg->verbose_level > 2)
mini/mini-s390x.c:		s390_lgr   (code, s390_r13, cfg->frame_reg);		
mini/mini-s390x.c:		mono_add_patch_info (cfg, code - cfg->native_code, 
mini/mini-s390x.c:	if (cfg->method->save_lmf)
mini/mini-s390x.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-s390x.c:		MonoBasicBlock *first_bb = cfg->bb_entry;
mini/mini-s390x.c:			inst = cfg->args [i];
mini/mini-s390x.c:	cfg->code_len = code - cfg->native_code;
mini/mini-s390x.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-s390x.c:	MonoMethod *method = cfg->method;
mini/mini-s390x.c:	if (cfg->method->save_lmf)
mini/mini-s390x.c:	else if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-s390x.c:	while ((cfg->code_len + max_epilog_size) > (cfg->code_size - 16)) {
mini/mini-s390x.c:		cfg->code_size  *= 2;
mini/mini-s390x.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-s390x.c:		cfg->stat_code_reallocs++;
mini/mini-s390x.c:	code = cfg->native_code + cfg->code_len;
mini/mini-s390x.c:		restoreLMF(code, cfg->frame_reg, cfg->stack_usage);
mini/mini-s390x.c:	if (cfg->flags & MONO_CFG_HAS_ALLOCA) {
mini/mini-s390x.c:	cfg->code_len = code - cfg->native_code;
mini/mini-s390x.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-s390x.c:	for (patch_info = cfg->patch_info; 
mini/mini-s390x.c:	while ((cfg->code_len + code_size) > (cfg->code_size - 16)) {
mini/mini-s390x.c:		cfg->code_size  *= 2;
mini/mini-s390x.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-s390x.c:		cfg->stat_code_reallocs++; 
mini/mini-s390x.c:	code = cfg->native_code + cfg->code_len;
mini/mini-s390x.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-s390x.c:			guint8 *ip = patch_info->ip.i + cfg->native_code;
mini/mini-s390x.c:							   cfg->native_code + 8), code));
mini/mini-s390x.c:				patch_info->ip.i      = code - cfg->native_code;
mini/mini-s390x.c:	cfg->code_len = code - cfg->native_code;
mini/mini-s390x.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-sparc.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-sparc.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-sparc.c:	sig = mono_method_signature (cfg->method);
mini/mini-sparc.c:	header = cfg->header;
mini/mini-sparc.c:	sig = mono_method_signature (cfg->method);
mini/mini-sparc.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-sparc.c:			cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-sparc.c:				MonoInst *low = get_vreg_to_inst (cfg, MONO_LVREG_LS (cfg->ret->dreg));
mini/mini-sparc.c:				MonoInst *high = get_vreg_to_inst (cfg, MONO_LVREG_MS (cfg->ret->dreg));
mini/mini-sparc.c:			cfg->ret->opcode = OP_REGVAR;
mini/mini-sparc.c:			cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-sparc.c:			cfg->vret_addr->opcode = OP_REGOFFSET;
mini/mini-sparc.c:			cfg->vret_addr->inst_basereg = sparc_fp;
mini/mini-sparc.c:			cfg->vret_addr->inst_offset = 64;
mini/mini-sparc.c:		cfg->ret->dreg = cfg->ret->inst_c0;
mini/mini-sparc.c:	cfg->frame_reg = sparc_fp;
mini/mini-sparc.c:	if (cfg->method->save_lmf) {
mini/mini-sparc.c:		cfg->arch.lmf_offset = offset;
mini/mini-sparc.c:	curinst = cfg->locals_start;
mini/mini-sparc.c:	for (i = curinst; i < cfg->num_varinfo; ++i) {
mini/mini-sparc.c:		inst = cfg->varinfo [i];
mini/mini-sparc.c:		cfg->sig_cookie = cinfo->sig_cookie.offset + ARGS_OFFSET;
mini/mini-sparc.c:		inst = cfg->args [i];
mini/mini-sparc.c:	cfg->stack_offset = offset;
mini/mini-sparc.c:	sig = mono_method_signature (cfg->method);
mini/mini-sparc.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-sparc.c:		if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-sparc.c:			mono_print_ins (cfg->vret_addr);
mini/mini-sparc.c:		MonoInst *low = get_vreg_to_inst (cfg, MONO_LVREG_LS (cfg->ret->dreg));
mini/mini-sparc.c:		MonoInst *high = get_vreg_to_inst (cfg, MONO_LVREG_MS (cfg->ret->dreg));
mini/mini-sparc.c:	cfg->arch.float_spill_slot = mono_compile_create_var (cfg, &mono_defaults.double_class->byval_arg, OP_ARG);
mini/mini-sparc.c:	((MonoInst*)cfg->arch.float_spill_slot)->flags |= MONO_INST_VOLATILE;
mini/mini-sparc.c:	MONO_ADD_INS (cfg->cbb, arg);
mini/mini-sparc.c:		arg->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-sparc.c:		MONO_ADD_INS (cfg->cbb, arg);
mini/mini-sparc.c:		MONO_ADD_INS (cfg->cbb, arg);
mini/mini-sparc.c:	cfg->disable_aot = TRUE;
mini/mini-sparc.c:		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-sparc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_LMOVE, cfg->ret->dreg, val->dreg);
mini/mini-sparc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, MONO_LVREG_MS (cfg->ret->dreg), MONO_LVREG_MS (val->dreg));
mini/mini-sparc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, MONO_LVREG_LS (cfg->ret->dreg), MONO_LVREG_LS (val->dreg));
mini/mini-sparc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_SETFRET, cfg->ret->dreg, val->dreg);
mini/mini-sparc.c:			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-sparc.c:   disp = (ins->inst_true_bb->native_offset - ((guint8*)code - cfg->native_code)) >> 2; \
mini/mini-sparc.c:	mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb); \
mini/mini-sparc.c:	if (0 && v64 && !cfg->compile_aot) {
mini/mini-sparc.c:		target = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, &patch_info, FALSE, &error);
mini/mini-sparc.c:		mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, patch_type, data);
mini/mini-sparc.c:					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-sparc.c:				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-sparc.c:					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-sparc.c:					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
mini/mini-sparc.c:			if (v64 && (cfg->header->code_size < 10000) && last_ins && 
mini/mini-sparc.c:	if (cfg->method->save_lmf) {
mini/mini-sparc.c:		gint32 lmf_offset = MONO_SPARC_STACK_BIAS - cfg->arch.lmf_offset;
mini/mini-sparc.c:	MonoMethod *method = cfg->method;
mini/mini-sparc.c:		inst = cfg->args [i];
mini/mini-sparc.c:	guint32 *code = (guint32*)(cfg->native_code + cfg->code_len);
mini/mini-sparc.c:	if (cfg->verbose_level > 2)
mini/mini-sparc.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
mini/mini-sparc.c:		offset = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:		if (offset > (cfg->code_size - max_len - 16)) {
mini/mini-sparc.c:			cfg->code_size *= 2;
mini/mini-sparc.c:			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-sparc.c:			code = (guint32*)(cfg->native_code + offset);
mini/mini-sparc.c:			if (cfg->method->save_lmf)
mini/mini-sparc.c:			mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_METHOD_JUMP, ins->inst_p0);
mini/mini-sparc.c:			sparc_add_imm (code, FALSE, sparc_fp, cfg->sig_cookie, sparc_o7);
mini/mini-sparc.c:			if (mono_method_signature (cfg->method)->ret->type == MONO_TYPE_R4)
mini/mini-sparc.c:			offset2 = ALIGN_TO (cfg->arch.localloc_offset, 8);
mini/mini-sparc.c:			offset2 = ALIGN_TO (cfg->arch.localloc_offset, 8);
mini/mini-sparc.c:			mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-sparc.c:			mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-sparc.c:			ins->inst_c0 = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:				gint32 disp = (ins->inst_target_bb->native_offset - ((guint8*)code - cfg->native_code)) >> 2;
mini/mini-sparc.c:			if (v64 && (cfg->opt & MONO_OPT_CMOV)) {
mini/mini-sparc.c:		    if (v64 && (cfg->opt & MONO_OPT_CMOV)) {
mini/mini-sparc.c:			MonoInst *spill = cfg->arch.float_spill_slot;
mini/mini-sparc.c:			MonoInst *spill = cfg->arch.float_spill_slot;
mini/mini-sparc.c:			MonoInst *spill = cfg->arch.float_spill_slot;
mini/mini-sparc.c:			MonoInst *spill = cfg->arch.float_spill_slot;
mini/mini-sparc.c:	cfg->code_len = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:	MonoMethodSignature *sig = mono_method_signature (cfg->method);
mini/mini-sparc.c:	sparc_set (code, cfg->method, sparc_o0);
mini/mini-sparc.c:	mono_add_patch_info (cfg, (guint8*)code-cfg->native_code, MONO_PATCH_INFO_ABS, func);
mini/mini-sparc.c:	MonoMethod *method = cfg->method;
mini/mini-sparc.c:	sparc_set (code, cfg->method, sparc_o0);
mini/mini-sparc.c:	mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_ABS, func);
mini/mini-sparc.c:	MonoMethod *method = cfg->method;
mini/mini-sparc.c:	cfg->code_size = 256;
mini/mini-sparc.c:	cfg->native_code = g_malloc (cfg->code_size);
mini/mini-sparc.c:	code = (guint32*)cfg->native_code;
mini/mini-sparc.c:	offset = cfg->stack_offset;
mini/mini-sparc.c:	if (cfg->param_area < (6 * sizeof (gpointer)))
mini/mini-sparc.c:		offset += cfg->param_area;
mini/mini-sparc.c:	 * size is given by cfg->stack_offset), and between the space reserved
mini/mini-sparc.c:	cfg->arch.localloc_offset = offset - cfg->stack_offset;
mini/mini-sparc.c:	cfg->stack_offset = offset;
mini/mini-sparc.c:	if (!sparc_is_imm13 (- cfg->stack_offset)) {
mini/mini-sparc.c:		sparc_set (code, (- cfg->stack_offset), GP_SCRATCH_REG);
mini/mini-sparc.c:		sparc_save_imm (code, sparc_sp, - cfg->stack_offset, sparc_sp);
mini/mini-sparc.c:	if (strstr (cfg->method->name, "foo")) {
mini/mini-sparc.c:		mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_ABS, mono_sparc_break);
mini/mini-sparc.c:		inst = cfg->args [i];
mini/mini-sparc.c:	if (cfg->method->save_lmf) {
mini/mini-sparc.c:		gint32 lmf_offset = STACK_BIAS - cfg->arch.lmf_offset;
mini/mini-sparc.c:		mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_IP, NULL);
mini/mini-sparc.c:		sparc_set (code, cfg->method, sparc_o7);
mini/mini-sparc.c:		mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
mini/mini-sparc.c:	cfg->code_len = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:	g_assert (cfg->code_len <= cfg->code_size);
mini/mini-sparc.c:	MonoMethod *method = cfg->method;
mini/mini-sparc.c:	if (cfg->method->save_lmf)
mini/mini-sparc.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-sparc.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-sparc.c:		cfg->code_size *= 2;
mini/mini-sparc.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-sparc.c:		cfg->stat_code_reallocs++;
mini/mini-sparc.c:	code = (guint32*)(cfg->native_code + cfg->code_len);
mini/mini-sparc.c:	if (cfg->method->save_lmf) {
mini/mini-sparc.c:		gint32 lmf_offset = STACK_BIAS - cfg->arch.lmf_offset;
mini/mini-sparc.c:	if (!v64 && mono_method_signature (cfg->method)->pinvoke && MONO_TYPE_ISSTRUCT(mono_method_signature (cfg->method)->ret))
mini/mini-sparc.c:	if (cfg->bb_exit->in_count == 1 && cfg->bb_exit->in_bb[0]->native_offset != cfg->bb_exit->native_offset)
mini/mini-sparc.c:	cfg->code_len = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-sparc.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-sparc.c:	while (cfg->code_len + code_size > (cfg->code_size - 16)) {
mini/mini-sparc.c:		cfg->code_size *= 2;
mini/mini-sparc.c:		cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
mini/mini-sparc.c:		cfg->stat_code_reallocs++;
mini/mini-sparc.c:	code = (guint32*)(cfg->native_code + cfg->code_len);
mini/mini-sparc.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-sparc.c:			sparc_patch ((guint32*)(cfg->native_code + patch_info->ip.i), code);
mini/mini-sparc.c:				guint32 throw_offset = (((guint8*)exc_throw_end [i] - cfg->native_code) - throw_ip) >> 2;
mini/mini-sparc.c:				if (sparc_is_imm13 (((((guint8*)code - cfg->native_code) - throw_ip) >> 2) - 8))
mini/mini-sparc.c:				mono_add_patch_info (cfg, (guint8*)code - cfg->native_code, MONO_PATCH_INFO_ABS, mono_sparc_break);
mini/mini-sparc.c:				disp = (((guint8*)code - cfg->native_code) - throw_ip) >> 2;
mini/mini-sparc.c:				patch_info->ip.i = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:	cfg->code_len = (guint8*)code - cfg->native_code;
mini/mini-sparc.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-x86.c:	if (cfg->compile_aot && !cfg->full_aot)
mini/mini-x86.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/mini-x86.c:		MonoInst *ins = cfg->varinfo [i];
mini/mini-x86.c:	MonoInst *ins = cfg->varinfo [vmv->idx];
mini/mini-x86.c:	if (cfg->method->save_lmf)
mini/mini-x86.c:	if (cfg->arch.need_stack_frame_inited) {
mini/mini-x86.c:		g_assert (cfg->arch.need_stack_frame == flag);
mini/mini-x86.c:	cfg->arch.need_stack_frame = flag;
mini/mini-x86.c:	cfg->arch.need_stack_frame_inited = TRUE;
mini/mini-x86.c:	//g_print ("will eliminate %s.%s.%s\n", cfg->method->klass->name_space, cfg->method->klass->name, cfg->method->name);
mini/mini-x86.c:	if (cfg->arch.need_stack_frame_inited)
mini/mini-x86.c:		return cfg->arch.need_stack_frame;
mini/mini-x86.c:	header = cfg->header;
mini/mini-x86.c:	sig = mono_method_signature (cfg->method);
mini/mini-x86.c:	if (cfg->disable_omit_fp)
mini/mini-x86.c:	else if (cfg->flags & MONO_CFG_HAS_ALLOCA)
mini/mini-x86.c:	else if (cfg->method->save_lmf)
mini/mini-x86.c:	else if (cfg->stack_offset)
mini/mini-x86.c:	else if (cfg->param_area)
mini/mini-x86.c:	else if (cfg->flags & (MONO_CFG_HAS_CALLS | MONO_CFG_HAS_ALLOCA | MONO_CFG_HAS_TAIL))
mini/mini-x86.c:	else if ((mono_jit_trace_calls != NULL && mono_trace_eval (cfg->method)) ||
mini/mini-x86.c:		(cfg->prof_options & MONO_PROFILE_ENTER_LEAVE))
mini/mini-x86.c:	return cfg->arch.need_stack_frame;
mini/mini-x86.c:	header = cfg->header;
mini/mini-x86.c:	sig = mono_method_signature (cfg->method);
mini/mini-x86.c:	if (!cfg->arch.cinfo)
mini/mini-x86.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-x86.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-x86.c:	cfg->frame_reg = X86_EBP;
mini/mini-x86.c:	if (cfg->has_atomic_add_i4 || cfg->has_atomic_exchange_i4) {
mini/mini-x86.c:		cfg->used_int_regs |= (1 << X86_EBX) | (1 << X86_EDI) | (1 << X86_ESI);
mini/mini-x86.c:	if (cfg->method->save_lmf) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EBX)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EDI)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_ESI)) {
mini/mini-x86.c:		cfg->ret->opcode = OP_REGOFFSET;
mini/mini-x86.c:		cfg->ret->inst_basereg = X86_EBP;
mini/mini-x86.c:		cfg->ret->inst_offset = - offset;
mini/mini-x86.c:		char *mname = mono_method_full_name (cfg->method, TRUE);
mini/mini-x86.c:	cfg->locals_min_stack_offset = - (offset + locals_stack_size);
mini/mini-x86.c:	cfg->locals_max_stack_offset = - offset;
mini/mini-x86.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini-x86.c:			MonoInst *inst = cfg->varinfo [i];
mini/mini-x86.c:		if (cfg->vret_addr) {
mini/mini-x86.c:			 * In the new IR, the cfg->vret_addr variable represents the
mini/mini-x86.c:			cfg->vret_addr->opcode = OP_REGOFFSET;
mini/mini-x86.c:			cfg->vret_addr->inst_basereg = cfg->frame_reg;
mini/mini-x86.c:			cfg->vret_addr->inst_offset = cinfo->ret.offset + ARGS_OFFSET;
mini/mini-x86.c:			if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/mini-x86.c:				mono_print_ins (cfg->vret_addr);
mini/mini-x86.c:			cfg->ret->opcode = OP_REGOFFSET;
mini/mini-x86.c:			cfg->ret->inst_basereg = X86_EBP;
mini/mini-x86.c:			cfg->ret->inst_offset = cinfo->ret.offset + ARGS_OFFSET;
mini/mini-x86.c:		cfg->ret->opcode = OP_REGVAR;
mini/mini-x86.c:		cfg->ret->inst_c0 = cinfo->ret.reg;
mini/mini-x86.c:		cfg->ret->dreg = cinfo->ret.reg;
mini/mini-x86.c:		cfg->sig_cookie = cinfo->sig_cookie.offset + ARGS_OFFSET;
mini/mini-x86.c:		inst = cfg->args [i];
mini/mini-x86.c:	cfg->stack_offset = offset;
mini/mini-x86.c:	sig = mono_method_signature (cfg->method);
mini/mini-x86.c:	if (!cfg->arch.cinfo)
mini/mini-x86.c:		cfg->arch.cinfo = get_call_info (cfg->mempool, sig);
mini/mini-x86.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-x86.c:		cfg->ret_var_is_local = TRUE;
mini/mini-x86.c:		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
mini/mini-x86.c:	if (cfg->gen_sdb_seq_points) {
mini/mini-x86.c:		cfg->arch.ss_tramp_var = ins;
mini/mini-x86.c:		cfg->arch.bp_tramp_var = ins;
mini/mini-x86.c:	if (cfg->method->save_lmf) {
mini/mini-x86.c:		cfg->create_lmf_var = TRUE;
mini/mini-x86.c:		cfg->lmf_ir = TRUE;
mini/mini-x86.c:		cfg->lmf_ir_mono_lmf = TRUE;
mini/mini-x86.c:	cfg->arch_eh_jit_info = 1;
mini/mini-x86.c:	if (cfg->compile_aot) {
mini/mini-x86.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-x86.c:	linfo = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));
mini/mini-x86.c:			cfg->exception_message = g_strdup ("pinvoke + vtypes");
mini/mini-x86.c:			cfg->disable_llvm = TRUE;
mini/mini-x86.c:		cfg->exception_message = g_strdup ("vtype ret in call");
mini/mini-x86.c:		cfg->disable_llvm = TRUE;
mini/mini-x86.c:		cfg->exception_message = g_strdup ("vtype ret in call");
mini/mini-x86.c:		cfg->disable_llvm = TRUE;
mini/mini-x86.c:				cfg->exception_message = g_strdup ("pinvoke + vtypes");
mini/mini-x86.c:				cfg->disable_llvm = TRUE;
mini/mini-x86.c:			cfg->exception_message = g_strdup ("vtype arg");
mini/mini-x86.c:			cfg->disable_llvm = TRUE;
mini/mini-x86.c:			cfg->exception_message = g_strdup ("ainfo->storage");
mini/mini-x86.c:			cfg->disable_llvm = TRUE;
mini/mini-x86.c:	if (cfg->compute_gc_maps) {
mini/mini-x86.c:	cinfo = get_call_info (cfg->mempool, sig);
mini/mini-x86.c:			MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-x86.c:			arg->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-x86.c:			MONO_ADD_INS (cfg->cbb, arg);
mini/mini-x86.c:				arg->inst_p1 = mono_mempool_alloc (cfg->mempool, sizeof (ArgInfo));
mini/mini-x86.c:				MONO_ADD_INS (cfg->cbb, arg);
mini/mini-x86.c:				MONO_ADD_INS (cfg->cbb, arg);
mini/mini-x86.c:			if (cfg->compute_gc_maps) {
mini/mini-x86.c:			MONO_ADD_INS (cfg->cbb, vtarg);
mini/mini-x86.c:		if (cfg->gsharedvt && mini_is_gsharedvt_klass (ins->klass)) {
mini/mini-x86.c:				MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-x86.c:				MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
mini/mini-x86.c:				MONO_EMIT_NEW_UNALU (cfg, OP_LMOVE, cfg->ret->dreg, val->dreg);
mini/mini-x86.c:	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
mini/mini-x86.c:	if (cfg->compile_aot) {
mini/mini-x86.c:		x86_push_imm (code, cfg->method);
mini/mini-x86.c:		mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_METHODCONST, cfg->method);
mini/mini-x86.c:		x86_push_imm (code, cfg->method);
mini/mini-x86.c:		mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_ABS, func);
mini/mini-x86.c:	MonoMethod *method = cfg->method;
mini/mini-x86.c:	if (cfg->compile_aot) {
mini/mini-x86.c:		mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_METHODCONST, method);
mini/mini-x86.c:		mono_add_patch_info (cfg, code-cfg->native_code, MONO_PATCH_INFO_ABS, func);
mini/mini-x86.c:	x86_branch (code, cond, cfg->native_code + ins->inst_true_bb->native_offset, sign); \
mini/mini-x86.c:	mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_true_bb); \
mini/mini-x86.c:	if ((cfg->opt & MONO_OPT_BRANCH) && \
mini/mini-x86.c:			mono_add_patch_info (cfg, code - cfg->native_code,   \
mini/mini-x86.c:	if (cfg->abs_patches) {
mini/mini-x86.c:		jinfo = g_hash_table_lookup (cfg->abs_patches, data);
mini/mini-x86.c:	if (cfg->compile_aot)
mini/mini-x86.c:	pad_size = (guint32)(code + 1 - cfg->native_code) & 0x3;
mini/mini-x86.c:	mono_add_patch_info (cfg, code - cfg->native_code, patch_type, data);
mini/mini-x86.c:	bb->max_vreg = cfg->next_vreg;
mini/mini-x86.c:	if (cfg->opt & MONO_OPT_SSE2 && size < 8 && !(cfg->opt & MONO_OPT_SIMD)) {
mini/mini-x86.c:			if (cfg->param_area)
mini/mini-x86.c:				x86_lea_membase (code, X86_EDI, X86_ESP, 12 + ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-x86.c:		if (cfg->param_area)
mini/mini-x86.c:			x86_lea_membase (code, X86_EDI, X86_ESP, offset + ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-x86.c:	x86_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, ebx), X86_EBX, sizeof (mgreg_t));
mini/mini-x86.c:	x86_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, edi), X86_EDI, sizeof (mgreg_t));
mini/mini-x86.c:	x86_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, esi), X86_ESI, sizeof (mgreg_t));
mini/mini-x86.c:	x86_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, ebp), X86_EBP, sizeof (mgreg_t));
mini/mini-x86.c:	if (cfg->compile_aot) {
mini/mini-x86.c:		mono_add_patch_info (cfg, code + 1 - cfg->native_code, MONO_PATCH_INFO_IP, NULL);
mini/mini-x86.c:	x86_mov_membase_reg (code, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, eip), X86_EAX, sizeof (mgreg_t));
mini/mini-x86.c:	guint8 *code = cfg->native_code + cfg->code_len;
mini/mini-x86.c:	if (cfg->opt & MONO_OPT_LOOP) {
mini/mini-x86.c:		if (bb_is_loop_start (bb) && (pad = (cfg->code_len & (align - 1)))) {
mini/mini-x86.c:			/*g_print ("adding %d pad at %x to loop in %s\n", pad, cfg->code_len, cfg->method->name);*/
mini/mini-x86.c:			cfg->code_len += pad;
mini/mini-x86.c:			bb->native_offset = cfg->code_len;
mini/mini-x86.c:	if (cfg->verbose_level > 2)
mini/mini-x86.c:	if ((cfg->prof_options & MONO_PROFILE_COVERAGE) && cfg->coverage_info) {
mini/mini-x86.c:		MonoProfileCoverageInfo *cov = cfg->coverage_info;
mini/mini-x86.c:		g_assert (!cfg->compile_aot);
mini/mini-x86.c:	offset = code - cfg->native_code;
mini/mini-x86.c:    if (mono_break_at_bb_method && mono_method_desc_full_match (mono_break_at_bb_method, cfg->method) && bb->block_num == mono_break_at_bb_bb_num)
mini/mini-x86.c:		offset = code - cfg->native_code;
mini/mini-x86.c:		if (G_UNLIKELY (offset > (cfg->code_size - max_len - EXTRA_CODE_SPACE))) {
mini/mini-x86.c:			cfg->code_size *= 2;
mini/mini-x86.c:			cfg->native_code = mono_realloc_native_code(cfg);
mini/mini-x86.c:			code = cfg->native_code + offset;
mini/mini-x86.c:			cfg->stat_code_reallocs++;
mini/mini-x86.c:		if (cfg->debug_info)
mini/mini-x86.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-x86.c:			if (cfg->compile_aot)
mini/mini-x86.c:				MonoInst *var = cfg->arch.ss_tramp_var;
mini/mini-x86.c:			mono_add_seq_point (cfg, bb, ins, code - cfg->native_code);
mini/mini-x86.c:			MonoInst *var = cfg->arch.bp_tramp_var;
mini/mini-x86.c:			code = mono_arch_emit_load_got_addr (cfg->native_code, code, cfg, NULL);
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			offset = code - cfg->native_code;
mini/mini-x86.c:			g_assert (!cfg->method->save_lmf);
mini/mini-x86.c:				if (X86_IS_CALLEE_SAVED_REG (i) && cfg->used_int_regs & (1 << i))
mini/mini-x86.c:			if (cfg->used_int_regs & (1 << X86_ESI)) {
mini/mini-x86.c:			if (cfg->used_int_regs & (1 << X86_EDI)) {
mini/mini-x86.c:			if (cfg->used_int_regs & (1 << X86_EBX)) {
mini/mini-x86.c:			offset = code - cfg->native_code;
mini/mini-x86.c:			cfg->disable_aot = TRUE;
mini/mini-x86.c:			x86_lea_membase (code, hreg, X86_EBP, cfg->sig_cookie);
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			if (cfg->param_area)
mini/mini-x86.c:				x86_alu_reg_imm (code, X86_ADD, ins->dreg, ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-x86.c:			if (cfg->param_area)
mini/mini-x86.c:				x86_alu_reg_imm (code, X86_ADD, ins->dreg, ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, ins->inst_target_bb);
mini/mini-x86.c:			if (cfg->param_area)
mini/mini-x86.c:				x86_alu_reg_imm (code, X86_SUB, X86_ESP, ALIGN_TO (cfg->param_area, MONO_ARCH_FRAME_ALIGNMENT));
mini/mini-x86.c:			ins->inst_c0 = code - cfg->native_code;
mini/mini-x86.c:				x86_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
mini/mini-x86.c:				if ((cfg->opt & MONO_OPT_BRANCH) &&
mini/mini-x86.c:				if (cfg->compile_aot) {
mini/mini-x86.c:					mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_R8, ins->inst_p0);
mini/mini-x86.c:				if (cfg->compile_aot) {
mini/mini-x86.c:					mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_R4, ins->inst_p0);
mini/mini-x86.c:			if (cfg->compile_aot) {
mini/mini-x86.c:				mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_BB, tins->inst_true_bb);
mini/mini-x86.c:				if ((cfg->opt & MONO_OPT_BRANCH) && x86_is_imm8 (tins->inst_true_bb->max_offset - cpos))
mini/mini-x86.c:				mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_EXC, "OverflowException");
mini/mini-x86.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-x86.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-x86.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-x86.c:			g_assert (cfg->opt & MONO_OPT_CMOV);
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			if (cfg->opt & MONO_OPT_FCMOV) {
mini/mini-x86.c:			g_assert (cfg->has_atomic_add_i4);
mini/mini-x86.c:			g_assert (cfg->has_atomic_exchange_i4);
mini/mini-x86.c:			if (cfg->verbose_level)
mini/mini-x86.c:			if (cfg->verbose_level > 1)
mini/mini-x86.c:				printf ("R%d START=0x%x\n", MONO_VARINFO (cfg, ins->inst_c0)->vreg, (int)(code - cfg->native_code));
mini/mini-x86.c:			MONO_VARINFO (cfg, ins->inst_c0)->live_range_start = code - cfg->native_code;
mini/mini-x86.c:			if (cfg->verbose_level > 1)
mini/mini-x86.c:				printf ("R%d END=0x%x\n", MONO_VARINFO (cfg, ins->inst_c0)->vreg, (int)(code - cfg->native_code));
mini/mini-x86.c:			MONO_VARINFO (cfg, ins->inst_c0)->live_range_end = code - cfg->native_code;
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			ins->backend.pc_offset = code - cfg->native_code;
mini/mini-x86.c:			bb->spill_slot_defs = g_slist_prepend_mempool (cfg->mempool, bb->spill_slot_defs, ins);
mini/mini-x86.c:		if (G_UNLIKELY ((code - cfg->native_code - offset) > max_len)) {
mini/mini-x86.c:					   mono_inst_name (ins->opcode), max_len, code - cfg->native_code - offset);
mini/mini-x86.c:	cfg->code_len = code - cfg->native_code;
mini/mini-x86.c:	MonoMethod *method = cfg->method;
mini/mini-x86.c:	cfg->code_size = MAX (cfg->header->code_size * 4, 10240);
mini/mini-x86.c:	if (cfg->prof_options & MONO_PROFILE_ENTER_LEAVE)
mini/mini-x86.c:		cfg->code_size += 512;
mini/mini-x86.c:	code = cfg->native_code = g_malloc (cfg->code_size);
mini/mini-x86.c:	x86_push_imm (code, cfg->method);
mini/mini-x86.c:		cfg->frame_reg = X86_ESP;
mini/mini-x86.c:	cfg->stack_offset += cfg->param_area;
mini/mini-x86.c:	cfg->stack_offset = ALIGN_TO (cfg->stack_offset, MONO_ARCH_FRAME_ALIGNMENT);
mini/mini-x86.c:	alloc_size = cfg->stack_offset;
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EBX)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EDI)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_ESI)) {
mini/mini-x86.c:	cfg->arch.sp_fp_offset = alloc_size + pos;
mini/mini-x86.c:		guint32 offset = code - cfg->native_code;
mini/mini-x86.c:		if (G_UNLIKELY (required_code_size >= (cfg->code_size - offset))) {
mini/mini-x86.c:			while (required_code_size >= (cfg->code_size - offset))
mini/mini-x86.c:				cfg->code_size *= 2;
mini/mini-x86.c:			cfg->native_code = mono_realloc_native_code(cfg);
mini/mini-x86.c:			code = cfg->native_code + offset;
mini/mini-x86.c:			cfg->stat_code_reallocs++;
mini/mini-x86.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED ||
mini/mini-x86.c:			cfg->method->wrapper_type == MONO_WRAPPER_RUNTIME_INVOKE) {
mini/mini-x86.c:	if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini-x86.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini-x86.c:			if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini-x86.c:			if ((cfg->opt & MONO_OPT_LOOP) && bb_is_loop_start (bb))
mini/mini-x86.c:	if (cfg->rgctx_var) {
mini/mini-x86.c:		g_assert (cfg->rgctx_var->opcode == OP_REGOFFSET && cfg->rgctx_var->inst_basereg == X86_EBP);
mini/mini-x86.c:		x86_mov_membase_reg (code, X86_EBP, cfg->rgctx_var->inst_offset, MONO_ARCH_RGCTX_REG, 4);
mini/mini-x86.c:		code = emit_setup_lmf (cfg, code, cfg->lmf_var->inst_offset, cfa_offset);
mini/mini-x86.c:		if (cfg->arch.ss_tramp_var) {
mini/mini-x86.c:			ins = cfg->arch.ss_tramp_var;
mini/mini-x86.c:			g_assert (!cfg->compile_aot);
mini/mini-x86.c:		if (cfg->arch.bp_tramp_var) {
mini/mini-x86.c:			ins = cfg->arch.bp_tramp_var;
mini/mini-x86.c:			g_assert (!cfg->compile_aot);
mini/mini-x86.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-x86.c:		inst = cfg->args [pos];
mini/mini-x86.c:			if (cfg->verbose_level > 2)
mini/mini-x86.c:	cfg->code_len = code - cfg->native_code;
mini/mini-x86.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-x86.c:	MonoMethod *method = cfg->method;
mini/mini-x86.c:	if (cfg->method->save_lmf)
mini/mini-x86.c:	while (cfg->code_len + max_epilog_size > (cfg->code_size - 16)) {
mini/mini-x86.c:		cfg->code_size *= 2;
mini/mini-x86.c:		cfg->native_code = mono_realloc_native_code(cfg);
mini/mini-x86.c:		cfg->stat_code_reallocs++;
mini/mini-x86.c:	code = cfg->native_code + cfg->code_len;
mini/mini-x86.c:		gint32 lmf_offset = cfg->lmf_var->inst_offset;
mini/mini-x86.c:		if (!cfg->compile_aot && mono_arch_have_fast_tls () && mono_tls_get_tls_offset (TLS_KEY_JIT_TLS) != -1) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EBX)) {
mini/mini-x86.c:			x86_mov_reg_membase (code, X86_EBX, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, ebx), 4);
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EDI)) {
mini/mini-x86.c:			x86_mov_reg_membase (code, X86_EDI, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, edi), 4);
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_ESI)) {
mini/mini-x86.c:			x86_mov_reg_membase (code, X86_ESI, cfg->frame_reg, lmf_offset + MONO_STRUCT_OFFSET (MonoLMF, esi), 4);
mini/mini-x86.c:			if ((cfg->used_int_regs & X86_CALLER_REGS & (1 << i)) && (i != X86_EBP)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_ESI)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EDI)) {
mini/mini-x86.c:		if (cfg->used_int_regs & (1 << X86_EBX)) {
mini/mini-x86.c:	cinfo = (CallInfo *)cfg->arch.cinfo;
mini/mini-x86.c:				x86_mov_reg_membase (code, cinfo->ret.pair_regs [quad], cfg->ret->inst_basereg, cfg->ret->inst_offset + (quad * sizeof (gpointer)), 4);
mini/mini-x86.c:				x86_fld_membase (code, cfg->ret->inst_basereg, cfg->ret->inst_offset + (quad * sizeof (gpointer)), FALSE);
mini/mini-x86.c:				x86_fld_membase (code, cfg->ret->inst_basereg, cfg->ret->inst_offset + (quad * sizeof (gpointer)), TRUE);
mini/mini-x86.c:	cfg->code_len = code - cfg->native_code;
mini/mini-x86.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-x86.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-x86.c:	if (cfg->compile_aot)
mini/mini-x86.c:	while (cfg->code_len + code_size > (cfg->code_size - 16)) {
mini/mini-x86.c:		cfg->code_size *= 2;
mini/mini-x86.c:		cfg->native_code = mono_realloc_native_code(cfg);
mini/mini-x86.c:		cfg->stat_code_reallocs++;
mini/mini-x86.c:	code = cfg->native_code + cfg->code_len;
mini/mini-x86.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini-x86.c:			x86_patch (patch_info->ip.i + cfg->native_code, code);
mini/mini-x86.c:				x86_push_imm (code, (exc_throw_end [i] - cfg->native_code) - throw_ip);
mini/mini-x86.c:				if ((code - cfg->native_code) - throw_ip < 126 - size) {
mini/mini-x86.c:				patch_info->ip.i = code - cfg->native_code;
mini/mini-x86.c:				x86_push_imm (buf, (code - cfg->native_code) - throw_ip);
mini/mini-x86.c:	cfg->code_len = code - cfg->native_code;
mini/mini-x86.c:	g_assert (cfg->code_len < cfg->code_size);
mini/mini-x86.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		if (cfg->opt & MONO_OPT_CMOV) {
mini/mini-x86.c:				MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:	if (!cfg->fconv_to_r8_x_var) {
mini/mini-x86.c:		cfg->fconv_to_r8_x_var = mono_compile_create_var (cfg, &mono_defaults.double_class->byval_arg, OP_LOCAL);
mini/mini-x86.c:		cfg->fconv_to_r8_x_var->flags |= MONO_INST_VOLATILE; /*FIXME, use the don't regalloc flag*/
mini/mini-x86.c:	return cfg->fconv_to_r8_x_var;
mini/mini-x86.c:	if (!(cfg->opt & MONO_OPT_SSE2) || !(cfg->opt & MONO_OPT_SIMD) || COMPILE_LLVM (cfg))
mini/mini-x86.c:	mono_bblock_insert_before_ins (cfg->cbb, ins, fconv);
mini/mini-x86.c:	if (!(cfg->opt & MONO_OPT_SIMD))
mini/mini-x86.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/mini-x86.c:		mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_GOT_OFFSET, NULL);
mini/mini-x86.c:		mono_add_patch_info (cfg, code - cfg->native_code, tramp_type, target);
mini/mini.c:	return g_realloc (cfg->native_code, cfg->code_size);
mini/mini.c: * cfg->unwind_ops.
mini/mini.c:	MonoUnwindOp *op = (MonoUnwindOp *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoUnwindOp));
mini/mini.c:	cfg->unwind_ops = g_slist_append_mempool (cfg->mempool, cfg->unwind_ops, op);
mini/mini.c:	if (cfg->verbose_level > 1) {
mini/mini.c:	MonoMethodHeader *header = cfg->header;
mini/mini.c:		MonoMethodHeader *header = cfg->header;
mini/mini.c:	return (MonoInst *)g_hash_table_lookup (cfg->spvars, GINT_TO_POINTER (region));
mini/mini.c:		g_assert (cfg->gshared);
mini/mini.c:	if (cfg->gshared && !type->byref && (type->type == MONO_TYPE_VAR || type->type == MONO_TYPE_MVAR)) {
mini/mini.c:	bb->max_vreg = MAX (bb->max_vreg, cfg->next_vreg);
mini/mini.c:	if (vreg >= cfg->vreg_to_inst_len) {
mini/mini.c:		MonoInst **tmp = cfg->vreg_to_inst;
mini/mini.c:		int size = cfg->vreg_to_inst_len;
mini/mini.c:		while (vreg >= cfg->vreg_to_inst_len)
mini/mini.c:			cfg->vreg_to_inst_len = cfg->vreg_to_inst_len ? cfg->vreg_to_inst_len * 2 : 32;
mini/mini.c:		cfg->vreg_to_inst = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst*) * cfg->vreg_to_inst_len);
mini/mini.c:			memcpy (cfg->vreg_to_inst, tmp, size * sizeof (MonoInst*));
mini/mini.c:	cfg->vreg_to_inst [vreg] = inst;
mini/mini.c:	int num = cfg->num_varinfo;
mini/mini.c:	if ((num + 1) >= cfg->varinfo_count) {
mini/mini.c:		int orig_count = cfg->varinfo_count;
mini/mini.c:		cfg->varinfo_count = cfg->varinfo_count ? (cfg->varinfo_count * 2) : 32;
mini/mini.c:		cfg->varinfo = (MonoInst **)g_realloc (cfg->varinfo, sizeof (MonoInst*) * cfg->varinfo_count);
mini/mini.c:		cfg->vars = (MonoMethodVar *)g_realloc (cfg->vars, sizeof (MonoMethodVar) * cfg->varinfo_count);
mini/mini.c:		memset (&cfg->vars [orig_count], 0, (cfg->varinfo_count - orig_count) * sizeof (MonoMethodVar));
mini/mini.c:	cfg->stat_allocate_var++;
mini/mini.c:	if (cfg->compute_gc_maps) {
mini/mini.c:	cfg->varinfo [num] = inst;
mini/mini.c:	MONO_INIT_VARINFO (&cfg->vars [num], num);
mini/mini.c:		 * put it into the cfg->varinfo array, confusing many parts of the JIT.
mini/mini.c:		if (cfg->verbose_level >= 4) {
mini/mini.c:		if (mono_arch_is_soft_float () && cfg->opt & MONO_OPT_SSA) {
mini/mini.c:		if (cfg->opt & MONO_OPT_SSA)
mini/mini.c:		if (cfg->opt & MONO_OPT_SSA)
mini/mini.c:	cfg->num_varinfo++;
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:	if (!cfg->iconv_raw_var) {
mini/mini.c:		cfg->iconv_raw_var = mono_compile_create_var (cfg, &mono_defaults.int32_class->byval_arg, OP_LOCAL);
mini/mini.c:		cfg->iconv_raw_var->flags |= MONO_INST_VOLATILE; /*FIXME, use the don't regalloc flag*/
mini/mini.c:	return cfg->iconv_raw_var;
mini/mini.c:	if (vreg >= cfg->vreg_is_ref_len) {
mini/mini.c:		gboolean *tmp = cfg->vreg_is_ref;
mini/mini.c:		int size = cfg->vreg_is_ref_len;
mini/mini.c:		while (vreg >= cfg->vreg_is_ref_len)
mini/mini.c:			cfg->vreg_is_ref_len = cfg->vreg_is_ref_len ? cfg->vreg_is_ref_len * 2 : 32;
mini/mini.c:		cfg->vreg_is_ref = (gboolean *)mono_mempool_alloc0 (cfg->mempool, sizeof (gboolean) * cfg->vreg_is_ref_len);
mini/mini.c:			memcpy (cfg->vreg_is_ref, tmp, size * sizeof (gboolean));
mini/mini.c:	cfg->vreg_is_ref [vreg] = TRUE;
mini/mini.c:	if (vreg >= cfg->vreg_is_mp_len) {
mini/mini.c:		gboolean *tmp = cfg->vreg_is_mp;
mini/mini.c:		int size = cfg->vreg_is_mp_len;
mini/mini.c:		while (vreg >= cfg->vreg_is_mp_len)
mini/mini.c:			cfg->vreg_is_mp_len = cfg->vreg_is_mp_len ? cfg->vreg_is_mp_len * 2 : 32;
mini/mini.c:		cfg->vreg_is_mp = (gboolean *)mono_mempool_alloc0 (cfg->mempool, sizeof (gboolean) * cfg->vreg_is_mp_len);
mini/mini.c:			memcpy (cfg->vreg_is_mp, tmp, size * sizeof (gboolean));
mini/mini.c:	cfg->vreg_is_mp [vreg] = TRUE;
mini/mini.c:	MonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc (cfg->mempool, sizeof (MonoJumpInfo));
mini/mini.c:	table = (MonoJumpInfoBBTable *)mono_mempool_alloc (cfg->mempool, sizeof (MonoJumpInfoBBTable));
mini/mini.c:	ji->next = cfg->patch_info;
mini/mini.c:	cfg->patch_info = ji;
mini/mini.c:	is_fulltrust = mono_verifier_is_method_full_trust (method) ||  mini_assembly_can_skip_verification (cfg->domain, method);
mini/mini.c:	res = mono_method_verify_with_current_settings (method, cfg->skip_visibility, is_fulltrust);
mini/mini.c:					cfg->exception_type = info->exception_type;
mini/mini.c:					cfg->exception_message = g_strdup_printf ("Error verifying %s: %s", method_name, info->info.message);
mini/mini.c:						mono_error_set_generic_error (&cfg->error, "System", "MethodAccessException", "%s", msg);
mini/mini.c:						mono_error_set_generic_error (&cfg->error, "System", "FieldAccessException", "%s", msg);
mini/mini.c:						mono_error_set_generic_error (&cfg->error, "System.Security", "VerificationException", "%s", msg);
mini/mini.c:					if (!mono_error_ok (&cfg->error)) {
mini/mini.c:						cfg->exception_type = info->exception_type;
mini/mini.c:						cfg->exception_message = msg;
mini/mini.c:	LSCAN_DEBUG (printf ("Allocate Stack Slots 2 for %s:\n", mono_method_full_name (cfg->method, TRUE)));
mini/mini.c:	scalar_stack_slots = (StackSlotInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (StackSlotInfo) * MONO_TYPE_PINNED);
mini/mini.c:	offsets = (gint32 *)mono_mempool_alloc (cfg->mempool, sizeof (gint32) * cfg->num_varinfo);
mini/mini.c:	for (i = 0; i < cfg->num_varinfo; ++i)
mini/mini.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini.c:		inst = cfg->varinfo [i];
mini/mini.c:		inst = cfg->varinfo [vmv->idx];
mini/mini.c:		if (cfg->gsharedvt && mini_is_gsharedvt_variable_type (t))
mini/mini.c:		if (cfg->disable_reuse_stack_slots)
mini/mini.c:				vtype_stack_slots = (StackSlotInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (StackSlotInfo) * 256);
mini/mini.c:			if (cfg->disable_reuse_ref_stack_slots)
mini/mini.c:			if (cfg->disable_ref_noref_stack_slot_share) {
mini/mini.c:			if (cfg->disable_reuse_ref_stack_slots)
mini/mini.c:		if (cfg->comp_done & MONO_COMP_LIVENESS) {
mini/mini.c:						slot_info->slots = g_slist_prepend_mempool (cfg->mempool, slot_info->slots, GINT_TO_POINTER (offsets [v->idx]));
mini/mini.c:						LSCAN_DEBUG (printf ("Interval R%d has expired, adding 0x%x to slots\n", cfg->varinfo [v->idx]->dreg, offsets [v->idx]));
mini/mini.c:						LSCAN_DEBUG (printf ("Interval R%d became inactive\n", cfg->varinfo [v->idx]->dreg));
mini/mini.c:						//slot_info->slots = g_slist_prepend_mempool (cfg->mempool, slot_info->slots, GINT_TO_POINTER (offsets [v->idx]));
mini/mini.c:						LSCAN_DEBUG (printf ("Interval R%d has expired, adding 0x%x to slots\n", cfg->varinfo [v->idx]->dreg, offsets [v->idx]));
mini/mini.c:						LSCAN_DEBUG (printf ("\tInterval R%d became active\n", cfg->varinfo [v->idx]->dreg));
mini/mini.c:				printf ("LAST: %s\n", mono_method_full_name (cfg->method, TRUE));
mini/mini.c:	cfg->stat_locals_stack_size += offset;
mini/mini.c:	if ((cfg->num_varinfo > 0) && MONO_VARINFO (cfg, 0)->interval)
mini/mini.c:	scalar_stack_slots = (StackSlotInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (StackSlotInfo) * MONO_TYPE_PINNED);
mini/mini.c:	offsets = (gint32 *)mono_mempool_alloc (cfg->mempool, sizeof (gint32) * cfg->num_varinfo);
mini/mini.c:	for (i = 0; i < cfg->num_varinfo; ++i)
mini/mini.c:	for (i = cfg->locals_start; i < cfg->num_varinfo; i++) {
mini/mini.c:		inst = cfg->varinfo [i];
mini/mini.c:		inst = cfg->varinfo [vmv->idx];
mini/mini.c:		if (cfg->gsharedvt && mini_is_gsharedvt_variable_type (t))
mini/mini.c:		if (cfg->disable_reuse_stack_slots)
mini/mini.c:				vtype_stack_slots = (StackSlotInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (StackSlotInfo) * 256);
mini/mini.c:			if (cfg->disable_reuse_ref_stack_slots)
mini/mini.c:			if (cfg->disable_ref_noref_stack_slot_share) {
mini/mini.c:			if (cfg->disable_reuse_ref_stack_slots)
mini/mini.c:		if (cfg->comp_done & MONO_COMP_LIVENESS) {
mini/mini.c:				slot_info->slots = g_slist_prepend_mempool (cfg->mempool, slot_info->slots, GINT_TO_POINTER (offsets [amv->idx]));
mini/mini.c:				printf ("LAST: %s\n", mono_method_full_name (cfg->method, TRUE));
mini/mini.c:	cfg->stat_locals_stack_size += offset;
mini/mini.c:		char *method_name = mono_method_full_name (cfg->method, TRUE);
mini/mini.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/mini.c:		bb = cfg->bblocks [i];
mini/mini.c:			code1 = mono_disasm_code_one (NULL, cfg->method, bb->cil_code, NULL);
mini/mini.c:				code2 = mono_disasm_code_one (NULL, cfg->method, bb->last_ins->cil_code, NULL);
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini.c:	for (GSList *l = cfg->headers_to_free; l; l = l->next) {
mini/mini.c:	cfg->headers_to_free = NULL;
mini/mini.c:	if (cfg->mempool) {
mini/mini.c:	//mono_mempool_stats (cfg->mempool);
mini/mini.c:		mono_mempool_destroy (cfg->mempool);
mini/mini.c:		cfg->mempool = NULL;
mini/mini.c:	g_free (cfg->varinfo);
mini/mini.c:	cfg->varinfo = NULL;
mini/mini.c:	g_free (cfg->vars);
mini/mini.c:	cfg->vars = NULL;
mini/mini.c:	if (cfg->rs) {
mini/mini.c:		mono_regstate_free (cfg->rs);
mini/mini.c:		cfg->rs = NULL;
mini/mini.c:	if (cfg->header)
mini/mini.c:		mono_metadata_free_mh (cfg->header);
mini/mini.c:	if (cfg->spvars)
mini/mini.c:		g_hash_table_destroy (cfg->spvars);
mini/mini.c:	if (cfg->exvars)
mini/mini.c:		g_hash_table_destroy (cfg->exvars);
mini/mini.c:	g_list_free (cfg->ldstr_list);
mini/mini.c:	if (cfg->token_info_hash)
mini/mini.c:		g_hash_table_destroy (cfg->token_info_hash);
mini/mini.c:	if (cfg->abs_patches)
mini/mini.c:		g_hash_table_destroy (cfg->abs_patches);
mini/mini.c:	g_free (cfg->varinfo);
mini/mini.c:	g_free (cfg->vars);
mini/mini.c:	g_free (cfg->exception_message);
mini/mini.c:	MonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfo));
mini/mini.c:	ji->next = cfg->patch_info;
mini/mini.c:	cfg->patch_info = ji;
mini/mini.c:	MonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoJumpInfo));
mini/mini.c:	ji->next = cfg->patch_info;
mini/mini.c:	cfg->patch_info = ji;
mini/mini.c:	MonoJumpInfo **ji = &cfg->patch_info;
mini/mini.c:	g_ptr_array_add (cfg->seq_points, ins);
mini/mini.c:		bb->seq_points = g_slist_prepend_mempool (cfg->mempool, bb->seq_points, ins);
mini/mini.c:	MonoDwarfLocListEntry *entry = (MonoDwarfLocListEntry *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoDwarfLocListEntry));
mini/mini.c:	if (var == cfg->args [0])
mini/mini.c:		cfg->this_loclist = g_slist_append_mempool (cfg->mempool, cfg->this_loclist, entry);
mini/mini.c:	else if (var == cfg->rgctx_var)
mini/mini.c:		cfg->rgctx_loclist = g_slist_append_mempool (cfg->mempool, cfg->rgctx_loclist, entry);
mini/mini.c:	header = cfg->header;
mini/mini.c:	sig = mono_method_signature (cfg->method);
mini/mini.c:		cfg->ret = mono_compile_create_var (cfg, sig->ret, OP_ARG);
mini/mini.c:		cfg->ret->flags |= MONO_INST_VOLATILE;
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:	cfg->args = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, (sig->param_count + sig->hasthis) * sizeof (MonoInst*));
mini/mini.c:		cfg->args [0] = mono_compile_create_var (cfg, &cfg->method->klass->this_arg, OP_ARG);
mini/mini.c:		cfg->this_arg = cfg->args [0];
mini/mini.c:		cfg->args [i + sig->hasthis] = mono_compile_create_var (cfg, sig->params [i], OP_ARG);
mini/mini.c:	if (cfg->verbose_level > 2) {
mini/mini.c:		if (cfg->ret) {
mini/mini.c:			mono_print_ins (cfg->ret);
mini/mini.c:			mono_print_ins (cfg->args [0]);
mini/mini.c:			mono_print_ins (cfg->args [i + sig->hasthis]);
mini/mini.c:	cfg->locals_start = cfg->num_varinfo;
mini/mini.c:	cfg->locals = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, header->num_locals * sizeof (MonoInst*));
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:		cfg->locals [i] = mono_compile_create_var (cfg, header->locals [i], OP_LOCAL);
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:	if (cfg->method->save_lmf && cfg->create_lmf_var) {
mini/mini.c:		cfg->lmf_var = lmf_var;
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini.c:	for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
mini/mini.c:				if (cfg->abs_patches) {
mini/mini.c:					MonoJumpInfo *abs_ji = (MonoJumpInfo *)g_hash_table_lookup (cfg->abs_patches, patch_info->data.target);
mini/mini.c:			if (cfg->method->dynamic) {
mini/mini.c:				table = (void **)mono_code_manager_reserve (cfg->dynamic_info->code_mp, sizeof (gpointer) * patch_info->data.table->table_size);
mini/mini.c:				table = (void **)mono_domain_code_reserve (cfg->domain, sizeof (gpointer) * patch_info->data.table->table_size);
mini/mini.c:			MonoDomain *domain = cfg->domain;
mini/mini.c:			unsigned char *ip = cfg->native_code + patch_info->ip.i;
mini/mini.c:		code_domain = cfg->domain;
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:		cfg->spill_count = 0;
mini/mini.c:		if (cfg->opt & MONO_OPT_PEEPHOLE)
mini/mini.c:		if (cfg->opt & MONO_OPT_PEEPHOLE)
mini/mini.c:		if (cfg->gen_seq_points && !cfg->gen_sdb_seq_points)
mini/mini.c:	if (cfg->prof_options & MONO_PROFILE_COVERAGE)
mini/mini.c:		cfg->coverage_info = mono_profiler_coverage_alloc (cfg->method, cfg->num_bblocks);
mini/mini.c:	cfg->code_len = code - cfg->native_code;
mini/mini.c:	cfg->prolog_end = cfg->code_len;
mini/mini.c:	cfg->cfa_reg = cfg->cur_cfa_reg;
mini/mini.c:	cfg->cfa_offset = cfg->cur_cfa_offset;
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:		bb->native_offset = cfg->code_len;
mini/mini.c:		bb->real_native_offset = cfg->code_len;
mini/mini.c:		//if ((bb == cfg->bb_entry) || !(bb->region == -1 && !bb->dfn))
mini/mini.c:		bb->native_length = cfg->code_len - bb->native_offset;
mini/mini.c:		if (bb == cfg->bb_exit) {
mini/mini.c:			cfg->epilog_begin = cfg->code_len;
mini/mini.c:			cfg->epilog_end = cfg->code_len;
mini/mini.c:	/* we always allocate code in cfg->domain->code_mp to increase locality */
mini/mini.c:	cfg->code_size = cfg->code_len + max_epilog_size;
mini/mini.c:	unwindlen = mono_arch_unwindinfo_get_size (cfg->arch.unwindinfo);
mini/mini.c:	if (cfg->method->dynamic) {
mini/mini.c:		cfg->dynamic_info = g_new0 (MonoJitDynamicMethodInfo, 1);
mini/mini.c:		cfg->dynamic_info->code_mp = mono_code_manager_new_dynamic ();
mini/mini.c:		mono_domain_lock (cfg->domain);
mini/mini.c:		mono_dynamic_code_hash_insert (cfg->domain, cfg->method, cfg->dynamic_info);
mini/mini.c:		mono_domain_unlock (cfg->domain);
mini/mini.c:			/* See the comment for cfg->code_domain */
mini/mini.c:			code = (guint8 *)mono_domain_code_reserve (code_domain, cfg->code_size + cfg->thunk_area + unwindlen);
mini/mini.c:			code = (guint8 *)mono_code_manager_reserve (cfg->dynamic_info->code_mp, cfg->code_size + cfg->thunk_area + unwindlen);
mini/mini.c:		code = (guint8 *)mono_domain_code_reserve (code_domain, cfg->code_size + cfg->thunk_area + unwindlen);
mini/mini.c:	if (cfg->thunk_area) {
mini/mini.c:		cfg->thunks_offset = cfg->code_size + unwindlen;
mini/mini.c:		cfg->thunks = code + cfg->thunks_offset;
mini/mini.c:		memset (cfg->thunks, 0, cfg->thunk_area);
mini/mini.c:	memcpy (code, cfg->native_code, cfg->code_len);
mini/mini.c:	g_free (cfg->native_code);
mini/mini.c:	cfg->native_code = code;
mini/mini.c:	code = cfg->native_code + cfg->code_len;
mini/mini.c:	/* g_assert (((int)cfg->native_code & (MONO_ARCH_CODE_ALIGNMENT - 1)) == 0); */
mini/mini.c:		char* nm = mono_method_full_name (cfg->method, TRUE);
mini/mini.c:		VALGRIND_JIT_REGISTER_MAP (nm, cfg->native_code, cfg->native_code + cfg->code_len);
mini/mini.c:	if (cfg->verbose_level > 0) {
mini/mini.c:		char* nm = mono_method_get_full_name (cfg->method);
mini/mini.c:				 cfg->native_code, cfg->native_code + cfg->code_len, cfg->code_len, cfg->domain->friendly_name);
mini/mini.c:		if (cfg->method->is_inflated || mono_method_get_generic_container (cfg->method) ||
mini/mini.c:				mono_class_is_gtd (cfg->method->klass) || mono_class_is_ginst (cfg->method->klass)) {
mini/mini.c:		if (cfg->gshared)
mini/mini.c:		for (ji = cfg->patch_info; ji; ji = ji->next) {
mini/mini.c:			if (cfg->compile_aot) {
mini/mini.c:			target = mono_resolve_patch_target (cfg->method, cfg->domain, cfg->native_code, ji, cfg->run_cctors, &cfg->error);
mini/mini.c:			if (!mono_error_ok (&cfg->error)) {
mini/mini.c:			mono_arch_patch_code_new (cfg, cfg->domain, cfg->native_code, ji, target);
mini/mini.c:	mono_arch_patch_code (cfg, cfg->method, cfg->domain, cfg->native_code, cfg->patch_info, cfg->run_cctors, &cfg->error);
mini/mini.c:	if (!is_ok (&cfg->error)) {
mini/mini.c:	if (cfg->method->dynamic) {
mini/mini.c:			mono_domain_code_commit (code_domain, cfg->native_code, cfg->code_size, cfg->code_len);
mini/mini.c:			mono_code_manager_commit (cfg->dynamic_info->code_mp, cfg->native_code, cfg->code_size, cfg->code_len);
mini/mini.c:		mono_domain_code_commit (code_domain, cfg->native_code, cfg->code_size, cfg->code_len);
mini/mini.c:	cfg->native_code = code_dest;
mini/mini.c:	mono_profiler_code_buffer_new (cfg->native_code, cfg->code_len, MONO_PROFILER_CODE_BUFFER_METHOD, cfg->method);
mini/mini.c:	mono_arch_flush_icache (cfg->native_code, cfg->code_len);
mini/mini.c:	mono_arch_unwindinfo_install_unwind_info (&cfg->arch.unwindinfo, cfg->native_code, cfg->code_len);
mini/mini.c:	cfg->bblocks = (MonoBasicBlock **)mono_mempool_alloc (cfg->mempool, sizeof (MonoBasicBlock*) * (cfg->num_bblocks + 1));
mini/mini.c:	cfg->max_block_num = cfg->num_bblocks;
mini/mini.c:	df_visit (cfg->bb_entry, &dfn, cfg->bblocks);
mini/mini.c:	if (cfg->num_bblocks != dfn + 1) {
mini/mini.c:		cfg->num_bblocks = dfn + 1;
mini/mini.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini.c:		compute_reachable (cfg->bb_entry);
mini/mini.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:				if (cfg->verbose_level > 1)
mini/mini.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:	g_assert (method_to_compile == cfg->method);
mini/mini.c:	header = cfg->header;
mini/mini.c:	if (cfg->gshared)
mini/mini.c:	if (cfg->arch_eh_jit_info) {
mini/mini.c:		MonoMethodSignature *sig = mono_method_signature (cfg->method_to_register);
mini/mini.c:	if (cfg->has_unwind_info_for_epilog && !(flags & JIT_INFO_HAS_ARCH_EH_INFO))
mini/mini.c:	if (cfg->thunk_area)
mini/mini.c:	if (cfg->try_block_holes) {
mini/mini.c:		for (tmp = cfg->try_block_holes; tmp; tmp = tmp->next) {
mini/mini.c:			MonoBasicBlock *clause_last_bb = cfg->cil_offset_to_bb [ec->try_offset + ec->try_len];
mini/mini.c:		if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/mini.c:		num_clauses = cfg->llvm_ex_info_len;
mini/mini.c:	if (cfg->method->dynamic)
mini/mini.c:		jinfo = (MonoJitInfo *)mono_domain_alloc0 (cfg->domain, mono_jit_info_size (flags, num_clauses, num_holes));
mini/mini.c:	mono_jit_info_init (jinfo, cfg->method_to_register, cfg->native_code, cfg->code_len, flags, num_clauses, num_holes);
mini/mini.c:	jinfo->domain_neutral = (cfg->opt & MONO_OPT_SHARED) != 0;
mini/mini.c:	if (cfg->gshared) {
mini/mini.c:		if (cfg->method->dynamic)
mini/mini.c:			gi->generic_sharing_context = (MonoGenericSharingContext *)mono_domain_alloc0 (cfg->domain, sizeof (MonoGenericSharingContext));
mini/mini.c:		mini_init_gsctx (cfg->method->dynamic ? NULL : cfg->domain, NULL, cfg->gsctx_context, gi->generic_sharing_context);
mini/mini.c:			g_assert (cfg->rgctx_var);
mini/mini.c:			inst = cfg->rgctx_var;
mini/mini.c:			loclist = cfg->rgctx_loclist;
mini/mini.c:			inst = cfg->args [0];
mini/mini.c:			loclist = cfg->this_loclist;
mini/mini.c:			if (cfg->method->dynamic)
mini/mini.c:				gi->locations = (MonoDwarfLocListEntry *)mono_domain_alloc0 (cfg->domain, gi->nlocs * sizeof (MonoDwarfLocListEntry));
mini/mini.c:			g_assert (cfg->llvm_this_reg != -1);
mini/mini.c:			gi->this_reg = cfg->llvm_this_reg;
mini/mini.c:			gi->this_offset = cfg->llvm_this_offset;
mini/mini.c:		for (tmp = cfg->try_block_holes; tmp; tmp = tmp->next) {
mini/mini.c:			MonoBasicBlock *clause_last_bb = cfg->cil_offset_to_bb [ec->try_offset + ec->try_len];
mini/mini.c:			if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/mini.c:	if (cfg->thunk_area) {
mini/mini.c:		info->thunks_offset = cfg->thunks_offset;
mini/mini.c:		info->thunks_size = cfg->thunk_area;
mini/mini.c:			memcpy (&jinfo->clauses [0], &cfg->llvm_ex_info [0], num_clauses * sizeof (MonoJitExceptionInfo));
mini/mini.c:			if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/mini.c:				tblock = cfg->cil_offset_to_bb [ec->data.filter_offset];
mini/mini.c:				ei->data.filter = cfg->native_code + tblock->native_offset;
mini/mini.c:			tblock = cfg->cil_offset_to_bb [ec->try_offset];
mini/mini.c:			ei->try_start = cfg->native_code + tblock->native_offset;
mini/mini.c:				ei->try_start = (guint8*)ei->try_start - cfg->backend->monitor_enter_adjustment;
mini/mini.c:				tblock = cfg->cil_offset_to_bb [ec->try_offset + ec->try_len];
mini/mini.c:				tblock = cfg->bb_exit;
mini/mini.c:			if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/mini.c:					MonoBasicBlock *bb = cfg->cil_offset_to_bb [j];
mini/mini.c:			ei->try_end = cfg->native_code + tblock->native_offset;
mini/mini.c:			tblock = cfg->cil_offset_to_bb [ec->handler_offset];
mini/mini.c:			ei->handler_start = cfg->native_code + tblock->native_offset;
mini/mini.c:			for (tmp = cfg->try_block_holes; tmp; tmp = tmp->next) {
mini/mini.c:				gpointer hole_end = cfg->native_code + (hole->basic_block->native_offset + hole->basic_block->native_length);
mini/mini.c:					if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/mini.c:						printf ("\tShortening try block %d from %x to %x\n", i, (int)((guint8*)ei->try_end - cfg->native_code), hole->start_offset);
mini/mini.c:					ei->try_end = cfg->native_code + hole->start_offset;
mini/mini.c:					tblock = cfg->cil_offset_to_bb [ec->handler_offset + ec->handler_len];
mini/mini.c:							MonoBasicBlock *bb = cfg->cil_offset_to_bb [j];
mini/mini.c:					end_offset = cfg->epilog_begin;
mini/mini.c:				ei->data.handler_end = cfg->native_code + end_offset;
mini/mini.c:	if (G_UNLIKELY (cfg->verbose_level >= 4)) {
mini/mini.c:			int start = (guint8*)ei->try_start - cfg->native_code;
mini/mini.c:			int end = (guint8*)ei->try_end - cfg->native_code;
mini/mini.c:			int handler = (guint8*)ei->handler_start - cfg->native_code;
mini/mini.c:			int handler_end = (guint8*)ei->data.handler_end - cfg->native_code;
mini/mini.c:	if (cfg->encoded_unwind_ops) {
mini/mini.c:		jinfo->unwind_info = mono_cache_unwind_info (cfg->encoded_unwind_ops, cfg->encoded_unwind_ops_len);
mini/mini.c:		g_free (cfg->encoded_unwind_ops);
mini/mini.c:	} else if (cfg->unwind_ops) {
mini/mini.c:		guint8 *unwind_info = mono_unwind_ops_encode (cfg->unwind_ops, &info_len);
mini/mini.c:		if (cfg->has_unwind_info_for_epilog) {
mini/mini.c:			info->epilog_size = cfg->code_len - cfg->epilog_begin;
mini/mini.c:		jinfo->unwind_info = cfg->used_int_regs;
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:	if (cfg->disable_gc_safe_points)
mini/mini.c:	if (cfg->verbose_level > 1)
mini/mini.c:	} else if (bblock == cfg->bb_entry) {
mini/mini.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
mini/mini.c:		WrapperInfo *info = mono_marshal_get_wrapper_info (cfg->method);
mini/mini.c:			if (cfg->verbose_level > 1)
mini/mini.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED) {
mini/mini.c:		if (cfg->verbose_level > 1)
mini/mini.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
mini/mini.c:		WrapperInfo *info = mono_marshal_get_wrapper_info (cfg->method);
mini/mini.c:			if (cfg->verbose_level > 1)
mini/mini.c:				printf ("SKIPPING SAFEPOINTS for wrapper %s\n", cfg->method->name);
mini/mini.c:	if (cfg->verbose_level > 1)
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:		if (bb->loop_body_start || bb == cfg->bb_entry || bb->flags & BB_EXCEPTION_HANDLER)
mini/mini.c:	if (cfg->verbose_level > 2)
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:				MonoInst *inst = (MonoInst *)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst));
mini/mini.c:	if (cfg->verbose_level >= 4) {
mini/mini.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/mini.c:		bb->max_vreg = cfg->next_vreg;
mini/mini.c:	cfg->method = method_to_compile;
mini/mini.c:	cfg->mempool = mono_mempool_new ();
mini/mini.c:	cfg->opt = opts;
mini/mini.c:	cfg->prof_options = mono_profiler_get_events ();
mini/mini.c:	cfg->run_cctors = run_cctors;
mini/mini.c:	cfg->domain = domain;
mini/mini.c:	cfg->verbose_level = mini_verbose;
mini/mini.c:	cfg->compile_aot = compile_aot;
mini/mini.c:	cfg->full_aot = full_aot;
mini/mini.c:	cfg->disable_omit_fp = debug_options.disable_omit_fp;
mini/mini.c:	cfg->skip_visibility = method->skip_visibility;
mini/mini.c:	cfg->orig_method = method;
mini/mini.c:	cfg->gen_seq_points = !debug_options.no_seq_points_compact_data || debug_options.gen_sdb_seq_points;
mini/mini.c:	cfg->gen_sdb_seq_points = debug_options.gen_sdb_seq_points;
mini/mini.c:	cfg->llvm_only = (flags & JIT_FLAG_LLVM_ONLY) != 0;
mini/mini.c:	cfg->backend = current_backend;
mini/mini.c:	if (cfg->method->wrapper_type != MONO_WRAPPER_NONE) {
mini/mini.c:		cfg->gen_seq_points = FALSE;
mini/mini.c:		cfg->gen_sdb_seq_points = FALSE;
mini/mini.c:	if (cfg->method->wrapper_type == MONO_WRAPPER_ALLOC) {
mini/mini.c:		cfg->gen_seq_points = FALSE;
mini/mini.c:		cfg->gen_sdb_seq_points = FALSE;
mini/mini.c:	cfg->opt |= MONO_OPT_LOOP;
mini/mini.c:		cfg->opt |= MONO_OPT_LOOP;
mini/mini.c:	cfg->explicit_null_checks = debug_options.explicit_null_checks || (flags & JIT_FLAG_EXPLICIT_NULL_CHECKS);
mini/mini.c:	cfg->soft_breakpoints = debug_options.soft_breakpoints;
mini/mini.c:	cfg->check_pinvoke_callconv = debug_options.check_pinvoke_callconv;
mini/mini.c:	cfg->disable_direct_icalls = disable_direct_icalls;
mini/mini.c:	cfg->direct_pinvoke = (flags & JIT_FLAG_DIRECT_PINVOKE) != 0;
mini/mini.c:		cfg->gshared = TRUE;
mini/mini.c:	cfg->compile_llvm = try_llvm;
mini/mini.c:	cfg->token_info_hash = g_hash_table_new (NULL, NULL);
mini/mini.c:	if (cfg->compile_aot)
mini/mini.c:		cfg->method_index = aot_method_index;
mini/mini.c:		cfg->opt &= ~MONO_OPT_FLOAT32;
mini/mini.c:	if (cfg->llvm_only)
mini/mini.c:		cfg->opt &= ~MONO_OPT_SIMD;
mini/mini.c:	cfg->r4fp = (cfg->opt & MONO_OPT_FLOAT32) ? 1 : 0;
mini/mini.c:	cfg->r4_stack_type = cfg->r4fp ? STACK_R4 : STACK_R8;
mini/mini.c:	if (cfg->gen_seq_points)
mini/mini.c:		cfg->seq_points = g_ptr_array_new ();
mini/mini.c:	mono_error_init (&cfg->error);
mini/mini.c:	if (cfg->compile_aot && !try_generic_shared && (method->is_generic || mono_class_is_gtd (method->klass) || method_is_gshared)) {
mini/mini.c:		cfg->exception_type = MONO_EXCEPTION_GENERIC_SHARING_FAILED;
mini/mini.c:	if (cfg->gshared && (gsharedvt_method || mini_is_gsharedvt_sharable_method (method))) {
mini/mini.c:		mini_init_gsctx (NULL, cfg->mempool, context, &cfg->gsctx);
mini/mini.c:		cfg->gsctx_context = context;
mini/mini.c:		cfg->gsharedvt = TRUE;
mini/mini.c:		if (!cfg->llvm_only) {
mini/mini.c:			cfg->disable_llvm = TRUE;
mini/mini.c:			cfg->exception_message = g_strdup ("gsharedvt");
mini/mini.c:	if (cfg->gshared) {
mini/mini.c:	cfg->method_to_register = method_to_register;
mini/mini.c:	sig = mono_method_signature_checked (cfg->method, &err);	
mini/mini.c:		cfg->exception_type = MONO_EXCEPTION_TYPE_LOAD;
mini/mini.c:		cfg->exception_message = g_strdup (mono_error_get_message (&err));
mini/mini.c:	header = cfg->header = mono_method_get_header_checked (cfg->method, &cfg->error);
mini/mini.c:			if (cfg->disable_llvm) {
mini/mini.c:				if (cfg->verbose_level >= (cfg->llvm_only ? 0 : 1)) {
mini/mini.c:					//nm = mono_method_full_name (cfg->method, TRUE);
mini/mini.c:					printf ("LLVM failed for '%s': %s\n", method->name, cfg->exception_message);
mini/mini.c:				if (cfg->llvm_only) {
mini/mini.c:					g_free (cfg->exception_message);
mini/mini.c:					cfg->disable_aot = TRUE;
mini/mini.c:		cfg->disable_reuse_registers = TRUE;
mini/mini.c:		cfg->disable_reuse_stack_slots = TRUE;
mini/mini.c:		cfg->disable_initlocals_opt = TRUE;
mini/mini.c:		cfg->extend_live_ranges = TRUE;
mini/mini.c:		cfg->disable_vreg_to_lvreg = TRUE;
mini/mini.c:		cfg->disable_deadce_vars = TRUE;
mini/mini.c:		cfg->opt &= ~MONO_OPT_DEADCE;
mini/mini.c:		cfg->opt &= ~MONO_OPT_INLINE;
mini/mini.c:		cfg->opt &= ~MONO_OPT_COPYPROP;
mini/mini.c:		cfg->opt &= ~MONO_OPT_CONSPROP;
mini/mini.c:		cfg->disable_out_of_line_bblocks = TRUE;
mini/mini.c:		cfg->disable_reuse_registers = TRUE;
mini/mini.c:		cfg->disable_reuse_stack_slots = TRUE;
mini/mini.c:		cfg->extend_live_ranges = TRUE;
mini/mini.c:		cfg->compute_precise_live_ranges = TRUE;
mini/mini.c:			cfg->disable_gc_safe_points = TRUE;
mini/mini.c:			cfg->gen_write_barriers = FALSE;
mini/mini.c:		cfg->opt |= MONO_OPT_ABCREM;
mini/mini.c:			if (mono_method_desc_full_match (desc, cfg->method)) {
mini/mini.c:				cfg->verbose_level = 4;
mini/mini.c:			if (strcmp (cfg->method->name, name) == 0)
mini/mini.c:				cfg->verbose_level = 4;
mini/mini.c:	cfg->intvars = (guint16 *)mono_mempool_alloc0 (cfg->mempool, sizeof (guint16) * STACK_MAX * header->max_stack);
mini/mini.c:	if (cfg->verbose_level > 0) {
mini/mini.c:		g_print ("converting %s%s%smethod %s\n", COMPILE_LLVM (cfg) ? "llvm " : "", cfg->gsharedvt ? "gsharedvt " : "", (cfg->gshared && !cfg->gsharedvt) ? "gshared " : "", method_name);
mini/mini.c:		else if (cfg->gsharedvt)
mini/mini.c:		else if (cfg->gshared)
mini/mini.c:	if (cfg->opt & MONO_OPT_ABCREM)
mini/mini.c:		cfg->opt |= MONO_OPT_SSA;
mini/mini.c:	cfg->rs = mono_regstate_new ();
mini/mini.c:	cfg->next_vreg = cfg->rs->next_vreg;
mini/mini.c:	if (cfg->opt & MONO_OPT_SSA)
mini/mini.c:		cfg->enable_extended_bblocks = FALSE;
mini/mini.c:	//cfg->enable_extended_bblocks = TRUE;
mini/mini.c:	if (mono_compile_is_broken (cfg, cfg->method, TRUE)) {
mini/mini.c:	if (cfg->gdump_ctx != NULL) {
mini/mini.c:		if (try_generic_shared && cfg->exception_type == MONO_EXCEPTION_GENERIC_SHARING_FAILED) {
mini/mini.c:		g_assert (cfg->exception_type != MONO_EXCEPTION_GENERIC_SHARING_FAILED);
mini/mini.c:	cfg->stat_basic_blocks += cfg->num_bblocks;
mini/mini.c:		cfg->opt |= MONO_OPT_SSA;
mini/mini.c:		if (cfg->ret) {
mini/mini.c:			cfg->ret->flags &= ~MONO_INST_VOLATILE;
mini/mini.c:			ins->sreg1 = cfg->ret->dreg;
mini/mini.c:			MONO_ADD_INS (cfg->bb_exit, ins);
mini/mini.c:		cfg->opt &= ~MONO_OPT_LINEARS;
mini/mini.c:		cfg->opt &= ~MONO_OPT_BRANCH;
mini/mini.c:	/*g_print ("numblocks = %d\n", cfg->num_bblocks);*/
mini/mini.c:	if (cfg->opt & (MONO_OPT_CONSPROP | MONO_OPT_COPYPROP)) {
mini/mini.c:	if (cfg->flags & MONO_CFG_HAS_TYPE_CHECK) {
mini/mini.c:		if (cfg->gdump_ctx != NULL) {
mini/mini.c:	if (cfg->has_emulated_ops) {
mini/mini.c:	if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini.c:	if (cfg->opt & MONO_OPT_DEADCE) {
mini/mini.c:	if (cfg->opt & MONO_OPT_ALIAS_ANALYSIS) {
mini/mini.c:	if (((cfg->num_varinfo > 2000) || (cfg->num_bblocks > 1000)) && !cfg->compile_aot) {
mini/mini.c:		cfg->opt &= ~ (MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP);
mini/mini.c:		cfg->disable_ssa = TRUE;
mini/mini.c:	if (cfg->opt & MONO_OPT_LOOP) {
mini/mini.c:	  cfg->disable_ssa = TRUE;
mini/mini.c:	if (!cfg->disable_ssa) {
mini/mini.c:	if (cfg->opt & MONO_OPT_SSA) {
mini/mini.c:		if (!(cfg->comp_done & MONO_COMP_SSA) && !cfg->disable_ssa) {
mini/mini.c:			if (cfg->verbose_level >= 2) {
mini/mini.c:	if ((cfg->opt & MONO_OPT_CONSPROP) || (cfg->opt & MONO_OPT_COPYPROP)) {
mini/mini.c:		if (cfg->comp_done & MONO_COMP_SSA && !COMPILE_LLVM (cfg)) {
mini/mini.c:	if (cfg->comp_done & MONO_COMP_SSA && !COMPILE_LLVM (cfg)) {
mini/mini.c:		if (cfg->opt & MONO_OPT_DEADCE) {
mini/mini.c:		if ((cfg->flags & (MONO_CFG_HAS_LDELEMA|MONO_CFG_HAS_CHECK_THIS)) && (cfg->opt & MONO_OPT_ABCREM)) {
mini/mini.c:		if (cfg->opt & MONO_OPT_DEADCE) {
mini/mini.c:		if (cfg->opt & MONO_OPT_BRANCH) {
mini/mini.c:	if (cfg->comp_done & MONO_COMP_SSA && COMPILE_LLVM (cfg)) {
mini/mini.c:		if (cfg->opt & MONO_OPT_ABCREM) {
mini/mini.c:	if (cfg->llvm_only && cfg->gsharedvt)
mini/mini.c:	if (cfg->flags & MONO_CFG_HAS_ARRAY_ACCESS) {
mini/mini.c:	if (cfg->got_var) {
mini/mini.c:		g_assert (cfg->got_var_allocated);
mini/mini.c:		cfg->got_var->opcode = OP_REGVAR;
mini/mini.c:		cfg->got_var->dreg = got_reg;
mini/mini.c:		cfg->used_int_regs |= 1LL << cfg->got_var->dreg;
mini/mini.c:	if (cfg->opt & MONO_OPT_LINEARS) {
mini/mini.c:		cfg->comp_done &= ~MONO_COMP_LIVENESS;
mini/mini.c:		if (!(cfg->comp_done & MONO_COMP_LIVENESS))
mini/mini.c:			if (cfg->got_var) {
mini/mini.c:					if (GPOINTER_TO_UINT (l->data) == cfg->got_var->dreg) {
mini/mini.c:			MONO_TIME_TRACK (mono_jit_stats.jit_linear_scan, mono_linear_scan (cfg, vars, regs, &cfg->used_int_regs));
mini/mini.c:		if (cfg->exception_type)
mini/mini.c:	if (cfg->gsharedvt)
mini/mini.c:		if (need_local_opts || cfg->compile_aot) {
mini/mini.c:			if (cfg->opt & MONO_OPT_DEADCE)
mini/mini.c:		if (!(cfg->comp_done & MONO_COMP_SSA)) {
mini/mini.c:			cfg->exception_message = g_strdup ("SSA disabled.");
mini/mini.c:			cfg->disable_llvm = TRUE;
mini/mini.c:		if (cfg->flags & MONO_CFG_HAS_ARRAY_ACCESS)
mini/mini.c:		if (!cfg->disable_llvm)
mini/mini.c:		if (cfg->disable_llvm) {
mini/mini.c:			if (cfg->verbose_level >= (cfg->llvm_only ? 0 : 1)) {
mini/mini.c:				//nm = mono_method_full_name (cfg->method, TRUE);
mini/mini.c:				printf ("LLVM failed for '%s': %s\n", method->name, cfg->exception_message);
mini/mini.c:			if (cfg->llvm_only) {
mini/mini.c:				cfg->disable_aot = TRUE;
mini/mini.c:		if (cfg->verbose_level > 0 && !cfg->compile_aot) {
mini/mini.c:			nm = mono_method_full_name (cfg->method, TRUE);
mini/mini.c:					 cfg->native_code, cfg->native_code + cfg->code_len, cfg->code_len, cfg->domain->friendly_name);
mini/mini.c:		if (cfg->exception_type)
mini/mini.c:	MONO_TIME_TRACK (mono_jit_stats.jit_create_jit_info, cfg->jit_info = create_jit_info (cfg, method_to_compile));
mini/mini.c:	if (cfg->extend_live_ranges) {
mini/mini.c:		for (i = 0; i < cfg->num_varinfo; ++i)
mini/mini.c:			MONO_VARINFO (cfg, i)->live_range_end = cfg->code_len;
mini/mini.c:	if (!cfg->compile_aot) {
mini/mini.c:	if (cfg->verbose_level >= 2) {
mini/mini.c:		char *id =  mono_method_full_name (cfg->method, FALSE);
mini/mini.c:		mono_disassemble_code (cfg, cfg->native_code, cfg->code_len, id + 3);
mini/mini.c:	if (!cfg->compile_aot && !(flags & JIT_FLAG_DISCARD_RESULTS)) {
mini/mini.c:		mono_domain_lock (cfg->domain);
mini/mini.c:		mono_jit_info_table_add (cfg->domain, cfg->jit_info);
mini/mini.c:		if (cfg->method->dynamic)
mini/mini.c:			mono_dynamic_code_hash_lookup (cfg->domain, cfg->method)->ji = cfg->jit_info;
mini/mini.c:		mono_domain_unlock (cfg->domain);
mini/mini.c:	if (cfg->gsharedvt)
mini/mini.c:		printf ("GSHAREDVT: %s\n", mono_method_full_name (cfg->method, TRUE));
mini/mini.c:	mono_jit_stats.allocated_code_size += cfg->code_len;
mini/mini.c:	code_size_ratio = cfg->code_len;
mini/mini.c:	mono_jit_stats.native_code_size += cfg->code_len;
mini/mini.c:	TryBlockHole *hole = (TryBlockHole *)mono_mempool_alloc (cfg->mempool, sizeof (TryBlockHole));
mini/mini.c:	hole->start_offset = start - cfg->native_code;
mini/mini.c:	cfg->try_block_holes = g_slist_append_mempool (cfg->mempool, cfg->try_block_holes, hole);
mini/mini.c:	cfg->exception_type = type;
mini/mini.c:	mono_error_set_generic_error (&cfg->error, "System", "InvalidProgramException", "%s", msg);
mini/mini.c:	mono_jit_stats.allocate_var += cfg->stat_allocate_var;
mini/mini.c:	mono_jit_stats.locals_stack_size += cfg->stat_locals_stack_size;
mini/mini.c:	mono_jit_stats.basic_blocks += cfg->stat_basic_blocks;
mini/mini.c:	mono_jit_stats.max_basic_blocks = MAX (cfg->stat_basic_blocks, mono_jit_stats.max_basic_blocks);
mini/mini.c:	mono_jit_stats.cil_code_size += cfg->stat_cil_code_size;
mini/mini.c:	mono_jit_stats.regvars += cfg->stat_n_regvars;
mini/mini.c:	mono_jit_stats.inlineable_methods += cfg->stat_inlineable_methods;
mini/mini.c:	mono_jit_stats.inlined_methods += cfg->stat_inlined_methods;
mini/mini.c:	mono_jit_stats.code_reallocs += cfg->stat_code_reallocs;
mini/mini.c:	prof_method = cfg->method;
mini/mini.c:	switch (cfg->exception_type) {
mini/mini.c:		if (cfg->exception_ptr) {
mini/mini.c:			ex = mono_class_get_exception_for_failure ((MonoClass *)cfg->exception_ptr);
mini/mini.c:			if (cfg->exception_type == MONO_EXCEPTION_MISSING_FIELD)
mini/mini.c:				ex = mono_exception_from_name_msg (mono_defaults.corlib, "System", "MissingFieldException", cfg->exception_message);
mini/mini.c:			else if (cfg->exception_type == MONO_EXCEPTION_MISSING_METHOD)
mini/mini.c:				ex = mono_exception_from_name_msg (mono_defaults.corlib, "System", "MissingMethodException", cfg->exception_message);
mini/mini.c:			else if (cfg->exception_type == MONO_EXCEPTION_TYPE_LOAD)
mini/mini.c:				ex = mono_exception_from_name_msg (mono_defaults.corlib, "System", "TypeLoadException", cfg->exception_message);
mini/mini.c:			else if (cfg->exception_type == MONO_EXCEPTION_FILE_NOT_FOUND)
mini/mini.c:				ex = mono_exception_from_name_msg (mono_defaults.corlib, "System.IO", "FileNotFoundException", cfg->exception_message);
mini/mini.c:			else if (cfg->exception_type == MONO_EXCEPTION_BAD_IMAGE)
mini/mini.c:				ex = mono_get_exception_bad_image_format (cfg->exception_message);
mini/mini.c:			else if (cfg->exception_type == MONO_EXCEPTION_INVALID_PROGRAM)
mini/mini.c:				ex = mono_exception_from_name_msg (mono_defaults.corlib, "System", "InvalidProgramException", cfg->exception_message);
mini/mini.c:		g_assert (!mono_error_ok (&cfg->error));
mini/mini.c:		ex = mono_error_convert_to_exception (&cfg->error);
mini/mini.c:		if (cfg->prof_options & MONO_PROFILE_JIT_COMPILATION)
mini/mini.c:		mono_internal_hash_table_insert (&target_domain->jit_code_hash, cfg->jit_info->d.method, cfg->jit_info);
mini/mini.c:		code = cfg->native_code;
mini/mini.c:		if (cfg->gshared && mono_method_is_generic_sharable (method, FALSE))
mini/mini.c:		if (cfg->gsharedvt)
mini/mini.c:	jinfo = cfg->jit_info;
mini/mini.c:	prof_options = cfg->prof_options;
mini/mini.h:	 * Has length cfg->num_varinfo in bits.
mini/mini.h:	guint           idx; /* inside cfg->varinfo, cfg->vars */
mini/mini.h:	 * cfg->varinfo [idx]->dreg could be replaced for OP_REGVAR, this contains the 
mini/seq-points.c:		if (in_bb == cfg->bb_entry)
mini/seq-points.c:		bb->pred_seq_points = (MonoInst **)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst *) * predecessors->len);
mini/seq-points.c:	if (bb->pred_seq_points == NULL && bb != cfg->bb_entry)
mini/seq-points.c:	MonoDomain *domain = cfg->domain;
mini/seq-points.c:	gboolean has_debug_data = cfg->gen_sdb_seq_points;
mini/seq-points.c:	if (!cfg->seq_points)
mini/seq-points.c:	seq_points = g_new0 (SeqPoint, cfg->seq_points->len);
mini/seq-points.c:	for (i = 0; i < cfg->seq_points->len; ++i) {
mini/seq-points.c:		MonoInst *ins = (MonoInst *)g_ptr_array_index (cfg->seq_points, i);
mini/seq-points.c:		next = g_new0 (GSList*, cfg->seq_points->len);
mini/seq-points.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/seq-points.c:					for (bb2 = cfg->bb_entry; bb2; bb2 = bb2->next_bb) {
mini/seq-points.c:		if (cfg->verbose_level > 2) {
mini/seq-points.c:			for (i = 0; i < cfg->seq_points->len; ++i) {
mini/seq-points.c:		for (i = 0; i < cfg->seq_points->len; ++i) {
mini/seq-points.c:	cfg->seq_point_info = mono_seq_point_info_new (array->len, TRUE, array->data, has_debug_data, &seq_info_size);
mini/seq-points.c:	if (!cfg->compile_aot) {
mini/seq-points.c:		if (!g_hash_table_lookup (domain_jit_info (domain)->seq_points, cfg->method_to_register))
mini/seq-points.c:			g_hash_table_insert (domain_jit_info (domain)->seq_points, cfg->method_to_register, cfg->seq_point_info);
mini/seq-points.c:	g_ptr_array_free (cfg->seq_points, TRUE);
mini/seq-points.c:	cfg->seq_points = NULL;
mini/simd-intrinsics.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/simd-intrinsics.c:		MonoInst *var = cfg->varinfo [i];
mini/simd-intrinsics.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/simd-intrinsics.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/simd-intrinsics.c:		MonoInst *var = cfg->varinfo [i];
mini/simd-intrinsics.c:		for (i = 0; i < cfg->num_varinfo; i++) {
mini/simd-intrinsics.c:			MonoInst *var = cfg->varinfo [i];
mini/simd-intrinsics.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/simd-intrinsics.c:		MonoInst *var = cfg->varinfo [i];
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	if (!cfg->fconv_to_r8_x_var) {
mini/simd-intrinsics.c:		cfg->fconv_to_r8_x_var = mono_compile_create_var (cfg, &mono_defaults.double_class->byval_arg, OP_LOCAL);
mini/simd-intrinsics.c:		cfg->fconv_to_r8_x_var->flags |= MONO_INST_VOLATILE; /*FIXME, use the don't regalloc flag*/
mini/simd-intrinsics.c:	return cfg->fconv_to_r8_x_var;
mini/simd-intrinsics.c:	if (!cfg->simd_ctor_var) {
mini/simd-intrinsics.c:		cfg->simd_ctor_var = mono_compile_create_var (cfg, &avector_klass->byval_arg, OP_LOCAL);
mini/simd-intrinsics.c:		cfg->simd_ctor_var->flags |= MONO_INST_VOLATILE; /*FIXME, use the don't regalloc flag*/
mini/simd-intrinsics.c:	return cfg->simd_ctor_var;
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	if ((index >> shift_bits) && !cfg->compile_llvm) {
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	if (cfg->compile_llvm)
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_INST_NEW (cfg, ins, cfg->r4fp ? OP_ICONV_TO_R4_RAW : OP_MOVE_I4_TO_F);
mini/simd-intrinsics.c:		ins->type = cfg->r4_stack_type;
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);	
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, load);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, store);
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:	cfg->uses_simd_intrinsics = 1;
mini/simd-intrinsics.c:	if (cfg->verbose_level > 1) {
mini/simd-intrinsics.c:		MONO_ADD_INS (cfg->cbb, zero);
mini/simd-intrinsics.c:	if (cfg->verbose_level > 1) {
mini/simd-intrinsics.c:			MONO_ADD_INS (cfg->cbb, ins);
mini/simd-intrinsics.c:			if (cfg->verbose_level > 1)
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_REACHABILITY);
mini/ssa.c:	if (G_UNLIKELY (cfg->verbose_level > 1))
mini/ssa.c:	for (bb = cfg->bb_entry; bb && bb->next_bb;) {
mini/ssa.c:	for (i = 1; i < cfg->num_bblocks; i++) {
mini/ssa.c:		bb = cfg->bblocks [i];
mini/ssa.c:			if (G_UNLIKELY (cfg->verbose_level > 1))
mini/ssa.c:	MonoVarUsageInfo *ui = (MonoVarUsageInfo *)mono_mempool_alloc (cfg->mempool, sizeof (MonoVarUsageInfo));
mini/ssa.c:	info->uses = g_list_prepend_mempool (cfg->mempool, info->uses, ui);
mini/ssa.c:	if (cfg->verbose_level >= 4)
mini/ssa.c:					if (cfg->verbose_level >= 4)
mini/ssa.c:					new_var = cfg->varinfo [idx];
mini/ssa.c:				if (G_UNLIKELY (cfg->verbose_level >= 4))
mini/ssa.c:	cfg->comp_done |= MONO_COMP_SSA_DEF_USE;
mini/ssa.c:	MonoMethodVar *vinfo = g_new0 (MonoMethodVar, cfg->num_varinfo);
mini/ssa.c:	g_assert (!(cfg->comp_done & MONO_COMP_SSA));
mini/ssa.c:	g_assert (!cfg->disable_ssa);
mini/ssa.c:	if (cfg->verbose_level >= 4)
mini/ssa.c:		printf ("\nCOMPUTE SSA %d (R%d-)\n\n", cfg->num_varinfo, cfg->next_vreg);
mini/ssa.c:	if (!(cfg->comp_done & MONO_COMP_LIVENESS))
mini/ssa.c:	bitsize = mono_bitset_alloc_size (cfg->num_bblocks, 0);
mini/ssa.c:	buf = buf_start = (guint8 *)g_malloc0 (mono_bitset_alloc_size (cfg->num_bblocks, 0) * cfg->num_varinfo);
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/ssa.c:		vinfo [i].def_in = mono_bitset_mem_new (buf, cfg->num_bblocks, 0);
mini/ssa.c:		if (cfg->varinfo [i]->opcode == OP_ARG)
mini/ssa.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/ssa.c:		MONO_BB_FOR_EACH_INS (cfg->bblocks [i], ins) {
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/ssa.c:		MonoInst *var = cfg->varinfo [i];
mini/ssa.c:		if (cfg->verbose_level >= 4) {
mini/ssa.c:		mono_bitset_foreach_bit (set, idx, cfg->num_bblocks) {
mini/ssa.c:			MonoBasicBlock *bb = cfg->bblocks [idx];
mini/ssa.c:			if (bb == cfg->bb_exit && !COMPILE_LLVM (cfg))
mini/ssa.c:			if ((cfg->comp_done & MONO_COMP_LIVENESS) && !mono_bitset_test_fast (bb->live_in_set, i)) {
mini/ssa.c:				//printf ("%d is not live in BB%d %s\n", i, bb->block_num, mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:			ins->inst_phi_args = (int *)mono_mempool_alloc0 (cfg->mempool, sizeof (int) * (cfg->bblocks [idx]->in_count + 1));
mini/ssa.c:			ins->inst_phi_args [0] = cfg->bblocks [idx]->in_count;
mini/ssa.c:			for (j = 0; j < cfg->bblocks [idx]->in_count; ++j)
mini/ssa.c:			ins->dreg = cfg->varinfo [i]->dreg;
mini/ssa.c:			printf ("ADD PHI BB%d %s\n", cfg->bblocks [idx]->block_num, mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:	stack = (MonoInst **)alloca (sizeof (MonoInst *) * cfg->num_varinfo);
mini/ssa.c:	memset (stack, 0, sizeof (MonoInst *) * cfg->num_varinfo);
mini/ssa.c:	lvreg_stack = g_new0 (guint32, cfg->next_vreg);
mini/ssa.c:	lvreg_defined = g_new0 (gboolean, cfg->next_vreg);
mini/ssa.c:	originals = g_new0 (gboolean, cfg->num_varinfo);
mini/ssa.c:	mono_ssa_rename_vars (cfg, cfg->num_varinfo, cfg->bb_entry, originals, stack, lvreg_stack, lvreg_defined, stack_history, stack_history_size);
mini/ssa.c:	if (cfg->verbose_level >= 4)
mini/ssa.c:	cfg->comp_done |= MONO_COMP_SSA;
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA);
mini/ssa.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/ssa.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/ssa.c:		if (cfg->verbose_level >= 4)
mini/ssa.c:					if (cfg->verbose_level >= 4)
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA);
mini/ssa.c:	for (i = 0; i < cfg->num_bblocks; ++i) {
mini/ssa.c:		MonoBasicBlock *bb = cfg->bblocks [i];
mini/ssa.c:		if (cfg->verbose_level >= 4)
mini/ssa.c:						if (cfg->verbose_level >= 4)
mini/ssa.c:	if (cfg->verbose_level >= 4) {
mini/ssa.c:		for (i = 0; i < cfg->num_bblocks; ++i) {
mini/ssa.c:			MonoBasicBlock *bb = cfg->bblocks [i];
mini/ssa.c:	for (bbindex = 0; bbindex < cfg->num_bblocks; ++bbindex) {
mini/ssa.c:		MonoBasicBlock *bb = cfg->bblocks [bbindex];
mini/ssa.c:						printf ("COALESCE: R%d -> R%d\n", ins->dreg, cfg->varinfo [vmv->reg]->dreg);
mini/ssa.c:						ins->dreg = cfg->varinfo [vmv->reg]->dreg; 
mini/ssa.c:						printf ("COALESCE: R%d -> R%d\n", sregs [i], cfg->varinfo [vmv->reg]->dreg);
mini/ssa.c:						sregs [i] = cfg->varinfo [vmv->reg]->dreg;
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; ++i) {
mini/ssa.c:	if (cfg->comp_done & MONO_COMP_REACHABILITY)
mini/ssa.c:	cfg->comp_done &= ~MONO_COMP_LIVENESS;
mini/ssa.c:	cfg->comp_done &= ~MONO_COMP_SSA;
mini/ssa.c:	g_assert (!(cfg->comp_done & MONO_COMP_SSA_DEF_USE));
mini/ssa.c:	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/ssa.c:	cfg->comp_done |= MONO_COMP_SSA_DEF_USE;
mini/ssa.c:	g_assert ((cfg->comp_done & MONO_COMP_SSA_DEF_USE));
mini/ssa.c:	for (index = 0; index < cfg->num_varinfo; ++index) {
mini/ssa.c:		MonoInst *var = cfg->varinfo [index];
mini/ssa.c:	if (cfg->verbose_level >= 4) {
mini/ssa.c:		for (bb = cfg->bb_entry; bb; bb = bb->next_bb)
mini/ssa.c:			if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/ssa.c:	if (G_UNLIKELY (cfg->verbose_level > 1))
mini/ssa.c:		printf ("\tState of R%d set to %d\n", cfg->varinfo [info->idx]->dreg, info->cpstate);
mini/ssa.c:	carray [cfg->varinfo [info->idx]->dreg] = c0;
mini/ssa.c:	if (G_UNLIKELY (cfg->verbose_level > 1))
mini/ssa.c:	if (cfg->verbose_level > 1)
mini/ssa.c:					if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/ssa.c:				if (G_UNLIKELY (cfg->verbose_level > 1)) {
mini/ssa.c:	//printf ("SIMPLE OPTS BB%d %s\n", bb->block_num, mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:	carray = g_new0 (MonoInst*, cfg->next_vreg);
mini/ssa.c:	if (!(cfg->comp_done & MONO_COMP_SSA_DEF_USE))
mini/ssa.c:	bblock_list = g_list_prepend (NULL, cfg->bb_entry);
mini/ssa.c:	cfg->bb_entry->flags |= BB_REACHABLE;
mini/ssa.c:	memset (carray, 0, sizeof (MonoInst *) * cfg->num_varinfo);
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/ssa.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/ssa.c:		if (cfg->verbose_level > 1)
mini/ssa.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/ssa.c:	cfg->comp_done |= MONO_COMP_REACHABILITY;
mini/ssa.c:	cfg->comp_done &=  ~MONO_COMP_SSA_DEF_USE;
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/ssa.c:	*wl = g_list_prepend_mempool (cfg->mempool, *wl, use);
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA);
mini/ssa.c:	//printf ("DEADCE %s\n", mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:	if (!(cfg->comp_done & MONO_COMP_SSA_DEF_USE))
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/ssa.c:		work_list = g_list_prepend_mempool (cfg->mempool, work_list, info);
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA);
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_LOOPS);
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA_DEF_USE);
mini/ssa.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/ssa.c:			for (i = 0; i < cfg->num_varinfo; i++) {
mini/ssa.c:					printf ("FOUND %d in %s\n", info->idx, mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:	g_assert (cfg->comp_done & MONO_COMP_SSA);
mini/ssa.c:	if (!(cfg->comp_done & MONO_COMP_LOOPS) || !(cfg->comp_done & MONO_COMP_SSA_DEF_USE))
mini/ssa.c:	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
mini/ssa.c:					  printf ("%s\n", mono_method_full_name (cfg->method, TRUE));
mini/ssa.c:				if (cfg->verbose_level > 1) {
mini/ssa.c:	cfg->comp_done &=  ~MONO_COMP_SSA_DEF_USE;
mini/ssa.c:	for (i = 0; i < cfg->num_varinfo; i++) {
mini/type-checking.c:	if (cfg->gshared)
mini/type-checking.c:	cfg->castclass_cache_index ++;
mini/type-checking.c:	return (cfg->method_index << 16) | cfg->castclass_cache_index;
mini/type-checking.c:	} else if (cfg->compile_aot) {
mini/type-checking.c:	MONO_ADD_INS (cfg->cbb, ins);
mini/type-checking.c:	if (cfg->compile_aot) {
mini/type-checking.c:	if (cfg->compile_aot) {
mini/type-checking.c:	if (cfg->compile_aot) {
mini/type-checking.c:		if (!klass->rank && !cfg->compile_aot && !(cfg->opt & MONO_OPT_SHARED) && mono_class_is_sealed (klass)) {
mini/type-checking.c:				MonoVTable *vt = mono_class_vtable (cfg->domain, klass);
mini/type-checking.c:					cfg->exception_ptr = klass;
mini/type-checking.c:			if (!cfg->compile_aot && !(cfg->opt & MONO_OPT_SHARED) && mono_class_is_sealed (klass)) {
mini/type-checking.c:					MonoVTable *vt = mono_class_vtable (cfg->domain, klass);
mini/type-checking.c:						cfg->exception_ptr = klass;
mini/type-checking.c:	cfg->cbb = first_bb;
mini/type-checking.c:	g_assert (cfg->cbb->code || first_bb->code);
mini/type-checking.c:	mono_replace_ins (cfg, bb, ins, &prev, first_bb, cfg->cbb);
mini/type-checking.c:	for (MonoBasicBlock *bb = cfg->bb_entry; bb; bb = bb->next_bb) {
mini/type-checking.c:	if ((cfg->verbose_level > 2) && found_typetest)
mini/xdebug.c:		dmji = mono_debug_find_method (jinfo_get_method (cfg->jit_info), mono_domain_get ());;
mini/xdebug.c:		mono_dwarf_writer_emit_method (xdebug_writer, cfg, jinfo_get_method (cfg->jit_info), NULL, NULL, NULL,
mini/xdebug.c:									   cfg->jit_info->code_start, cfg->jit_info->code_size, cfg->args, cfg->locals, cfg->unwind_ops, dmji);
mini/xdebug.c:		sym = get_debug_sym (cfg->jit_info->method, "", xdebug_syms);
mini/xdebug.c:			xdebug_text_addr = cfg->jit_info->code_start;
mini/xdebug.c:		mono_img_writer_emit_global_with_size (w, sym, cfg->jit_info->code_size, TRUE);
mini/xdebug.c:		mono_img_writer_emit_bytes (w, cfg->jit_info->code_start, cfg->jit_info->code_size);
mini/xdebug.c:		dmji = mono_debug_find_method (jinfo_get_method (cfg->jit_info), mono_domain_get ());
mini/xdebug.c:		mono_dwarf_writer_emit_method (xdebug_writer, cfg, jinfo_get_method (cfg->jit_info), NULL, NULL, NULL,
mini/xdebug.c:									   cfg->jit_info->code_start, cfg->jit_info->code_size, cfg->args, cfg->locals, cfg->unwind_ops, dmji);
